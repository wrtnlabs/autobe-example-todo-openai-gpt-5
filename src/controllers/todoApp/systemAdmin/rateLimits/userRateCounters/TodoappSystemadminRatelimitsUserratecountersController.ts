import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { patchtodoAppSystemAdminRateLimitsRateLimitIdUserRateCounters } from "../../../../../providers/patchtodoAppSystemAdminRateLimitsRateLimitIdUserRateCounters";
import { SystemadminAuth } from "../../../../../decorators/SystemadminAuth";
import { SystemadminPayload } from "../../../../../decorators/payload/SystemadminPayload";
import { gettodoAppSystemAdminRateLimitsRateLimitIdUserRateCountersUserRateCounterId } from "../../../../../providers/gettodoAppSystemAdminRateLimitsRateLimitIdUserRateCountersUserRateCounterId";

import { IPageITodoAppUserRateCounter } from "../../../../../api/structures/IPageITodoAppUserRateCounter";
import { ITodoAppUserRateCounter } from "../../../../../api/structures/ITodoAppUserRateCounter";

@Controller("/todoApp/systemAdmin/rateLimits/:rateLimitId/userRateCounters")
export class TodoappSystemadminRatelimitsUserratecountersController {
  /**
   * Search user rate counters by policy (todo_app_user_rate_counters).
   *
   * This operation returns user rate counter windows for a particular policy
   * identified by rateLimitId. The underlying Prisma model
   * todo_app_user_rate_counters contains references to todo_app_rate_limits
   * (todo_app_rate_limit_id) and to users (todo_app_user_id), along with
   * window_started_at/window_ends_at, count, last_action_at, and optional
   * blocked_until for cooldowns. Restricting by policy via the path parameter
   * aligns with common admin workflows that examine policy-specific impacts
   * across users.
   *
   * Security and permissions: Access is limited to administrators (systemAdmin)
   * due to the cross-user operational detail exposed. Implementations should
   * exclude records where deleted_at is present by default, consistent with
   * retention handling.
   *
   * Entity relationships and filtering: The IRequest payload may include
   * pagination, sorting, and additional filters such as userId, window overlap
   * periods, whether blocked_until is set or in the future, and ordering
   * preferences. The service must apply the policy constraint derived from the
   * path parameter in addition to any request body filters.
   *
   * Related operations: Use PATCH /userRateCounters for a global search across
   * all policies or GET /userRateCounters/{userRateCounterId} for a single
   * record. Policy configurations themselves are managed via the
   * todo_app_rate_limits entity in separate administrative surfaces.
   *
   * Error handling: Invalid UUID for rateLimitId should cause a validation
   * error. Authorization failures should deny access. An empty result is
   * returned as an empty page with pagination metadata.
   *
   * @param connection
   * @param rateLimitId Rate limit policy ID to scope user rate counter results
   * @param body Additional filters, sorting, and pagination for counters within
   *   the policy
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @SystemadminAuth()
    systemAdmin: SystemadminPayload,
    @TypedParam("rateLimitId")
    rateLimitId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ITodoAppUserRateCounter.IRequest,
  ): Promise<IPageITodoAppUserRateCounter> {
    try {
      return await patchtodoAppSystemAdminRateLimitsRateLimitIdUserRateCounters(
        {
          systemAdmin,
          rateLimitId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get a single user rate counter (todo_app_user_rate_counters) under a
   * specific rate limit.
   *
   * Fetch detailed information about a single user rate counter record tied to
   * a specific rate limit policy. The underlying Prisma model
   * todo_app_user_rate_counters stores per-user counters with fields including
   * id (UUID), todo_app_rate_limit_id (link to todo_app_rate_limits),
   * todo_app_user_id (link to todo_app_users), window_started_at,
   * window_ends_at, count, last_action_at, blocked_until, and system timestamps
   * (created_at, updated_at). The schema comment explains this table is used to
   * enforce fair-use and cooldowns and is not directly managed by end users.
   *
   * Security and authorization: Access to user-level counters exposes
   * operational telemetry and must be restricted. Only system administrators
   * should query arbitrary users’ counters for investigations and support. End
   * users do not modify these records; the system updates them as requests are
   * processed. Implementations should ensure that records with archival markers
   * (deleted_at not null) are excluded from normal responses unless an explicit
   * audit mode is used.
   *
   * Data relationships and validation: The returned record references
   * todo_app_rate_limits via todo_app_rate_limit_id to bind the counter to a
   * configured policy (window_seconds, max_requests, scope, category). It also
   * references todo_app_users via todo_app_user_id to identify the subject
   * account. The path requires both rateLimitId and userRateCounterId;
   * providers should verify that the counter’s todo_app_rate_limit_id matches
   * the rateLimitId to prevent cross-policy leakage. If not found or
   * mismatched, return a not-found outcome.
   *
   * Usage and error handling: Typical use cases include diagnosing throttled
   * users (blocked_until set), verifying counter behavior within a window
   * (window_started_at/window_ends_at), and correlating with admin actions or
   * audit logs. Error scenarios include nonexistent IDs, mismatched
   * parent-child relation (counter not under the specified rate limit), or
   * access without sufficient privileges. As this is a read-only operation, no
   * side effects occur.
   *
   * @param connection
   * @param rateLimitId Target rate limit policy ID to which the user rate
   *   counter must belong.
   * @param userRateCounterId Identifier of the user rate counter to retrieve.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":userRateCounterId")
  public async at(
    @SystemadminAuth()
    systemAdmin: SystemadminPayload,
    @TypedParam("rateLimitId")
    rateLimitId: string & tags.Format<"uuid">,
    @TypedParam("userRateCounterId")
    userRateCounterId: string & tags.Format<"uuid">,
  ): Promise<ITodoAppUserRateCounter> {
    try {
      return await gettodoAppSystemAdminRateLimitsRateLimitIdUserRateCountersUserRateCounterId(
        {
          systemAdmin,
          rateLimitId,
          userRateCounterId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
