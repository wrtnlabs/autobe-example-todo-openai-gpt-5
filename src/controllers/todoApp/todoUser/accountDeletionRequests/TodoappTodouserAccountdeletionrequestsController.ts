import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody, TypedParam } from "@nestia/core";
import typia, { tags } from "typia";
import { patchtodoAppTodoUserAccountDeletionRequests } from "../../../../providers/patchtodoAppTodoUserAccountDeletionRequests";
import { TodouserAuth } from "../../../../decorators/TodouserAuth";
import { TodouserPayload } from "../../../../decorators/payload/TodouserPayload";
import { gettodoAppTodoUserAccountDeletionRequestsAccountDeletionRequestId } from "../../../../providers/gettodoAppTodoUserAccountDeletionRequestsAccountDeletionRequestId";

import { IPageITodoAppAccountDeletionRequest } from "../../../../api/structures/IPageITodoAppAccountDeletionRequest";
import { ITodoAppAccountDeletionRequest } from "../../../../api/structures/ITodoAppAccountDeletionRequest";

@Controller("/todoApp/todoUser/accountDeletionRequests")
export class TodoappTodouserAccountdeletionrequestsController {
  /**
   * List/search account deletion requests (todo_app_account_deletion_requests)
   * for the authenticated user.
   *
   * This operation lists account deletion request records for the signed-in
   * user from the todo_app_account_deletion_requests table. The model includes
   * fields for status, reason, confirmed_at, scheduled_purge_at, processed_at,
   * canceled_at, request_ip, request_user_agent, created_at, updated_at, and a
   * logical deletion timestamp used for retention. Ownership is enforced
   * through todo_app_user_id referencing todo_app_users.id.
   *
   * Security and permissions: only authenticated users in the todoUser role may
   * view their own deletion requests. The provider must filter by
   * todo_app_account_deletion_requests.todo_app_user_id = auth.userId.
   * Administrative oversight of deletion workflows across users is handled via
   * separate governance endpoints and is not in scope here.
   *
   * Filtering, sorting, pagination: clients may filter by status to track where
   * a request is in its lifecycle (pending_confirmation, scheduled, canceled,
   * completed). Time-based filters on created_at, confirmed_at,
   * scheduled_purge_at, processed_at, and canceled_at support history
   * inspection and monitoring. Sorting supports created_at and
   * scheduled_purge_at fields, with created_at descending as default.
   * Pagination respects user preferences or explicit request parameters.
   *
   * Behavior and validations: once a request is scheduled, the
   * scheduled_purge_at indicates when purge processing begins according to
   * policy; processed_at captures completion. Records flagged for lifecycle
   * retention via the deleted timestamp should be hidden from normal listings.
   * This list endpoint does not modify state; cancellation or creation of
   * requests is performed by separate endpoints.
   *
   * Related operations: use GET
   * /todoApp/todoUser/accountDeletionRequests/{accountDeletionRequestId} to
   * retrieve details about a specific deletion request. Creation, confirmation,
   * cancellation, and scheduling occur through dedicated endpoints not covered
   * here.
   *
   * @param connection
   * @param body Search, filter, sort, and pagination parameters for account
   *   deletion requests
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedBody()
    body: ITodoAppAccountDeletionRequest.IRequest,
  ): Promise<IPageITodoAppAccountDeletionRequest.ISummary> {
    try {
      return await patchtodoAppTodoUserAccountDeletionRequests({
        todoUser,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get a specific account deletion request
   * (todo_app_account_deletion_requests) by ID for the authenticated user.
   *
   * This operation fetches a specific account deletion request from
   * todo_app_account_deletion_requests by primary key id. The entity tracks
   * request lifecycle through status and timestamps including confirmed_at,
   * scheduled_purge_at, processed_at, and canceled_at, and stores request_ip
   * and request_user_agent for traceability. The record’s ownership is enforced
   * via todo_app_user_id referencing todo_app_users.id, and implementations
   * must prevent cross-user access.
   *
   * Security: available to authenticated users (todoUser role) for their own
   * records only. Requests for another user’s identifier should be denied
   * without revealing whether a record exists. Administrative reviews across
   * multiple users are handled by separate governance operations and are
   * excluded here.
   *
   * Behavior: status communicates the current stage of the workflow (e.g.,
   * pending_confirmation, scheduled, canceled, completed). The presence of a
   * logical deletion timestamp indicates records intended for retention
   * workflows and such entries should not be returned by this endpoint. Clients
   * may use scheduled_purge_at to communicate expected purge timing and
   * processed_at to indicate completion.
   *
   * Related operations: to browse multiple requests with filters or to track
   * history, use PATCH /todoApp/todoUser/accountDeletionRequests. Lifecycle
   * transitions (create/confirm/cancel) are handled elsewhere.
   *
   * @param connection
   * @param accountDeletionRequestId Identifier of the account deletion request
   *   (UUID)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":accountDeletionRequestId")
  public async at(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("accountDeletionRequestId")
    accountDeletionRequestId: string & tags.Format<"uuid">,
  ): Promise<ITodoAppAccountDeletionRequest> {
    try {
      return await gettodoAppTodoUserAccountDeletionRequestsAccountDeletionRequestId(
        {
          todoUser,
          accountDeletionRequestId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
