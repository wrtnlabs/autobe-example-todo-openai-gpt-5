import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { gettodoAppTodoUserUsersUserIdPreferences } from "../../../../../providers/gettodoAppTodoUserUsersUserIdPreferences";
import { TodouserAuth } from "../../../../../decorators/TodouserAuth";
import { TodouserPayload } from "../../../../../decorators/payload/TodouserPayload";
import { posttodoAppTodoUserUsersUserIdPreferences } from "../../../../../providers/posttodoAppTodoUserUsersUserIdPreferences";
import { puttodoAppTodoUserUsersUserIdPreferences } from "../../../../../providers/puttodoAppTodoUserUsersUserIdPreferences";
import { deletetodoAppTodoUserUsersUserIdPreferences } from "../../../../../providers/deletetodoAppTodoUserUsersUserIdPreferences";

import { ITodoAppUserPreference } from "../../../../../api/structures/ITodoAppUserPreference";

@Controller("/todoApp/todoUser/users/:userId/preferences")
export class TodoappTodouserUsersPreferencesController {
  /**
   * Get user preferences (todo_app_user_preferences) for the specified userId.
   *
   * This operation fetches per-user preference settings from
   * todo_app_user_preferences. Fields include timezone (e.g., "Asia/Seoul"),
   * locale (e.g., "en-US"), and page_size (integer, typical allowed range 1–100
   * per business rules). The model is one-to-one with todo_app_users through
   * todo_app_user_preferences.todo_app_user_id and maintains
   * created_at/updated_at timestamps with an additional deleted_at timestamp
   * for lifecycle control.
   *
   * Security: Only authenticated end users (todoUser) can access their own
   * preferences. The controller/provider must verify that the authenticated
   * user’s id matches the {userId} path parameter. Administrative access to
   * private preference values is not part of routine operations for MVP.
   *
   * Behavior and error handling: If no preferences record exists for the user,
   * the service may either return not-found or elect to lazily initialize
   * defaults at a higher layer; this API describes retrieval only and does not
   * perform creation. Records where deleted_at is non-null should be ignored
   * for normal reads. Validation is not required for GET, but downstream
   * consumers should interpret timezone and locale per their standards.
   *
   * Related operations: Separate endpoints (not defined here) would handle
   * creation or update of preferences. This GET operation solely returns the
   * existing preferences for the specified userId.
   *
   * @param connection
   * @param userId Unique identifier of the user whose preferences are
   *   requested.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get()
  public async at(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
  ): Promise<ITodoAppUserPreference> {
    try {
      return await gettodoAppTodoUserUsersUserIdPreferences({
        todoUser,
        userId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Create a user preference record (todo_app_user_preferences) for the
   * specified user.
   *
   * Create a user preference record bound to the owner identified by userId.
   * According to the Prisma schema for todo_app_user_preferences, this table
   * stores per-user settings: timezone (IANA identifier such as "Asia/Seoul"),
   * locale (BCP 47 tag such as "en-US"), and page_size (integer with business
   * rule range 1–100). The model also contains created_at, updated_at, and an
   * optional deleted_at. The relationship to todo_app_users is one-to-one
   * through todo_app_user_id with a unique constraint, ensuring each account
   * has at most one preference record.
   *
   * Security considerations: Only the authenticated owner should be able to
   * create their own preferences. The authorization role is limited to
   * todoUser, with ownership validation performed in application logic to
   * ensure the path parameter userId matches the authenticated principal.
   * Administrative accounts do not routinely create or modify end-user
   * preferences.
   *
   * Relationship to underlying entities: The preference record references
   * todo_app_users via a required FK. The table’s columns (timezone, locale,
   * page_size) directly influence business behavior, such as timezone-aware
   * interpretation for due_at in todo_app_todos and default page sizes for list
   * endpoints. Creation should populate created_at/updated_at, leaving
   * deleted_at null. Attempts to create a second record must be rejected due to
   * the unique constraint on todo_app_user_id.
   *
   * Validation and business logic: Enforce that page_size respects business
   * limits (typically 1–100). Validate timezone strings against known IANA
   * identifiers and locale strings against BCP 47 format. If validation fails,
   * return a clear error. If a record already exists for the user, return a
   * conflict response.
   *
   * Related operations: Use PUT /users/{userId}/preferences to update an
   * existing record. There is no separate delete endpoint in this scope;
   * preference lifecycle can be handled via updates or administrative processes
   * if needed.
   *
   * Error handling: Return validation errors for bad timezone/locale formats or
   * out-of-range page_size. Return conflict if a record for the given user
   * already exists. Ensure ownership checks deny cross-user attempts without
   * revealing existence of other users’ data.
   *
   * @param connection
   * @param userId Owner user’s ID whose preferences are being created.
   * @param body Initial preference settings for the user, including timezone,
   *   locale, and page size.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ITodoAppUserPreference.ICreate,
  ): Promise<ITodoAppUserPreference> {
    try {
      return await posttodoAppTodoUserUsersUserIdPreferences({
        todoUser,
        userId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update an existing user preference record (todo_app_user_preferences) for
   * the specified user.
   *
   * Update the user’s existing preference record indicated by userId. Per the
   * Prisma schema for todo_app_user_preferences, this table holds: timezone
   * (IANA identifier), locale (BCP 47 tag), and page_size (integer).
   * System-managed timestamps include created_at and updated_at; deleted_at is
   * optional. The foreign key todo_app_user_id enforces ownership and
   * uniqueness across users.
   *
   * Security and permissions: Only the authenticated owner should update their
   * own preferences. The authorization role is todoUser, with ownership
   * verified in application logic by comparing the authenticated principal to
   * the path parameter userId. Administrative actors do not routinely edit
   * private user preferences.
   *
   * Entity relationships: The preference record is 1:1 with todo_app_users
   * (unique on todo_app_user_id). Preference values impact interpretation of
   * due_at in todo_app_todos (timezone) and display language (locale), as well
   * as default pagination size for list endpoints (page_size).
   *
   * Validation rules and business logic: Validate timezone against IANA
   * identifiers, locale against BCP 47, and page_size within allowed range
   * (1–100). Update should set updated_at to the current time. If the
   * preference record does not exist for the user, return a not found error,
   * avoiding disclosure beyond the current user context.
   *
   * Related operations: Use POST /users/{userId}/preferences to create a
   * preference record if none exists. Reading preferences can be exposed via a
   * corresponding GET endpoint if required by the client design.
   *
   * Error handling: Provide field-specific validation messages on incorrect
   * formats or ranges. Return not found when no preference record exists for
   * the user. Deny access if an authenticated user attempts to modify another
   * user’s preferences.
   *
   * @param connection
   * @param userId Owner user’s ID whose preferences are being updated.
   * @param body Partial or full updates to timezone, locale, and page size.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put()
  public async update(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ITodoAppUserPreference.IUpdate,
  ): Promise<ITodoAppUserPreference> {
    try {
      return await puttodoAppTodoUserUsersUserIdPreferences({
        todoUser,
        userId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Logically delete user preferences (todo_app_user_preferences) by userId.
   *
   * This endpoint marks the preferences record in todo_app_user_preferences as
   * deleted by setting deleted_at. The preferences table is 1:1 with
   * todo_app_users via todo_app_user_id and stores user-controlled presentation
   * and behavior such as timezone, locale, and page_size. Logical deletion
   * preserves history and supports retention workflows consistent with the
   * presence of the deleted_at column in the schema.
   *
   * Security and permissions: only the owner (role "todoUser") can delete their
   * preferences. The provider must verify that the path userId corresponds to
   * the authenticated user, and deny access for cross-user attempts without
   * revealing whether a preferences record exists.
   *
   * Database relationships: the unique constraint on todo_app_user_id ensures a
   * single preferences row per user. This endpoint addresses the preferences by
   * userId rather than a separate preferencesId, aligning with the 1:1 model
   * and typical self-service flows.
   *
   * Behavior and validation: if a preferences record is already deleted or does
   * not exist, the operation should be treated as idempotent with the
   * postcondition that no active preferences remain. Downstream systems
   * interpreting due dates and UI text (timezone, locale, page_size) should
   * fall back to service defaults after deletion until a new preferences record
   * is created.
   *
   * Related operations: separate endpoints typically allow creating or updating
   * preferences. Administrative access to private preference values is out of
   * routine scope.
   *
   * Error handling: validate userId as UUID. Deny unauthenticated requests.
   * Ensure rate limits are respected for destructive actions. The operation
   * sets deleted_at and excludes the record from subsequent normal reads.
   *
   * @param connection
   * @param userId Identifier of the owning user whose preferences should be
   *   deleted
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete()
  public async erase(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deletetodoAppTodoUserUsersUserIdPreferences({
        todoUser,
        userId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
