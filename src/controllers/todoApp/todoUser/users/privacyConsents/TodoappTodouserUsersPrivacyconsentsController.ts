import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { posttodoAppTodoUserUsersUserIdPrivacyConsents } from "../../../../../providers/posttodoAppTodoUserUsersUserIdPrivacyConsents";
import { TodouserAuth } from "../../../../../decorators/TodouserAuth";
import { TodouserPayload } from "../../../../../decorators/payload/TodouserPayload";
import { patchtodoAppTodoUserUsersUserIdPrivacyConsents } from "../../../../../providers/patchtodoAppTodoUserUsersUserIdPrivacyConsents";
import { gettodoAppTodoUserUsersUserIdPrivacyConsentsPrivacyConsentId } from "../../../../../providers/gettodoAppTodoUserUsersUserIdPrivacyConsentsPrivacyConsentId";

import { ITodoAppPrivacyConsent } from "../../../../../api/structures/ITodoAppPrivacyConsent";
import { IPageITodoAppPrivacyConsent } from "../../../../../api/structures/IPageITodoAppPrivacyConsent";

@Controller("/todoApp/todoUser/users/:userId/privacyConsents")
export class TodoappTodouserUsersPrivacyconsentsController {
  /**
   * Create a new privacy consent event (todo_app_privacy_consents).
   *
   * Create a privacy consent record for the account identified by userId using
   * the append-only model of todo_app_privacy_consents. Each row represents a
   * consent action with fields including purpose_code, purpose_name, granted
   * (true to grant, false to deny/withdraw), granted_at, optional revoked_at
   * and expires_at, policy_version, and optional source, ip, and user_agent.
   * The ownership link is todo_app_user_id; created_at and updated_at
   * timestamps support auditing and reporting.
   *
   * Security and permissions: Only the authenticated owner (role todoUser) may
   * create consent records for their own account. The controller must verify
   * the path userId equals the authenticated subject. Administrative users do
   * not use this endpoint for routine operations.
   *
   * Validation and business rules: Ensure required fields are present and
   * consistent. When granted is true, granted_at should be set; when
   * representing a withdrawal, granted may be false and revoked_at may be set
   * according to policy. purpose_code and policy_version must be valid per
   * current notices/policies. Optional metadata (source, ip, user_agent) may be
   * captured from the request.
   *
   * Related operations: Use PATCH /users/{userId}/privacyConsents to search
   * existing history and GET /users/{userId}/privacyConsents/{privacyConsentId}
   * to view a specific event. Updates to prior records are not typical; changes
   * are recorded as new rows to preserve history.
   *
   * Error handling: Reject attempts to write for another user’s account.
   * Validate enum-like domain values (e.g., format or policy-defined lists for
   * purpose_code) and timestamp fields. Return clear messages on validation
   * failures.
   *
   * @param connection
   * @param userId Owner user’s ID for whom the consent event is recorded
   * @param body Consent creation payload describing purpose, grant/withdrawal,
   *   and policy context
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ITodoAppPrivacyConsent.ICreate,
  ): Promise<ITodoAppPrivacyConsent> {
    try {
      return await posttodoAppTodoUserUsersUserIdPrivacyConsents({
        todoUser,
        userId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search a user’s privacy consent history (todo_app_privacy_consents).
   *
   * Retrieve a filtered, paginated list of privacy consent records for the
   * account identified by userId using the Prisma model
   * todo_app_privacy_consents. This table preserves a historical trail of
   * consent actions with fields including purpose_code, purpose_name, granted
   * (boolean), granted_at, revoked_at (when applicable), expires_at (optional),
   * policy_version, source, ip, and user_agent. The record links to the owner
   * via todo_app_user_id and includes created_at and updated_at for temporal
   * querying.
   *
   * Security and permissions: Only the authenticated owner with role todoUser
   * may list their own privacy consent history. The implementation must ensure
   * the path userId matches the authenticated subject. Administrative use cases
   * review aggregated or non-personal data through separate mechanisms; routine
   * access to private consent content is not permitted.
   *
   * Query behavior: The request body supports search parameters such as purpose
   * filters (by purpose_code or purpose_name), status filters (currently active
   * grants vs revoked), time windows (granted_at ranges, revoked_at ranges,
   * expires_at ranges), and sorting preferences (e.g., granted_at desc by
   * default). Pagination parameters (page, page_size) should follow
   * service-wide conventions with typical limits (e.g., 1–100). The endpoint
   * returns a paginated page wrapper whose data elements are consent records.
   *
   * Related operations: Use POST /users/{userId}/privacyConsents to append a
   * new consent event (grant or withdrawal). Use GET
   * /users/{userId}/privacyConsents/{privacyConsentId} to retrieve a specific
   * consent action by identifier.
   *
   * Error handling: Deny access if the userId does not match the authenticated
   * subject. Validate pagination bounds and filter formats; provide clear
   * messages when constraints are violated.
   *
   * @param connection
   * @param userId Owner user’s ID whose privacy consents are being listed
   * @param body Search, filter, and pagination parameters for listing privacy
   *   consents
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ITodoAppPrivacyConsent.IRequest,
  ): Promise<IPageITodoAppPrivacyConsent> {
    try {
      return await patchtodoAppTodoUserUsersUserIdPrivacyConsents({
        todoUser,
        userId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get a specific privacy consent by ID (todo_app_privacy_consents).
   *
   * Return a single privacy consent record from todo_app_privacy_consents
   * matching privacyConsentId that belongs to the account identified by userId.
   * The consent record contains business fields like purpose_code,
   * purpose_name, granted, granted_at, optional revoked_at and expires_at,
   * policy_version, and optional source, ip, and user_agent for traceability.
   * Ownership is enforced via todo_app_user_id; temporal fields
   * (created_at/updated_at) support auditing.
   *
   * Security and permissions: Only the authenticated owner with role todoUser
   * may access this resource, and the path userId must match the authenticated
   * subject. The implementation must also verify ownership: the consent
   * record’s todo_app_user_id equals userId. Requests for resources not owned
   * by the caller must be denied without revealing existence.
   *
   * Behavior and validation: If the record is not found or does not belong to
   * the specified user, return a not-found style response without disclosing
   * sensitive details. This endpoint is read-only and returns the stored
   * consent event as-is, reflecting the append-only design for consent
   * history.
   *
   * Related operations: Use PATCH /users/{userId}/privacyConsents to search a
   * user’s consent history. Use POST /users/{userId}/privacyConsents to append
   * a new consent decision event.
   *
   * Error handling: Handle invalid UUID formats for either path parameter with
   * appropriate validation messages. Protect against enumeration by applying
   * ownership checks before returning data.
   *
   * @param connection
   * @param userId Owner user’s ID to which the consent must belong
   * @param privacyConsentId Target privacy consent record’s ID
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":privacyConsentId")
  public async at(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
    @TypedParam("privacyConsentId")
    privacyConsentId: string & tags.Format<"uuid">,
  ): Promise<ITodoAppPrivacyConsent> {
    try {
      return await gettodoAppTodoUserUsersUserIdPrivacyConsentsPrivacyConsentId(
        {
          todoUser,
          userId,
          privacyConsentId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
