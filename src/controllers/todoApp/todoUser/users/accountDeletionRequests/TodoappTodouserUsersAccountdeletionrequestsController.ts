import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { posttodoAppTodoUserUsersUserIdAccountDeletionRequests } from "../../../../../providers/posttodoAppTodoUserUsersUserIdAccountDeletionRequests";
import { TodouserAuth } from "../../../../../decorators/TodouserAuth";
import { TodouserPayload } from "../../../../../decorators/payload/TodouserPayload";
import { patchtodoAppTodoUserUsersUserIdAccountDeletionRequests } from "../../../../../providers/patchtodoAppTodoUserUsersUserIdAccountDeletionRequests";
import { gettodoAppTodoUserUsersUserIdAccountDeletionRequestsAccountDeletionRequestId } from "../../../../../providers/gettodoAppTodoUserUsersUserIdAccountDeletionRequestsAccountDeletionRequestId";

import { ITodoAppAccountDeletionRequest } from "../../../../../api/structures/ITodoAppAccountDeletionRequest";
import { IPageITodoAppAccountDeletionRequest } from "../../../../../api/structures/IPageITodoAppAccountDeletionRequest";

@Controller("/todoApp/todoUser/users/:userId/accountDeletionRequests")
export class TodoappTodouserUsersAccountdeletionrequestsController {
  /**
   * Create a user’s account deletion request
   * (todo_app_account_deletion_requests).
   *
   * Create an account deletion request for the owner identified by userId. The
   * underlying Prisma model todo_app_account_deletion_requests stores the
   * lifecycle of a deletion request with fields including status (e.g.,
   * pending_confirmation, scheduled, canceled, completed), optional reason,
   * timestamps such as confirmed_at, scheduled_purge_at, processed_at, and
   * canceled_at, as well as request_ip and request_user_agent for traceability.
   * The model links to the owning account through todo_app_user_id and uses
   * created_at and updated_at for temporal auditing.
   *
   * Security and permissions: Only the authenticated owner with role todoUser
   * is authorized to initiate a deletion request for their own account. The
   * controller/provider must enforce that the authenticated subject matches the
   * path parameter userId. Administrative staff do not use this endpoint for
   * governance workflows; they use separate admin channels documented
   * elsewhere.
   *
   * Business logic and validation: Implementers should validate that the userId
   * in the path exists and is active or otherwise eligible to request deletion
   * under policy. Status is initialized according to business rules (for
   * example, pending_confirmation). Optional reason text should be captured as
   * provided within acceptable length constraints. Request context such as
   * request_ip and request_user_agent may be captured from the HTTP request for
   * auditability. Subsequent steps in the workflow (confirmation, scheduling,
   * processing, or cancellation) are handled by other internal processes or
   * endpoints.
   *
   * Related operations: Systems may expose read endpoints to view the status of
   * a user’s deletion request history. This create endpoint is typically
   * followed by confirmation and scheduling processes that update the status
   * timeline maintained by todo_app_account_deletion_requests.
   *
   * Error handling: If the path userId does not match the authenticated
   * subject, access must be denied without revealing resource existence. If a
   * request conflicts with an already pending or scheduled deletion request
   * according to policy, return a business-level conflict response with clear
   * messaging.
   *
   * @param connection
   * @param userId Owner user’s ID who is initiating the deletion request
   * @param body Account deletion request payload, including optional reason and
   *   initial status intent if policy allows
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ITodoAppAccountDeletionRequest.ICreate,
  ): Promise<ITodoAppAccountDeletionRequest> {
    try {
      return await posttodoAppTodoUserUsersUserIdAccountDeletionRequests({
        todoUser,
        userId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Search and list a user’s account deletion requests from
   * todo_app_account_deletion_requests.
   *
   * This operation returns a filtered and paginated list of account deletion
   * requests for the specified user. The todo_app_account_deletion_requests
   * table captures the lifecycle of deletion workflows (e.g.,
   * pending_confirmation, scheduled, canceled, completed) and timestamps like
   * confirmed_at, scheduled_purge_at, and processed_at, enabling clients to
   * show current state and timelines.
   *
   * Security and permissions: only the owner (todoUser) may list their own
   * deletion requests. The provider must filter by todo_app_user_id = userId
   * and prevent cross-user access. Administrative reviews of deletion workflows
   * occur elsewhere and should avoid exposing private content via this
   * user-facing endpoint.
   *
   * Search and pagination behavior: the request supports filtering by status,
   * created_at ranges, scheduled_purge_at windows, and optional reason text
   * search per business policy. Results should exclude records that are marked
   * deleted via deleted_at in normal flows. Sorting is commonly by created_at
   * descending by default, with options to sort by scheduled_purge_at.
   * Pagination must adhere to user preferences or request parameters (e.g.,
   * page number/size within 1–100) and return a page container including
   * pagination metadata and an array of summary objects.
   *
   * Related operations: clients often navigate to GET
   * /users/{userId}/accountDeletionRequests/{accountDeletionRequestId} to view
   * details of a single request. Separate privacy features like data exports
   * are managed via their own endpoints.
   *
   * Error handling: validate pagination bounds and filter values. If no records
   * match, return an empty page. Enforce ownership checks and avoid revealing
   * the existence of other users’ requests.
   *
   * @param connection
   * @param userId Unique identifier of the owner user
   * @param body Filter, sorting, and pagination parameters for listing account
   *   deletion requests
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ITodoAppAccountDeletionRequest.IRequest,
  ): Promise<IPageITodoAppAccountDeletionRequest.ISummary> {
    try {
      return await patchtodoAppTodoUserUsersUserIdAccountDeletionRequests({
        todoUser,
        userId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get a user’s account deletion request by ID from
   * todo_app_account_deletion_requests.
   *
   * This endpoint provides full details of a single account deletion request
   * for the specified user. The underlying table
   * todo_app_account_deletion_requests records each request’s status (e.g.,
   * pending_confirmation, scheduled, canceled, completed) and time markers that
   * guide UI messaging and scheduling (confirmed_at and scheduled_purge_at).
   * Clients use this to display current state, rationale (reason when present),
   * and next steps.
   *
   * Security and permissions: access is restricted to the resource owner
   * (todoUser). The provider must ensure that todo_app_user_id equals the path
   * userId and that records marked deleted (via deleted_at) are excluded from
   * normal responses. Administrative governance endpoints are separate and not
   * part of this user-facing operation.
   *
   * Entity relationships: each record references todo_app_users via
   * todo_app_user_id. No other entities need to be expanded here. The response
   * returns the complete deletion request resource so clients can render
   * details and status-dependent actions (e.g., cancel within a policy window
   * if supported by business logic implemented elsewhere).
   *
   * Error handling: if the record is not found for the given userId and
   * accountDeletionRequestId, respond with a not-found outcome without
   * indicating whether a record exists for other users. Validate both
   * identifiers as UUIDs. No request body is required.
   *
   * @param connection
   * @param userId Unique identifier of the owner user
   * @param accountDeletionRequestId Unique identifier of the account deletion
   *   request
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":accountDeletionRequestId")
  public async at(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
    @TypedParam("accountDeletionRequestId")
    accountDeletionRequestId: string & tags.Format<"uuid">,
  ): Promise<ITodoAppAccountDeletionRequest> {
    try {
      return await gettodoAppTodoUserUsersUserIdAccountDeletionRequestsAccountDeletionRequestId(
        {
          todoUser,
          userId,
          accountDeletionRequestId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
