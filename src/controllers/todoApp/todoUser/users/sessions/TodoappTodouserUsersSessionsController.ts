import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { patchtodoAppTodoUserUsersUserIdSessions } from "../../../../../providers/patchtodoAppTodoUserUsersUserIdSessions";
import { TodouserAuth } from "../../../../../decorators/TodouserAuth";
import { TodouserPayload } from "../../../../../decorators/payload/TodouserPayload";
import { gettodoAppTodoUserUsersUserIdSessionsSessionId } from "../../../../../providers/gettodoAppTodoUserUsersUserIdSessionsSessionId";

import { IPageITodoAppSession } from "../../../../../api/structures/IPageITodoAppSession";
import { ITodoAppSession } from "../../../../../api/structures/ITodoAppSession";

@Controller("/todoApp/todoUser/users/:userId/sessions")
export class TodoappTodouserUsersSessionsController {
  /**
   * Search a user’s sessions from Prisma table todo_app_sessions with filtering
   * and pagination.
   *
   * Retrieve a filtered, sorted, and paginated list of sessions for the
   * specified user from the todo_app_sessions table. Each record represents a
   * sign-in session and includes attributes such as id (UUID primary key),
   * todo_app_user_id (owner reference), ip (last seen or creation IP),
   * user_agent, issued_at, expires_at, revoked_at, revoked_reason, created_at,
   * and updated_at. The table also has a session_token column that is unique
   * and security-sensitive; client responses must not include raw tokens.
   *
   * This operation is intended for authenticated users reviewing their own
   * active and historical sessions to monitor account security and manage
   * sign-ins across devices. Authorization must ensure that the path userId
   * matches the caller’s identity. Use todo_app_sessions.todo_app_user_id to
   * enforce ownership checks so that users can never list sessions belonging to
   * others.
   *
   * The request body (ITodoAppSession.IRequest) should support common filters
   * derived from the schema columns, such as status filters (e.g., active where
   * revoked_at is null and expires_at is in the future; expired where
   * expires_at is in the past; revoked where revoked_at is not null), time
   * range filters over issued_at/expires_at, client metadata filters (ip,
   * user_agent substrings), and pagination/sorting parameters (default sort by
   * issued_at descending). Results should exclude rows considered logically
   * removed by business policy when deleted_at is not null.
   *
   * If the user does not exist or the caller lacks permission to access the
   * specified userId, the provider should deny access without revealing whether
   * the resource exists. If filters are invalid (e.g., malformed date ranges),
   * the provider should return validation errors that identify the rule in
   * business terms. Related operations include: GET
   * /users/{userId}/sessions/{sessionId} for a specific session detail, GET
   * /sessions/{sessionId}/revocation for any associated revocation record, and
   * PATCH /sessions/{sessionId}/refreshTokens to review the refresh-token chain
   * for a session.
   *
   * @param connection
   * @param userId Owner user’s ID whose sessions are being queried
   * @param body Search, filter, sort, and paginate parameters for user sessions
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ITodoAppSession.IRequest,
  ): Promise<IPageITodoAppSession.ISummary> {
    try {
      return await patchtodoAppTodoUserUsersUserIdSessions({
        todoUser,
        userId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get a specific session (todo_app_sessions) for the given user.
   *
   * Fetch a single session record from todo_app_sessions identified by
   * sessionId and scoped by userId. The schema defines fields including id
   * (UUID), todo_app_user_id (FK to todo_app_users.id), session_token (unique
   * secret, never returned to clients), ip, user_agent, issued_at, expires_at,
   * revoked_at, revoked_reason, created_at, updated_at, and deleted_at.
   * Implementations must avoid exposing raw session_token, and may provide safe
   * metadata only.
   *
   * Security and authorization: the caller must be authenticated as the owner
   * indicated by userId, and the provider must verify that the session’s
   * todo_app_user_id equals the path userId. If the session does not belong to
   * the user or is not found, the provider should deny access without
   * indicating whether the resource exists. This behavior aligns with the
   * account security practices described in the requirements.
   *
   * Expected behavior and errors: return the single session entity when found.
   * If the record is flagged as logically removed by business policy (non-null
   * deleted_at), omit it from normal responses. If the session is expired
   * (expires_at < now) or revoked (revoked_at not null), those states should be
   * reflected in the response fields but do not by themselves prevent
   * retrieval. Validation errors should be returned for malformed UUIDs.
   * Related endpoints: PATCH /users/{userId}/sessions (list/search), GET
   * /sessions/{sessionId}/revocation (view revocation details for the session),
   * PATCH /sessions/{sessionId}/refreshTokens (inspect refresh-token chain).
   *
   * @param connection
   * @param userId Owner user’s ID
   * @param sessionId Target session’s ID
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":sessionId")
  public async at(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("userId")
    userId: string & tags.Format<"uuid">,
    @TypedParam("sessionId")
    sessionId: string & tags.Format<"uuid">,
  ): Promise<ITodoAppSession> {
    try {
      return await gettodoAppTodoUserUsersUserIdSessionsSessionId({
        todoUser,
        userId,
        sessionId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
