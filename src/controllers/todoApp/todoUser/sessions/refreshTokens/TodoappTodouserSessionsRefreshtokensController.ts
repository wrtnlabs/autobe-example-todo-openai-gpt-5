import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { patchtodoAppTodoUserSessionsSessionIdRefreshTokens } from "../../../../../providers/patchtodoAppTodoUserSessionsSessionIdRefreshTokens";
import { TodouserAuth } from "../../../../../decorators/TodouserAuth";
import { TodouserPayload } from "../../../../../decorators/payload/TodouserPayload";
import { gettodoAppTodoUserSessionsSessionIdRefreshTokensRefreshTokenId } from "../../../../../providers/gettodoAppTodoUserSessionsSessionIdRefreshTokensRefreshTokenId";

import { IPageITodoAppRefreshToken } from "../../../../../api/structures/IPageITodoAppRefreshToken";
import { ITodoAppRefreshToken } from "../../../../../api/structures/ITodoAppRefreshToken";

@Controller("/todoApp/todoUser/sessions/:sessionId/refreshTokens")
export class TodoappTodouserSessionsRefreshtokensController {
  /**
   * Search refresh tokens (todo_app_refresh_tokens) for a session with
   * pagination.
   *
   * Retrieve refresh tokens for the specified session from
   * todo_app_refresh_tokens. The schema includes id (UUID PK),
   * todo_app_session_id (FK to todo_app_sessions.id), parent_id
   * (self-referential chain), token (opaque; deprecated for security),
   * token_hash (unique lookup hash), issued_at, expires_at, rotated_at,
   * revoked_at, revoked_reason, created_at, updated_at, and deleted_at. Client
   * responses must not expose token or token_hash values; instead, return safe
   * metadata such as timestamps and rotation/revocation status.
   *
   * Security and authorization: although the path does not include userId, the
   * provider must enforce ownership by verifying that the session referenced by
   * the path parameter belongs to the authenticated user (via
   * todo_app_sessions.todo_app_user_id). This prevents cross-user inspection of
   * token chains.
   *
   * The request body (ITodoAppRefreshToken.IRequest) should support filters on
   * temporal fields (issued_at/expires_at), rotation/revocation status
   * (rotated_at, revoked_at), and chain navigation via parent_id when focusing
   * on a branch. Sorting should typically default to issued_at descending.
   * Results should exclude logically removed rows when deleted_at is not null
   * per business policy. Related endpoints: GET
   * /users/{userId}/sessions/{sessionId} (session detail), GET
   * /sessions/{sessionId}/revocation (revocation info), and PATCH
   * /users/{userId}/sessions (search sessions).
   *
   * @param connection
   * @param sessionId Session whose refresh tokens are being queried
   * @param body Search, filter, sort, and paginate parameters for refresh
   *   tokens
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("sessionId")
    sessionId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ITodoAppRefreshToken.IRequest,
  ): Promise<IPageITodoAppRefreshToken.ISummary> {
    try {
      return await patchtodoAppTodoUserSessionsSessionIdRefreshTokens({
        todoUser,
        sessionId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get a refresh token from todo_app_refresh_tokens by session and token
   * identifiers.
   *
   * Fetch a specific refresh token associated with an authentication session.
   * In the Prisma schema, todo_app_refresh_tokens stores long-lived
   * authentication artifacts with rotation history and revocation metadata.
   * Columns include id, todo_app_session_id (FK to todo_app_sessions.id),
   * optional parent_id for rotation chains, token and token_hash, issued_at,
   * expires_at, rotated_at, revoked_at, revoked_reason, created_at, updated_at,
   * and a deleted_at marker column used to exclude records from normal flows
   * when set.
   *
   * Security and permissions: Only the authenticated owner of the session (the
   * same user who owns todo_app_sessions.todo_app_user_id) should be able to
   * read this record. Administrators should not need routine access to refresh
   * token contents. Providers must never expose raw secrets in logs, and
   * downstream DTOs must omit or redact sensitive columns (token, token_hash)
   * per policy.
   *
   * Entity relationships and constraints: The record references a parent
   * session via todo_app_session_id with onDelete: Cascade in the schema.
   * Implementations must confirm that the refreshTokenId exists and belongs to
   * the specified sessionId; otherwise, respond as not found. If revoked_at is
   * present, the token has been revoked; if rotated_at is present, the token
   * has been superseded by a child token in the rotation chain. The deleted_at
   * marker indicates records that are no longer active and should typically be
   * excluded from standard retrievals.
   *
   * Validation and behavior: This operation returns a single resource. It does
   * not paginate or filter. Typical errors include invalid UUID formats,
   * nonexistent identifiers, or a mismatch between sessionId and
   * refreshTokenId. Related operations include session detail retrieval and
   * listing a sessionâ€™s refresh tokens if provided elsewhere.
   *
   * @param connection
   * @param sessionId Identifier of the parent session (todo_app_sessions.id)
   * @param refreshTokenId Identifier of the refresh token
   *   (todo_app_refresh_tokens.id)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":refreshTokenId")
  public async at(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("sessionId")
    sessionId: string & tags.Format<"uuid">,
    @TypedParam("refreshTokenId")
    refreshTokenId: string & tags.Format<"uuid">,
  ): Promise<ITodoAppRefreshToken> {
    try {
      return await gettodoAppTodoUserSessionsSessionIdRefreshTokensRefreshTokenId(
        {
          todoUser,
          sessionId,
          refreshTokenId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
