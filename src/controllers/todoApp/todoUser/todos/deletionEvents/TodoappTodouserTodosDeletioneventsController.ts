import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { patchtodoAppTodoUserTodosTodoIdDeletionEvents } from "../../../../../providers/patchtodoAppTodoUserTodosTodoIdDeletionEvents";
import { TodouserAuth } from "../../../../../decorators/TodouserAuth";
import { TodouserPayload } from "../../../../../decorators/payload/TodouserPayload";
import { gettodoAppTodoUserTodosTodoIdDeletionEventsDeletionEventId } from "../../../../../providers/gettodoAppTodoUserTodosTodoIdDeletionEventsDeletionEventId";

import { IPageITodoAppTodoDeletionEvent } from "../../../../../api/structures/IPageITodoAppTodoDeletionEvent";
import { ITodoAppTodoDeletionEvent } from "../../../../../api/structures/ITodoAppTodoDeletionEvent";

@Controller("/todoApp/todoUser/todos/:todoId/deletionEvents")
export class TodoappTodouserTodosDeletioneventsController {
  /**
   * List deletion audit entries for a Todo from todo_app_todo_deletion_events.
   *
   * Purpose and overview: Lists deletion audit records tied to a Todo using the
   * todo_app_todo_deletion_events model. Each record includes a link to the
   * deleted Todo (nullable for preservation), the deleting user (nullable), a
   * human-readable reason, and occurred_at timestamps. This endpoint provides
   * transparency for deletion workflows and complements the soft deletion
   * behavior supported by todo_app_todos.deleted_at.
   *
   * Security and authorization: Only the owner (role todoUser) may list
   * deletion events for their Todo. Providers must validate that the Todo
   * identified by todoId belongs to the authenticated user. Unauthorized access
   * attempts must be denied without revealing whether the resource exists.
   *
   * DB relationships and behavior: Deletion events relate to todo_app_todos and
   * todo_app_users with onDelete behaviors chosen to preserve history (nullable
   * FKs). Providers should constrain results to events for the specified Todo,
   * apply pagination and sorting, and optionally expose keyword filtering on
   * reason leveraging the available trigram index.
   *
   * Validation and errors: Reject requests with invalid UUIDs or when the
   * specified Todo is not found/owned by the caller. This endpoint is read-only
   * and does not create, change, or remove deletion events. Related operations
   * include DELETE /todoApp/todoUser/todos/{todoId} to perform the deletion and
   * PATCH /todoApp/todoUser/todos/{todoId}/activities to review broader
   * activity history.
   *
   * @param connection
   * @param todoId Identifier of the parent todo
   * @param body Search, filter, sort, and pagination parameters for deletion
   *   events
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("todoId")
    todoId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ITodoAppTodoDeletionEvent.IRequest,
  ): Promise<IPageITodoAppTodoDeletionEvent.ISummary> {
    try {
      return await patchtodoAppTodoUserTodosTodoIdDeletionEvents({
        todoUser,
        todoId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get a specific Todo deletion audit entry (todo_app_todo_deletion_events) by
   * identifiers.
   *
   * This endpoint returns a single deletion audit entry for a Todo. The
   * underlying storage is the Prisma model todo_app_todo_deletion_events, which
   * records point‑in‑time deletion audit entries for todos, including who
   * deleted the todo and when, with an optional human‑readable reason. The
   * model includes columns like id (primary key), todo_app_todo_id (nullable FK
   * to todo_app_todos), todo_app_user_id (nullable FK to todo_app_users as the
   * deleter), reason (optional text), occurred_at (business event time), and
   * created_at/updated_at timestamps. It preserves audit history by allowing
   * the foreign keys to be nullable so that records remain valid even if parent
   * entities are purged. A logical deletion timestamp exists for rare
   * administrative redactions under policy, and such records must be excluded
   * from normal retrievals.
   *
   * Security and permissions must ensure that only the owner of the parent todo
   * can access the associated deletion event. Provider logic should verify that
   * the authenticated identity corresponds to todo_app_todos.todo_app_user_id
   * for the given todoId, and that the deletion event’s todo_app_todo_id
   * matches the provided todoId. If either check fails, the provider should
   * behave as if the resource is not available to avoid leaking information
   * about other users’ data.
   *
   * The operation is read‑only; it does not create or alter any audit records.
   * It is related to other read operations such as retrieving a Todo detail or
   * listing all deletion events under a Todo (if provided elsewhere). Expected
   * behaviors include returning a single audit record when both identifiers
   * match and the user is authorized, or an appropriate not‑found/authorization
   * failure outcome when identifiers do not correspond or access is denied.
   * Records with a logical deletion timestamp should be filtered out from
   * standard responses.
   *
   * @param connection
   * @param todoId Identifier of the parent Todo to which the deletion event
   *   belongs
   * @param deletionEventId Identifier of the target deletion event entry
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":deletionEventId")
  public async at(
    @TodouserAuth()
    todoUser: TodouserPayload,
    @TypedParam("todoId")
    todoId: string & tags.Format<"uuid">,
    @TypedParam("deletionEventId")
    deletionEventId: string & tags.Format<"uuid">,
  ): Promise<ITodoAppTodoDeletionEvent> {
    try {
      return await gettodoAppTodoUserTodosTodoIdDeletionEventsDeletionEventId({
        todoUser,
        todoId,
        deletionEventId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
