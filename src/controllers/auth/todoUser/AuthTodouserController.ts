import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postauthTodoUserJoin } from "../../../providers/postauthTodoUserJoin";
import { postauthTodoUserLogin } from "../../../providers/postauthTodoUserLogin";
import { postauthTodoUserRefresh } from "../../../providers/postauthTodoUserRefresh";
import { postauthTodoUserLogout } from "../../../providers/postauthTodoUserLogout";
import { TodouserAuth } from "../../../decorators/TodouserAuth";
import { TodouserPayload } from "../../../decorators/payload/TodouserPayload";

import { ITodoAppTodoUser } from "../../../api/structures/ITodoAppTodoUser";
import { ITodoAppTodoUserLogin } from "../../../api/structures/ITodoAppTodoUserLogin";
import { ITodoAppTodoUserRefresh } from "../../../api/structures/ITodoAppTodoUserRefresh";

@Controller("/auth/todoUser")
export class AuthTodouserController {
  /**
   * Register a new member in todo_app_users and assign todo_app_todousers;
   * create session/refresh in Auth tables.
   *
   * Purpose and functionality: Registers a new member user and issues
   * authentication tokens based on the Actors and Auth schema. Uses
   * todo_app_users.email as the unique login identifier, stores credentials in
   * todo_app_users.password_hash, initializes account lifecycle via
   * todo_app_users.status and todo_app_users.email_verified, and stamps
   * timestamps like todo_app_users.created_at and updated_at according to
   * policy. A role assignment entry is inserted into todo_app_todousers with
   * granted_at set and revoked_at null, marking the account as a current
   * todoUser.
   *
   * Implementation details: After persisting the user (todo_app_users), this
   * operation creates a session in todo_app_sessions with session_token,
   * issued_at, expires_at, ip, and user_agent as available, and then inserts a
   * first refresh token in todo_app_refresh_tokens with token_hash, issued_at,
   * expires_at, and parent_id null. A success record in todo_app_login_attempts
   * is appended with success=true and failure_reason null. The response
   * encapsulates the authorized context (access/refresh semantics derived from
   * session/refresh records) in an application DTO; no plaintext secrets are
   * persisted beyond token/refresh hashes as per schema comments.
   *
   * Role-specific integration: This is for the "todoUser" role and therefore
   * populates todo_app_todousers for the created user. It does not create
   * admin/system role records (todo_app_systemadmins) and does not assign guest
   * history (todo_app_guestvisitors) unless governance workflows do so
   * separately.
   *
   * Security considerations: Passwords are never stored in plaintext; only
   * todo_app_users.password_hash is persisted. Session validity and rotation
   * lifetimes are controlled by todo_app_sessions.expires_at and
   * todo_app_refresh_tokens.expires_at. Account admission can honor policies
   * via todo_app_users.status (e.g., "pending_verification" vs. "active") and
   * email verification state via todo_app_users.email_verified and verified_at.
   * All tokens should be conveyed to the client via the response object and
   * audited via todo_app_audit_logs if required by policy.
   *
   * Related operations: Clients typically proceed to protected APIs using the
   * returned credentials. For email verification, see the email verification
   * consumption endpoint that manipulates todo_app_email_verifications. For
   * token renewal, use the refresh endpoint that appends a new child in
   * todo_app_refresh_tokens and updates rotation fields. Errors include
   * duplicate email (todo_app_users.email uniqueness), invalid password policy,
   * or policy blocks implied by todo_app_users.status values.
   *
   * @param connection
   * @param body Registration payload for creating a todoUser account and
   *   initial session.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ITodoAppTodoUser.ICreate,
  ): Promise<ITodoAppTodoUser.IAuthorized> {
    try {
      return await postauthTodoUserJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Login for todoUser using todo_app_users; creates todo_app_sessions and
   * todo_app_refresh_tokens and logs attempts.
   *
   * Purpose and functionality: Authenticates a user identified by
   * todo_app_users.email using a submitted credential compared against
   * todo_app_users.password_hash. On success, sets todo_app_users.last_login_at
   * and returns an authorized DTO while preserving role membership via
   * todo_app_todousers (granted_at not revoked_at).
   *
   * Implementation details: Creates a todo_app_sessions row with session_token,
   * issued_at, expires_at, and optional ip/user_agent, then inserts a
   * todo_app_refresh_tokens row with token_hash, issued_at, and expires_at.
   * Appends a todo_app_login_attempts record with success=true on successful
   * login or success=false with failure_reason (e.g., "invalid_credentials" or
   * account state) for failures. Enforces lifecycle gates using
   * todo_app_users.status (e.g., block when "suspended") and email gating using
   * todo_app_users.email_verified and verified_at according to policy.
   *
   * Role-specific integration: Confirms that the authenticating account
   * currently holds the member role by checking an active row in
   * todo_app_todousers (revoked_at IS NULL). This endpoint is specific to
   * todoUser and does not authenticate systemAdmin.
   *
   * Security considerations: Never expose whether the email exists; failures
   * should be logged in todo_app_login_attempts with generic failure_reason.
   * Sessions must honor todo_app_sessions.expires_at and revocation flows using
   * revoked_at and optional todo_app_session_revocations. Refresh tokens must
   * be stored as token_hash within todo_app_refresh_tokens and rotated on
   * subsequent refresh.
   *
   * Related operations: Use the refresh endpoint for renewing tokens bound to
   * an existing session (todo_app_sessions and todo_app_refresh_tokens). For
   * password resets, see password reset request and confirmation endpoints
   * using todo_app_password_resets.
   *
   * @param connection
   * @param body Login payload with email and password for todoUser
   *   authentication.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ITodoAppTodoUserLogin.IRequest,
  ): Promise<ITodoAppTodoUser.IAuthorized> {
    try {
      return await postauthTodoUserLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh tokens for todoUser using todo_app_refresh_tokens rotation and
   * todo_app_sessions validity.
   *
   * Purpose and functionality: Accepts a refresh token and renews access
   * credentials for a member account. Validates the token via
   * todo_app_refresh_tokens.token_hash, respects expires_at, and checks
   * rotated_at/revoked_at to enforce single-use rotation. Ensures the parent
   * session in todo_app_sessions is valid (not expired per expires_at and not
   * revoked via revoked_at).
   *
   * Implementation details: Creates a new child row in todo_app_refresh_tokens
   * with parent_id referencing the previous token, sets issued_at/expires_at,
   * and marks the previous token’s rotated_at. Session metadata (e.g.,
   * updated_at or ip/user_agent) may be updated according to policy. The
   * response carries renewed authorization context in the standardized DTO.
   *
   * Role-specific integration: Confirms that the owning user still has an
   * active todoUser role via an unrevoked row in todo_app_todousers and that
   * the user’s account lifecycle in todo_app_users.status allows continued
   * authentication.
   *
   * Security considerations: Tokens are stored as token_hash only; plaintext
   * values are never persisted. Rotation is strict: an already-rotated token
   * (rotated_at not null) is rejected. Revocation actions are respected using
   * todo_app_refresh_tokens.revoked_at/revoked_reason and
   * todo_app_sessions.revoked_at/revoked_reason.
   *
   * Related operations: If the user needs to end the session, use the logout
   * endpoint that records a revocation via todo_app_session_revocations. For
   * credential changes, see change password, which should revoke others'
   * sessions per policy.
   *
   * @param connection
   * @param body Refresh payload carrying the refresh token to rotate and renew
   *   access.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ITodoAppTodoUserRefresh.IRequest,
  ): Promise<ITodoAppTodoUser.IAuthorized> {
    try {
      return await postauthTodoUserRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Logout current session by updating todo_app_sessions and inserting into
   * todo_app_session_revocations; optionally revoke current refresh token.
   *
   * Purpose and functionality: Ends the authenticated session for a todoUser by
   * marking the session as revoked in todo_app_sessions and recording a
   * revocation entry in todo_app_session_revocations. May also mark the
   * currently held refresh token as revoked in todo_app_refresh_tokens.
   *
   * Implementation details: Identifies the current session via the
   * authenticated context, sets revoked_at and revoked_reason, and creates the
   * associated todo_app_session_revocations row with revoked_by (e.g., "user")
   * and optional reason. No user record changes are required.
   *
   * Role-specific integration: Requires an authenticated todoUser. The
   * operation affects only the caller’s current session.
   *
   * Security considerations: Ensure idempotency—repeated calls should succeed
   * without error if the session is already revoked. Avoid exposing other
   * session details. Consider appending an audit log entry in
   * todo_app_audit_logs with action="logout".
   *
   * Related operations: To revoke all other devices, use the revokeOthers
   * endpoint. To renew access later, use login or refresh.
   *
   * @param connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("logout")
  public async logout(
    @TodouserAuth()
    todoUser: TodouserPayload,
  ): Promise<void> {
    try {
      return await postauthTodoUserLogout({
        todoUser,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
