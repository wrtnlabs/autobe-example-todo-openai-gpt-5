import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthGuestJoin } from "../../../providers/postAuthGuestJoin";
import { postAuthGuestRefresh } from "../../../providers/postAuthGuestRefresh";

import { ITodoMvpGuest } from "../../../api/structures/ITodoMvpGuest";
import { ITodoMvpGuestRefresh } from "../../../api/structures/ITodoMvpGuestRefresh";

@Controller("/auth/guest")
export class AuthGuestController {
  /**
   * Register a guest identity in todo_mvp_guests and create a session in
   * todo_mvp_sessions, issuing initial JWTs.
   *
   * This endpoint registers an anonymous guest identity and issues initial JWT
   * credentials suitable for temporary, unauthenticated usage scenarios. It
   * persists a minimal identity row in the Actors.todo_mvp_guests table,
   * leveraging its id (UUID primary key), created_at, and updated_at columns to
   * provide durable but privacy-respecting identification for session
   * management. The design intentionally stores no credential fields for
   * guests, aligning with the table’s minimal footprint described in the Prisma
   * schema comments.
   *
   * Upon creation of the guest identity, the service also creates a session
   * record in Auth.todo_mvp_sessions. That session row uses session_token_hash
   * to store a hashed representation of the issued token, and maintains
   * lifecycle fields created_at, updated_at, last_accessed_at, and expires_at.
   * For guest sessions, both todo_mvp_user_id and todo_mvp_admin_id remain null
   * by design, as guests are not authenticated users or admins. The expires_at
   * field governs absolute token lifetime, while last_accessed_at supports
   * inactivity policies as described in the schema commentary.
   *
   * From a role perspective, guests have no credentials and do not perform
   * password-based login. Therefore, this join operation is the only way to
   * establish a guest session. The returned ITodoMvpGuest.IAuthorized payload
   * encapsulates the tokens and identifies the session created in
   * todo_mvp_sessions so that subsequent requests can be validated without
   * exposing any personal data.
   *
   * Security considerations include hashing any bearer token into
   * todo_mvp_sessions.session_token_hash, avoiding storage of plaintext tokens.
   * The implementation must honor expires_at and update last_accessed_at on
   * use. Because guests are intentionally minimal, the join flow avoids
   * collecting unnecessary attributes, honoring privacy requirements emphasized
   * in the todo_mvp_guests schema documentation.
   *
   * Related operations: use POST /auth/guest/refresh to renew credentials
   * before expires_at. There is no password-based login for guests by design,
   * and guests cannot access protected Todo data per business rules; they may
   * only operate within public or guest-scoped capabilities until they become
   * authenticated users via a separate user registration flow outside the guest
   * scope.
   *
   * @param connection
   * @param body Optional client hints for creating a guest identity; typically
   *   empty for MVP.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ITodoMvpGuest.ICreate,
  ): Promise<ITodoMvpGuest.IAuthorized> {
    try {
      return await postAuthGuestJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh guest JWTs by rotating the session in todo_mvp_sessions using
   * session_token_hash and lifecycle fields.
   *
   * This endpoint renews guest credentials by validating and rotating the
   * corresponding session stored in Auth.todo_mvp_sessions. The Prisma schema
   * describes session_token_hash as a hashed representation uniquely
   * identifying a session; the service hashes the provided refresh token and
   * matches it against this column. The session’s lifecycle fields—created_at,
   * updated_at, last_accessed_at, and expires_at—are used to enforce absolute
   * TTL and idle activity policies during refresh.
   *
   * When the refresh succeeds, the service updates updated_at and
   * last_accessed_at, rotates the underlying token by updating
   * session_token_hash, and extends expires_at to a new absolute expiration.
   * The revoked_at field, when null, indicates the session has not been
   * explicitly invalidated; if set, refresh must be denied. For guest sessions,
   * todo_mvp_user_id and todo_mvp_admin_id remain null by design, reflecting
   * that the actor is an anonymous guest rather than an authenticated user or
   * admin.
   *
   * This operation is specific to the guest role and complements the guest join
   * flow. Guests do not perform password-based login and therefore rely on join
   * followed by periodic refresh. The response type ITodoMvpGuest.IAuthorized
   * packages the newly issued credentials so clients can continue interacting
   * under the same guest identity established earlier.
   *
   * Security considerations: tokens are never stored in plaintext; only their
   * hashes are persisted in session_token_hash. The implementation must verify
   * expires_at and any business-specific idle constraints based on
   * last_accessed_at. On successful refresh, the previous token becomes
   * invalid, preventing token replay.
   *
   * Related operations: prior to using this endpoint, a client must have
   * executed POST /auth/guest/join to obtain an initial session. Refresh can be
   * repeated until session constraints in todo_mvp_sessions prevent further
   * renewal (e.g., hard expiration via expires_at or explicit invalidation via
   * revoked_at).
   *
   * @param connection
   * @param body Refresh token payload required to locate and rotate the guest
   *   session.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ITodoMvpGuestRefresh.IRequest,
  ): Promise<ITodoMvpGuest.IAuthorized> {
    try {
      return await postAuthGuestRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
