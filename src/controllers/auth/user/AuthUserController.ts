import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthUserJoin } from "../../../providers/postAuthUserJoin";
import { postAuthUserLogin } from "../../../providers/postAuthUserLogin";
import { postAuthUserRefresh } from "../../../providers/postAuthUserRefresh";

import { ITodoMvpUser } from "../../../api/structures/ITodoMvpUser";
import { ITodoMvpUserLogin } from "../../../api/structures/ITodoMvpUserLogin";
import { ITodoMvpUserRefresh } from "../../../api/structures/ITodoMvpUserRefresh";

@Controller("/auth/user")
export class AuthUserController {
  /**
   * Register a new member in Actors.todo_mvp_users and create session in
   * Auth.todo_mvp_sessions.
   *
   * This endpoint registers a new member account using the
   * Actors.todo_mvp_users table. It requires an email and a password that will
   * be transformed into a strong credential and persisted as password_hash. The
   * account’s lifecycle state is tracked by the status column, where suggested
   * values include "active" or "deactivated" per schema comments; registration
   * initializes an account suitable for immediate use in the MVP when business
   * validation passes. Timestamps created_at and updated_at are recorded to
   * support temporal ordering and auditability.
   *
   * On success, the provider also creates an authentication session in
   * Auth.todo_mvp_sessions. The session stores a hashed form of the issued
   * bearer in session_token_hash and manages time-based controls via
   * last_accessed_at and expires_at. The relationship back to the user appears
   * through todo_mvp_user_id, ensuring that subsequent authorization checks can
   * associate actions with the correct user.
   *
   * Security-sensitive data handling follows schema guidance: email must be
   * unique across members (enforced by @@unique on todo_mvp_users.email), and
   * password hashes are stored only in password_hash (no plaintext). The
   * endpoint must not expose password_hash in responses. Optional fields like
   * deleted_at exist in the schema but are not used during registration in MVP
   * flows.
   *
   * This operation is designed for the "user" role (a member) described in
   * requirements. Even though the endpoint is public, the resulting session is
   * tied to the member through Auth.todo_mvp_sessions so that owner-only Todo
   * actions can be enforced elsewhere.
   *
   * Related operations include login for existing accounts and refresh for
   * token renewal using Auth.todo_mvp_sessions data. Applications typically
   * call this registration endpoint once per email address, then rely on login
   * and refresh for ongoing access management.
   *
   * @param connection
   * @param body Registration payload for creating a user account (email,
   *   password).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ITodoMvpUser.ICreate,
  ): Promise<ITodoMvpUser.IAuthorized> {
    try {
      return await postAuthUserJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate a member via Actors.todo_mvp_users and create
   * Auth.todo_mvp_sessions entry.
   *
   * This operation signs in a member by looking up Actors.todo_mvp_users via
   * the unique email and validating the supplied password against the stored
   * password_hash. Only accounts in an acceptable lifecycle state (e.g., status
   * = "active") are allowed to sign in, aligning with the schema’s status
   * column semantics. Timestamps created_at and updated_at on the user reflect
   * account lifecycle; the endpoint must not expose password_hash in any
   * response.
   *
   * When authentication succeeds, a session record is created in
   * Auth.todo_mvp_sessions. The session persists a hashed token in
   * session_token_hash and manages session lifecycle through last_accessed_at
   * and expires_at. Associations back to the authenticating user are tracked
   * via todo_mvp_user_id. Subsequent requests can use the issued tokens for
   * authorization checks.
   *
   * Security considerations include the unique constraint on email (@@unique on
   * todo_mvp_users.email) and the principle that plain credentials are never
   * stored. The system should update last_accessed_at as tokens are used, but
   * this endpoint’s core responsibility is initial issuance and session
   * creation.
   *
   * This endpoint applies to the "user" role (member). While the endpoint
   * itself is public, successful authentication yields tokens that enable
   * owner-only access to Todo resources under the MVP’s authorization rules.
   *
   * Use this in conjunction with the refresh operation that rotates or renews
   * tokens based on existing Auth.todo_mvp_sessions entries. Registration
   * (join) precedes login for first-time users.
   *
   * @param connection
   * @param body Login payload identifying the user (email) and password.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ITodoMvpUserLogin.IRequest,
  ): Promise<ITodoMvpUser.IAuthorized> {
    try {
      return await postAuthUserLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh a member’s session using Auth.todo_mvp_sessions and return renewed
   * authorization.
   *
   * This operation renews access for a member by validating an existing session
   * represented in Auth.todo_mvp_sessions. The session table contains
   * session_token_hash (hashed bearer for lookup), lifecycle timestamps
   * including last_accessed_at to support inactivity checks, and expires_at for
   * absolute TTL boundaries. If the session has been ended, a revoked_at
   * timestamp prevents renewal. The operation should also ensure the associated
   * user in Actors.todo_mvp_users remains suitable for access (e.g., status
   * still acceptable).
   *
   * On a successful refresh, implementations typically rotate the token
   * material and update last_accessed_at and expires_at, persisting the new
   * hashed representation back to session_token_hash. This maintains security
   * hygiene while extending the session lifespan. No plaintext tokens are
   * stored per schema intent.
   *
   * The user account is never exposed with sensitive fields like password_hash.
   * Standard user timestamps (created_at, updated_at) and the status column
   * inform authorization decisions but are not directly modified by this
   * endpoint.
   *
   * This endpoint is designed for the "user" role context, yet it does not
   * require role-restricted access because validation is performed using the
   * presented refresh token. Business rules in requirements emphasize
   * predictable session behavior and idle-timeout handling, which are supported
   * by last_accessed_at and expires_at columns.
   *
   * Typical flows pair this endpoint with login (initial session creation) and
   * are used periodically to maintain an authenticated state. If rotation fails
   * or the session is invalid or expired, the client should be guided to
   * re-authenticate via login.
   *
   * @param connection
   * @param body Refresh token payload used to renew the existing session.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ITodoMvpUserRefresh.IRequest,
  ): Promise<ITodoMvpUser.IAuthorized> {
    try {
      return await postAuthUserRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
