import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postauthSystemAdminJoin } from "../../../providers/postauthSystemAdminJoin";
import { postauthSystemAdminLogin } from "../../../providers/postauthSystemAdminLogin";
import { postauthSystemAdminRefresh } from "../../../providers/postauthSystemAdminRefresh";

import { ITodoAppSystemAdmin } from "../../../api/structures/ITodoAppSystemAdmin";
import { ITodoAppSystemAdminJoin } from "../../../api/structures/ITodoAppSystemAdminJoin";
import { ITodoAppSystemAdminLogin } from "../../../api/structures/ITodoAppSystemAdminLogin";
import { ITodoAppSystemAdminRefresh } from "../../../api/structures/ITodoAppSystemAdminRefresh";

@Controller("/auth/systemAdmin")
export class AuthSystemadminController {
  /**
   * Register a systemAdmin using todo_app_users and grant role in
   * todo_app_systemadmins.
   *
   * This endpoint registers a new system administrator by inserting a user row
   * into todo_app_users and establishing an initial role grant in
   * todo_app_systemadmins. The todo_app_users table stores email for login,
   * password_hash for credential verification, status to control lifecycle
   * (e.g., active or pending_verification), and email_verified/verified_at for
   * verification policy. The admin role history is captured in
   * todo_app_systemadmins with granted_at and optional revoked_at to preserve
   * governance history.
   *
   * On successful registration, the service can initialize authentication
   * artifacts: a session in todo_app_sessions with issued_at, expires_at,
   * optionally ip and user_agent, and a refresh token in
   * todo_app_refresh_tokens with issued_at/expires_at and token_hash for secure
   * lookup. These artifacts are returned through the authorized response
   * contract.
   *
   * The operation integrates with policy and configuration surfaces via
   * read-only logic as needed, but the primary persistence is restricted to
   * todo_app_users and todo_app_systemadmins. It does not touch private todo
   * content tables, preserving separation of concerns.
   *
   * Security considerations match the schema: no plaintext password storage
   * (password_hash only), and the email field must be unique. Account status in
   * todo_app_users determines whether the new admin can immediately log in;
   * email_verified and verified_at reflect verification requirements.
   *
   * Related operations include login for existing admins, refresh to renew
   * tokens based on todo_app_refresh_tokens, and email verification flows
   * backed by todo_app_email_verifications. Error handling should reflect
   * uniqueness on email and policy validation for password strength.
   *
   * @param connection
   * @param body Registration payload for creating a systemAdmin account.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ITodoAppSystemAdminJoin.ICreate,
  ): Promise<ITodoAppSystemAdmin.IAuthorized> {
    try {
      return await postauthSystemAdminJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Login a systemAdmin via todo_app_users and issue session/refresh artifacts.
   *
   * This endpoint validates the admin’s email and password against
   * todo_app_users, using the stored password_hash. The account’s status and
   * email_verified flags determine eligibility to authenticate. On success, it
   * records a new session in todo_app_sessions with issued_at/expires_at and
   * optional ip/user_agent, and creates a refresh token in
   * todo_app_refresh_tokens with issued_at/expires_at and token_hash.
   *
   * The todo_app_login_attempts table may be recorded separately by the
   * application for success/failure analytics (success, failure_reason,
   * occurred_at, ip, user_agent), but this endpoint focuses on establishing
   * authenticated state.
   *
   * Returned data follows the authorized contract, carrying access and refresh
   * tokens derived from todo_app_sessions and todo_app_refresh_tokens. The
   * user’s last_login_at in todo_app_users can be updated to reflect the
   * successful login event.
   *
   * This operation should not touch private todo data and is restricted to
   * authentication surfaces. It interoperates with email verification flows
   * tracked by todo_app_email_verifications, where email_verified and
   * verified_at govern access.
   *
   * Related endpoints are refresh for token renewal and logout or revoke
   * sessions backed by todo_app_session_revocations. Errors include invalid
   * credentials, suspended status in status, or unverified email as applicable
   * to business policy.
   *
   * @param connection
   * @param body Login credentials for systemAdmin authentication.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ITodoAppSystemAdminLogin.ICreate,
  ): Promise<ITodoAppSystemAdmin.IAuthorized> {
    try {
      return await postauthSystemAdminLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh tokens for systemAdmin using todo_app_refresh_tokens and
   * todo_app_sessions.
   *
   * This endpoint processes a refresh token associated with a session in
   * todo_app_sessions. The request includes a refresh token whose token_hash
   * maps to a row in todo_app_refresh_tokens that is not expired and not
   * revoked/rotated. On valid input, the service rotates the token (sets
   * rotated_at on the current record, creates a new child token referencing
   * parent_id) and can update todo_app_sessions metadata such as updated_at.
   *
   * The response returns new access credentials following the authorized
   * contract. Rotation and revocation states are enforced strictly using fields
   * like expires_at, rotated_at, revoked_at, and revoked_reason in
   * todo_app_refresh_tokens and revoked_at/revoked_reason in todo_app_sessions
   * if applicable.
   *
   * Security posture follows the schema’s recommendation to avoid plaintext
   * storage of tokens, using token_hash for durable lookups. No private todo
   * content is accessed through this flow, and the user’s core account data
   * remains in todo_app_users.
   *
   * This operation is complementary to login for first-time access and to
   * logout/session revocation that may set entries in
   * todo_app_session_revocations. Errors include expired or revoked tokens, or
   * mismatched session associations.
   *
   * Policy may cap session lifetimes by comparing issued_at/expires_at across
   * both the session and refresh chain to enforce maximum durations.
   *
   * @param connection
   * @param body Refresh request containing the refresh token.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ITodoAppSystemAdminRefresh.ICreate,
  ): Promise<ITodoAppSystemAdmin.IAuthorized> {
    try {
      return await postauthSystemAdminRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
