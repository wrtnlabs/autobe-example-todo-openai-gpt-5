import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postauthGuestVisitorJoin } from "../../../providers/postauthGuestVisitorJoin";
import { postauthGuestVisitorRefresh } from "../../../providers/postauthGuestVisitorRefresh";
import { postauthGuestVisitorLogout } from "../../../providers/postauthGuestVisitorLogout";
import { GuestvisitorAuth } from "../../../decorators/GuestvisitorAuth";
import { GuestvisitorPayload } from "../../../decorators/payload/GuestvisitorPayload";

import { ITodoAppGuestVisitor } from "../../../api/structures/ITodoAppGuestVisitor";
import { ITodoAppSessionRevocation } from "../../../api/structures/ITodoAppSessionRevocation";

@Controller("/auth/guestVisitor")
export class AuthGuestvisitorController {
  /**
   * Register a guestVisitor in todo_app_users and issue session and refresh
   * tokens via todo_app_sessions and todo_app_refresh_tokens.
   *
   * This operation registers a temporary "guestVisitor" account and immediately
   * issues authentication credentials based on the schema under Actors and
   * Auth. The core identity is persisted in todo_app_users using fields such as
   * email (optional in this flow), password_hash (server-generated, never
   * plaintext), status (e.g., an application-defined state string),
   * email_verified (false when verification is outstanding), verified_at (null
   * until verified), last_login_at (set upon first successful authentication),
   * and system timestamps created_at and updated_at.
   *
   * Once the user is created, a new access session is inserted into
   * todo_app_sessions, capturing session_token (opaque, unique), issued_at,
   * expires_at, and available client context such as ip and user_agent. The
   * session forms the anchor for refresh rotation and subsequent audit logging.
   * The system then inserts the initial refresh token into
   * todo_app_refresh_tokens with token_hash (one‑way hash of the raw token),
   * issued_at, expires_at, parent_id set to null for the first issuance, and
   * optional rotation/revocation fields remaining null at creation.
   *
   * For services requiring email verification, a record can be prepared in
   * todo_app_email_verifications with token_hash, target_email, sent_at,
   * expires_at, and future consumption fields (consumed_at, failure_count).
   * Until verification succeeds, the todo_app_users.email_verified remains
   * false and verified_at remains null, consistent with the schema.
   *
   * Security considerations include never storing raw credentials (only
   * password_hash on todo_app_users) and generating non‑guessable session_token
   * and refresh token values. Client metadata such as ip and user_agent should
   * be captured in todo_app_sessions for security analytics and downstream
   * business events, aligning with fields present in the Auth schema.
   *
   * Related operations in this authentication workflow are the refresh endpoint
   * for token renewal, the email verification confirmation endpoint for
   * verifying target_email, and the logout endpoint that records revocation via
   * todo_app_session_revocations and sets revoked_at on todo_app_sessions.
   * Error handling should report validation failures (e.g., invalid email
   * format) without exposing sensitive internals or raw token values.
   *
   * @param connection
   * @param body Guest join payload (optional email and client context).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ITodoAppGuestVisitor.IJoin,
  ): Promise<ITodoAppGuestVisitor.IAuthorized> {
    try {
      return await postauthGuestVisitorJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Rotate todo_app_refresh_tokens and return new credentials for guestVisitor;
   * extend or reissue todo_app_sessions as needed.
   *
   * This operation accepts a refresh token and returns fresh authentication
   * credentials for the current guestVisitor subject. According to the Auth
   * schema, the refresh token information is stored in todo_app_refresh_tokens,
   * which includes token_hash for lookup, parent_id for rotation chaining,
   * issued_at and expires_at for validity, and rotated_at or revoked_at for
   * lifecycle control. On valid use, the system creates a new child record
   * (rotation) and marks the prior token's rotated_at while preserving
   * revocation fields when applicable.
   *
   * The access session context is represented by todo_app_sessions with
   * issued_at and expires_at used to determine session validity windows.
   * Depending on policy, the same session may be extended or a new session may
   * be created, using the fields ip and user_agent as available context. Any
   * revocation action is recorded via revoked_at and revoked_reason on the
   * session and may also be captured in todo_app_session_revocations for
   * explicit provenance.
   *
   * The subject account is stored in todo_app_users, where fields like status,
   * email_verified, and verified_at can be consulted to ensure the account is
   * eligible for continued authentication. If business policies deny refresh
   * for certain status values, the endpoint must respond accordingly while
   * avoiding disclosure of sensitive internals.
   *
   * Security considerations include strict validation of token_hash
   * correspondence, rotation semantics that render the prior token unusable
   * after successful refresh, and consistent handling of expiry based on
   * expires_at values in both todo_app_refresh_tokens and todo_app_sessions.
   * Client context (ip, user_agent) may be used for anomaly detection
   * consistent with the schema.
   *
   * This endpoint is used together with the guest join operation and
   * complements verification and logout flows. Errors differentiate between
   * invalid/expired tokens and policy gating while maintaining consistent,
   * privacy‑preserving messages.
   *
   * @param connection
   * @param body Refresh token request payload (token and client context).
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ITodoAppGuestVisitor.IRefreshRequest,
  ): Promise<ITodoAppGuestVisitor.IAuthorized> {
    try {
      return await postauthGuestVisitorRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Revoke current session in todo_app_sessions and create
   * todo_app_session_revocations for guestVisitor logout.
   *
   * This operation terminates the caller’s active session by updating the
   * corresponding todo_app_sessions record with revoked_at and an optional
   * revoked_reason. To ensure auditability, a single record is inserted into
   * todo_app_session_revocations for that session, covering the fields
   * revoked_at, revoked_by (e.g., "user"), and a free‑form reason consistent
   * with the schema.
   *
   * The endpoint requires the caller to be authenticated as a guestVisitor. It
   * does not alter the underlying todo_app_users identity record; it only
   * affects session validity and related refresh tokens per policy. The
   * implementation should also consider invalidating outstanding refresh tokens
   * associated with the session via todo_app_refresh_tokens by setting
   * revoked_at and revoked_reason when applicable.
   *
   * Security considerations include idempotent handling (revoking an already
   * revoked session returns success without additional state changes) and
   * avoiding disclosure of token internals. Client context (ip, user_agent)
   * captured in todo_app_sessions remains available for subsequent audits.
   *
   * This operation is typically used after join or refresh and complements the
   * refresh flow and email verification steps. Errors include missing
   * authentication and policy-based denials.
   *
   * On success, the response returns a concise summary derived from
   * todo_app_session_revocations for traceability.
   *
   * @param connection
   * @param body Logout request payload (optional reason or scope).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("logout")
  public async logout(
    @GuestvisitorAuth()
    guestVisitor: GuestvisitorPayload,
    @TypedBody()
    body: ITodoAppSessionRevocation.ICreate,
  ): Promise<ITodoAppSessionRevocation.ISummary> {
    try {
      return await postauthGuestVisitorLogout({
        guestVisitor,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
