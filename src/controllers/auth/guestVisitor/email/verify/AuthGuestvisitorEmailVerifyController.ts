import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postauthGuestVisitorEmailVerify } from "../../../../../providers/postauthGuestVisitorEmailVerify";

import { ITodoAppEmailVerification } from "../../../../../api/structures/ITodoAppEmailVerification";

@Controller("/auth/guestVisitor/email/verify")
export class AuthGuestvisitorEmailVerifyController {
  /**
   * Consume todo_app_email_verifications to set todo_app_users.email_verified
   * and verified_at.
   *
   * This operation validates a verification token stored in
   * todo_app_email_verifications by matching token_hash within its expires_at
   * window and marking consumption using consumed_at while optionally
   * increasing failure_count for invalid attempts. When valid, the subject
   * user’s todo_app_users record is updated to set email_verified to true and
   * verified_at to the current time. If the flow is part of an email change,
   * target_email can guide which address is being confirmed per schema.
   *
   * No authentication is required, and the endpoint must avoid revealing
   * whether a given token corresponds to an existing account except through
   * success or failure of the verification. The process updates only the
   * specific fields defined in the schema and does not expose the raw token at
   * any point.
   *
   * Security considerations include honoring the expiry semantics, ensuring
   * idempotent handling for already consumed tokens via consumed_at, and
   * maintaining minimal, consistent error messages. The operation may emit
   * business events externally using the available context such as ip and
   * user_agent if captured.
   *
   * This endpoint is commonly preceded by the guest join operation (when
   * target_email is provided) or a change‑email request. It complements the
   * resend operation which creates a fresh entry in
   * todo_app_email_verifications and re-triggers delivery.
   *
   * Errors include invalid or expired tokens and policy gating when the account
   * status does not allow verification at this time.
   *
   * @param connection
   * @param body Email verification confirmation payload (token).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async verifyEmail(
    @TypedBody()
    body: ITodoAppEmailVerification.IConfirm,
  ): Promise<ITodoAppEmailVerification.ISummary> {
    try {
      return await postauthGuestVisitorEmailVerify({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
