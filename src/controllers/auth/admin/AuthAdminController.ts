import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postAuthAdminJoin } from "../../../providers/postAuthAdminJoin";
import { postAuthAdminLogin } from "../../../providers/postAuthAdminLogin";
import { postAuthAdminRefresh } from "../../../providers/postAuthAdminRefresh";
import { postAuthAdminLogout } from "../../../providers/postAuthAdminLogout";
import { AdminAuth } from "../../../decorators/AdminAuth";
import { AdminPayload } from "../../../decorators/payload/AdminPayload";

import { ITodoMvpAdmin } from "../../../api/structures/ITodoMvpAdmin";
import { ITodoMvpAdminJoin } from "../../../api/structures/ITodoMvpAdminJoin";
import { ITodoMvpAdminLogin } from "../../../api/structures/ITodoMvpAdminLogin";
import { ITodoMvpAdminRefresh } from "../../../api/structures/ITodoMvpAdminRefresh";

@Controller("/auth/admin")
export class AuthAdminController {
  /**
   * Register a new admin in Actors.todo_mvp_admins and issue initial
   * authorization via Auth.todo_mvp_sessions.
   *
   * Purpose and functionality: This endpoint creates a new administrator in the
   * Actors.todo_mvp_admins table by persisting the unique email and a derived
   * password_hash. The table comment specifies that admins are managed
   * independently from todo_mvp_users to preserve clear authorization
   * boundaries. The operation initializes lifecycle timestamps (created_at and
   * updated_at) and sets the status field to a value appropriate for business
   * policy (the schema comment suggests values like "active" or
   * "deactivated").
   *
   * Implementation details: The request’s secret is never stored in plaintext;
   * instead, a strong hash (e.g., Argon2/bcrypt) is computed and stored in
   * todo_mvp_admins.password_hash. After insertion, a corresponding session in
   * Auth.todo_mvp_sessions is created with the new admin’s id assigned to
   * todo_mvp_admin_id, a generated and hashed session_token_hash, and
   * timestamps populated for created_at, updated_at, last_accessed_at, and an
   * appropriate expires_at. The unique index @@unique([email]) in
   * todo_mvp_admins is enforced to avoid duplicate accounts.
   *
   * Role integration and business context: Administrators provide
   * platform-level oversight (aggregate insights and account lifecycle) without
   * browsing or editing member Todo content per the requirements. Keeping
   * admins separate from users (todo_mvp_admins vs todo_mvp_users) ensures
   * clear role separation when producing tokens. The session linkage and
   * indices on Auth.todo_mvp_sessions (including expires_at-related indexes)
   * support efficient token validation and expiration checks.
   *
   * Security considerations: The service must validate email parity with the
   * business rules and ensure secure hash generation and constant-time
   * verification practices. Rate limiting and duplicate-email handling should
   * be applied. The status column can be checked during subsequent
   * authentications to restrict access to deactivated accounts. No plaintext
   * credentials are logged; only a session_token_hash is stored for
   * verification, as guided by the Auth.todo_mvp_sessions schema comment.
   *
   * Related operations and behavior: Newly created admins can subsequently
   * authenticate via /auth/admin/login and renew access via
   * /auth/admin/refresh. If email uniqueness is violated, the operation returns
   * a conflict-style outcome. Failure to create the corresponding session
   * should fail registration to avoid orphaned accounts without initial
   * access.
   *
   * @param connection
   * @param body Registration payload with administrator credentials.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @TypedBody()
    body: ITodoMvpAdminJoin.ICreate,
  ): Promise<ITodoMvpAdmin.IAuthorized> {
    try {
      return await postAuthAdminJoin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Authenticate an admin from Actors.todo_mvp_admins and create/rotate a
   * session in Auth.todo_mvp_sessions.
   *
   * Purpose and functionality: Validate administrator credentials from
   * Actors.todo_mvp_admins using the provided email and a password verified
   * against password_hash. The table’s comment highlights admins’ independence
   * from users for clear authorization scoping. Only administrator accounts in
   * a permitted status (e.g., "active") should be allowed to authenticate.
   *
   * Implementation details: Upon successful verification, create or rotate a
   * session in Auth.todo_mvp_sessions with todo_mvp_admin_id set, generating a
   * new session_token_hash and populating created_at (on first session) or
   * updated_at (on rotation), last_accessed_at, and a fresh expires_at. The
   * presence of @@unique([email]) on todo_mvp_admins ensures lookup by email
   * yields a single record.
   *
   * Role-specific integration: Returned tokens represent administrator
   * authorization, enabling access to admin-only capabilities (e.g., aggregate
   * reporting or account lifecycle actions) while not granting visibility into
   * member Todo content. All admin-scoped authorization checks should resolve
   * against the admin identity (todo_mvp_admins.id) and associated sessions.
   *
   * Security considerations: The plaintext password is never persisted and is
   * compared to password_hash using a side-channel-resistant method. Repeated
   * failures should be rate-limited. The status column enforces operational
   * control (e.g., deny logins when status indicates deactivation). Session
   * data is stored as a hash (session_token_hash) to prevent token leakage at
   * rest.
   *
   * Related operations and workflow: Use /auth/admin/refresh to renew tokens
   * using a valid refresh token. For session termination, see
   * /auth/admin/logout. If the referenced admin record cannot be found or
   * status is not allowed, the operation returns an authentication failure
   * outcome without revealing existence details.
   *
   * @param connection
   * @param body Login credentials for the administrator.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @TypedBody()
    body: ITodoMvpAdminLogin.ICreate,
  ): Promise<ITodoMvpAdmin.IAuthorized> {
    try {
      return await postAuthAdminLogin({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refresh admin authorization by rotating Auth.todo_mvp_sessions tied to
   * Actors.todo_mvp_admins.
   *
   * Purpose and functionality: Renew administrator access tokens without full
   * credential re-entry by validating a refresh token mapped to a record in
   * Auth.todo_mvp_sessions. The session must be associated to an admin via
   * todo_mvp_admin_id and in good standing.
   *
   * Implementation details: On success, rotate session_token_hash, set
   * last_accessed_at to now, update updated_at, and set a new expires_at window
   * per policy. Reject refresh when expires_at is in the past, when revoked_at
   * is set, or when the linked Actors.todo_mvp_admins record indicates a
   * disallowed status. Indexed fields on Auth.todo_mvp_sessions (e.g.,
   * expires_at, revoked_at combinations) support efficient validation.
   *
   * Role integration and business context: This endpoint continues the
   * administrator’s authenticated lifecycle while respecting role separation
   * from members. The returned authorization bundle represents admin privileges
   * and should be scoped for administrative-only operations consistent with MVP
   * boundaries.
   *
   * Security considerations: Only a hashed session_token_hash is stored; the
   * refresh token presented by the client must match the stored hash. Implement
   * rotation to prevent replay and ensure tokens are short-lived as guided by
   * expires_at. Avoid revealing whether a specific session exists when
   * validation fails; return a generic refresh failure outcome.
   *
   * Related operations and dependencies: Typically invoked after a successful
   * /auth/admin/login or /auth/admin/join. For ending access,
   * /auth/admin/logout marks the session as revoked so that subsequent refresh
   * attempts fail.
   *
   * @param connection
   * @param body Refresh token/session reference to renew authorization.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @TypedBody()
    body: ITodoMvpAdminRefresh.ICreate,
  ): Promise<ITodoMvpAdmin.IAuthorized> {
    try {
      return await postAuthAdminRefresh({
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Revoke the current admin session in Auth.todo_mvp_sessions without
   * modifying Actors.todo_mvp_admins.
   *
   * Purpose and functionality: End the active admin session by recording a
   * revocation timestamp in Auth.todo_mvp_sessions.revoked_at for the caller’s
   * session. This prevents further use of the underlying token for refresh, as
   * advised by the session lifecycle columns.
   *
   * Implementation details: The provider function identifies the caller’s
   * active session (todo_mvp_admin_id present) and sets revoked_at to the
   * current time, while updating updated_at. Subsequent calls to
   * /auth/admin/refresh should fail because the session is revoked or otherwise
   * invalid per expires_at.
   *
   * Role integration and business context: This is an admin-scoped security
   * operation. It does not touch Actors.todo_mvp_admins credentials or status;
   * it solely changes Auth.todo_mvp_sessions for the current session.
   *
   * Security considerations: Ensure the operation targets only the caller’s
   * session context obtained from the authenticated request. No plaintext
   * secrets are handled here; only session metadata is updated.
   *
   * Related operations and workflow: Use /auth/admin/login to establish a
   * session and /auth/admin/refresh to maintain it. After logout, further
   * refresh attempts should be rejected for that session.
   *
   * @param connection
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("logout")
  public async logout(
    @AdminAuth()
    admin: AdminPayload,
  ): Promise<void> {
    try {
      return await postAuthAdminLogout({
        admin,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
