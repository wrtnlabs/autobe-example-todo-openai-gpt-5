import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { putAuthAdminPassword } from "../../../../providers/putAuthAdminPassword";
import { AdminAuth } from "../../../../decorators/AdminAuth";
import { AdminPayload } from "../../../../decorators/payload/AdminPayload";

import { ITodoMvpAdminSecurityResult } from "../../../../api/structures/ITodoMvpAdminSecurityResult";
import { ITodoMvpAdminPassword } from "../../../../api/structures/ITodoMvpAdminPassword";

@Controller("/auth/admin/password")
export class AuthAdminPasswordController {
  /**
   * Update Actors.todo_mvp_admins.password_hash for the authenticated admin and
   * optionally revoke other sessions in Auth.todo_mvp_sessions.
   *
   * Purpose and functionality: Enable an administrator to update their
   * credential by writing a new derived hash into
   * Actors.todo_mvp_admins.password_hash. The table’s comment notes that
   * plaintext passwords are never stored; only a hash is persisted. The
   * operation updates updated_at accordingly in the admin record.
   *
   * Implementation details: The handler should verify the current secret
   * against password_hash using a secure comparison before accepting the new
   * secret. After successful verification, compute a strong hash for the new
   * secret and store it in password_hash, updating updated_at. Implementers may
   * choose to revoke other sessions in Auth.todo_mvp_sessions for the same
   * admin by setting revoked_at to prevent continued use of older tokens.
   *
   * Role-specific integration: This admin-only security operation affects only
   * the administrator’s own credential and does not interact with member
   * entities or content. It aligns with the requirement that admins have
   * oversight functions but no routine access to member Todo content.
   *
   * Security considerations: Enforce strong password policies at the
   * application layer as appropriate. No secrets should be logged. Consider
   * rate limiting and lockout strategies if repeated verification failures
   * occur.
   *
   * Related operations and workflow: After changing the password, the admin may
   * need to re-authenticate via /auth/admin/login. If the implementation
   * revokes other sessions, refresh attempts made from those sessions should
   * fail due to revoked_at or expired expires_at.
   *
   * @param connection
   * @param body Payload containing the current password and the new password.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put()
  public async updatePassword(
    @AdminAuth()
    admin: AdminPayload,
    @TypedBody()
    body: ITodoMvpAdminPassword.IUpdate,
  ): Promise<ITodoMvpAdminSecurityResult> {
    try {
      return await putAuthAdminPassword({
        admin,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
