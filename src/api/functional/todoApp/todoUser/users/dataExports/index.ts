import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppDataExport } from "../../../../../structures/ITodoAppDataExport";
import { IPageITodoAppDataExport } from "../../../../../structures/IPageITodoAppDataExport";

/**
 * Create a new personal data export request in todo_app_data_exports.
 *
 * This endpoint allows an authenticated user to initiate a new export job of
 * their personal data. The underlying table todo_app_data_exports captures the
 * job’s lifecycle including status transitions (e.g., requested → processing →
 * completed or failed → expired) and integrity details (checksum,
 * file_size_bytes). The creation flow typically stores minimal user-provided
 * options such as export_format while all other lifecycle attributes are
 * system-managed during processing.
 *
 * Security and permissions: only the resource owner (todoUser) may create an
 * export for their own account. The controller/provider must enforce that the
 * path userId matches the authenticated subject. Administrative roles do not
 * use this endpoint for routine operations. The export record’s ownership is
 * established by setting todo_app_user_id to userId; subsequent retrievals must
 * filter by this relationship.
 *
 * Validation and business rules: validate export_format against supported
 * values (e.g., json or csv per product policy) and apply rate/fair-use limits
 * where configured. Newly created jobs set an initial status such as requested,
 * and do not include download_uri until processing completes. Records with
 * deleted_at set are excluded from normal flows by policy. This operation
 * should not accept system-managed fields like status, download_uri, checksum,
 * completed_at, or expires_at from clients; those are set by processing logic.
 *
 * Related operations: clients typically follow with GET
 * /users/{userId}/dataExports/{dataExportId} to poll status and obtain the
 * download_uri upon completion. Privacy workflows may also include listing and
 * viewing account deletion requests; however, those are separate resources.
 *
 * Error handling: reject invalid input (e.g., unsupported export_format). If
 * rate limits are exceeded, respond with a throttling outcome. Ensure ownership
 * and avoid exposing other users’ records.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the owner user initiating the export
 * @param props.body Creation payload specifying export options; system manages
 *   status and processing fields
 * @path /todoApp/todoUser/users/:userId/dataExports
 * @accessor api.functional.todoApp.todoUser.users.dataExports.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the owner user initiating the export */
    userId: string & tags.Format<"uuid">;

    /**
     * Creation payload specifying export options; system manages status and
     * processing fields
     */
    body: ITodoAppDataExport.ICreate;
  };
  export type Body = ITodoAppDataExport.ICreate;
  export type Response = ITodoAppDataExport;

  export const METADATA = {
    method: "POST",
    path: "/todoApp/todoUser/users/:userId/dataExports",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/dataExports`;
  export const random = (): ITodoAppDataExport =>
    typia.random<ITodoAppDataExport>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/search data exports (todo_app_data_exports) for a user.
 *
 * Return a paginated list of data export requests associated with the specified
 * user. The Prisma model todo_app_data_exports includes: id (UUID),
 * todo_app_user_id (FK), status, export_format, download_uri (URI when ready),
 * file_size_bytes, checksum, status_message, completed_at, expires_at,
 * request_ip, request_user_agent, created_at, updated_at, and deleted_at. The
 * schema comments emphasize that this table stores workflow metadata and links
 * only; private todo content is not stored in this table.
 *
 * Security: Access is restricted to the owner (todoUser). The provider must
 * ensure path userId matches the authenticated principal and filter results to
 * rows where todo_app_data_exports.todo_app_user_id equals that user. Access
 * attempts for other users must be denied without indicating whether records
 * exist.
 *
 * List behavior: The request body ITodoAppDataExport.IRequest should support
 * pagination (page size within 1–100, default typically 20), filtering by
 * status (e.g., requested, processing, completed, failed, expired), optional
 * date ranges (created_at, completed_at), and sorting by created_at or
 * completed_at. Exclude rows considered removed from normal access (deleted_at
 * set). For completed entries, download_uri is a URI string and should be
 * treated as sensitive with expiry semantics per expires_at.
 *
 * @param props.connection
 * @param props.userId Owner user’s ID (UUID) to scope data export jobs
 * @param props.body Filtering, sorting, and pagination criteria for listing
 *   data export jobs
 * @path /todoApp/todoUser/users/:userId/dataExports
 * @accessor api.functional.todoApp.todoUser.users.dataExports.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Owner user’s ID (UUID) to scope data export jobs */
    userId: string & tags.Format<"uuid">;

    /**
     * Filtering, sorting, and pagination criteria for listing data export
     * jobs
     */
    body: ITodoAppDataExport.IRequest;
  };
  export type Body = ITodoAppDataExport.IRequest;
  export type Response = IPageITodoAppDataExport.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/todoUser/users/:userId/dataExports",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/dataExports`;
  export const random = (): IPageITodoAppDataExport.ISummary =>
    typia.random<IPageITodoAppDataExport.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a user’s data export job by ID from todo_app_data_exports.
 *
 * This operation returns the detailed personal data export job for the
 * specified user and export identifier. In the Prisma schema,
 * todo_app_data_exports represents user-initiated data export requests and
 * tracks lifecycle fields like status (requested, processing, completed,
 * failed, expired), completion timestamps, and an optional download_uri for
 * retrieval once processing is finished. The model also captures request
 * context (request_ip, request_user_agent) and integrity metadata (checksum,
 * file_size_bytes) to support trustworthy downloads.
 *
 * Security and permissions: the result must belong to the authenticated user
 * indicated by userId. Access is limited to the resource owner in line with the
 * privacy and access boundaries described in the business requirements.
 * Administrative roles do not routinely access private export content; this
 * endpoint is intended for end users (todoUser role) to view their own job
 * details. If an export job does not belong to the user or does not exist, the
 * provider should respond without revealing the existence of other users’
 * records.
 *
 * Entity relationships: the export record references todo_app_users via
 * todo_app_user_id. The operation must filter by this FK to enforce ownership.
 * Listings and lookups should normally exclude records marked as deleted via
 * the deleted_at column according to retention policies, returning only active
 * records in normal flows.
 *
 * Validation and behavior: the path parameters must be valid UUIDs. The
 * operation returns the full export job object including status, export_format,
 * and when available, download_uri and expires_at so clients can render a
 * download action. No request body is required. Related operations include POST
 * /users/{userId}/dataExports to create a new export request and search/list
 * operations on account deletion requests for privacy workflows.
 *
 * Error handling: if the export is not found for the given userId and
 * dataExportId pair, return a not-found outcome consistent with access control
 * guidance. Avoid leaking cross-user existence. If the export has expired
 * (expires_at in the past), clients should expect download_uri to be unusable
 * and may initiate a new export.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the owner user
 * @param props.dataExportId Unique identifier of the data export job
 * @path /todoApp/todoUser/users/:userId/dataExports/:dataExportId
 * @accessor api.functional.todoApp.todoUser.users.dataExports.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the owner user */
    userId: string & tags.Format<"uuid">;

    /** Unique identifier of the data export job */
    dataExportId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppDataExport;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/todoUser/users/:userId/dataExports/:dataExportId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/dataExports/${encodeURIComponent(props.dataExportId ?? "null")}`;
  export const random = (): ITodoAppDataExport =>
    typia.random<ITodoAppDataExport>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("dataExportId")(() => typia.assert(props.dataExportId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
