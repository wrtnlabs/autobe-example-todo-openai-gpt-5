import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppUserPreference } from "../../../../../structures/ITodoAppUserPreference";

/**
 * Get user preferences (todo_app_user_preferences) for the specified userId.
 *
 * This operation fetches per-user preference settings from
 * todo_app_user_preferences. Fields include timezone (e.g., "Asia/Seoul"),
 * locale (e.g., "en-US"), and page_size (integer, typical allowed range 1–100
 * per business rules). The model is one-to-one with todo_app_users through
 * todo_app_user_preferences.todo_app_user_id and maintains
 * created_at/updated_at timestamps with an additional deleted_at timestamp for
 * lifecycle control.
 *
 * Security: Only authenticated end users (todoUser) can access their own
 * preferences. The controller/provider must verify that the authenticated
 * user’s id matches the {userId} path parameter. Administrative access to
 * private preference values is not part of routine operations for MVP.
 *
 * Behavior and error handling: If no preferences record exists for the user,
 * the service may either return not-found or elect to lazily initialize
 * defaults at a higher layer; this API describes retrieval only and does not
 * perform creation. Records where deleted_at is non-null should be ignored for
 * normal reads. Validation is not required for GET, but downstream consumers
 * should interpret timezone and locale per their standards.
 *
 * Related operations: Separate endpoints (not defined here) would handle
 * creation or update of preferences. This GET operation solely returns the
 * existing preferences for the specified userId.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user whose preferences are
 *   requested.
 * @path /todoApp/todoUser/users/:userId/preferences
 * @accessor api.functional.todoApp.todoUser.users.preferences.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the user whose preferences are requested. */
    userId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppUserPreference;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/todoUser/users/:userId/preferences",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/preferences`;
  export const random = (): ITodoAppUserPreference =>
    typia.random<ITodoAppUserPreference>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a user preference record (todo_app_user_preferences) for the specified
 * user.
 *
 * Create a user preference record bound to the owner identified by userId.
 * According to the Prisma schema for todo_app_user_preferences, this table
 * stores per-user settings: timezone (IANA identifier such as "Asia/Seoul"),
 * locale (BCP 47 tag such as "en-US"), and page_size (integer with business
 * rule range 1–100). The model also contains created_at, updated_at, and an
 * optional deleted_at. The relationship to todo_app_users is one-to-one through
 * todo_app_user_id with a unique constraint, ensuring each account has at most
 * one preference record.
 *
 * Security considerations: Only the authenticated owner should be able to
 * create their own preferences. The authorization role is limited to todoUser,
 * with ownership validation performed in application logic to ensure the path
 * parameter userId matches the authenticated principal. Administrative accounts
 * do not routinely create or modify end-user preferences.
 *
 * Relationship to underlying entities: The preference record references
 * todo_app_users via a required FK. The table’s columns (timezone, locale,
 * page_size) directly influence business behavior, such as timezone-aware
 * interpretation for due_at in todo_app_todos and default page sizes for list
 * endpoints. Creation should populate created_at/updated_at, leaving deleted_at
 * null. Attempts to create a second record must be rejected due to the unique
 * constraint on todo_app_user_id.
 *
 * Validation and business logic: Enforce that page_size respects business
 * limits (typically 1–100). Validate timezone strings against known IANA
 * identifiers and locale strings against BCP 47 format. If validation fails,
 * return a clear error. If a record already exists for the user, return a
 * conflict response.
 *
 * Related operations: Use PUT /users/{userId}/preferences to update an existing
 * record. There is no separate delete endpoint in this scope; preference
 * lifecycle can be handled via updates or administrative processes if needed.
 *
 * Error handling: Return validation errors for bad timezone/locale formats or
 * out-of-range page_size. Return conflict if a record for the given user
 * already exists. Ensure ownership checks deny cross-user attempts without
 * revealing existence of other users’ data.
 *
 * @param props.connection
 * @param props.userId Owner user’s ID whose preferences are being created.
 * @param props.body Initial preference settings for the user, including
 *   timezone, locale, and page size.
 * @path /todoApp/todoUser/users/:userId/preferences
 * @accessor api.functional.todoApp.todoUser.users.preferences.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Owner user’s ID whose preferences are being created. */
    userId: string & tags.Format<"uuid">;

    /**
     * Initial preference settings for the user, including timezone, locale,
     * and page size.
     */
    body: ITodoAppUserPreference.ICreate;
  };
  export type Body = ITodoAppUserPreference.ICreate;
  export type Response = ITodoAppUserPreference;

  export const METADATA = {
    method: "POST",
    path: "/todoApp/todoUser/users/:userId/preferences",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/preferences`;
  export const random = (): ITodoAppUserPreference =>
    typia.random<ITodoAppUserPreference>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing user preference record (todo_app_user_preferences) for the
 * specified user.
 *
 * Update the user’s existing preference record indicated by userId. Per the
 * Prisma schema for todo_app_user_preferences, this table holds: timezone (IANA
 * identifier), locale (BCP 47 tag), and page_size (integer). System-managed
 * timestamps include created_at and updated_at; deleted_at is optional. The
 * foreign key todo_app_user_id enforces ownership and uniqueness across users.
 *
 * Security and permissions: Only the authenticated owner should update their
 * own preferences. The authorization role is todoUser, with ownership verified
 * in application logic by comparing the authenticated principal to the path
 * parameter userId. Administrative actors do not routinely edit private user
 * preferences.
 *
 * Entity relationships: The preference record is 1:1 with todo_app_users
 * (unique on todo_app_user_id). Preference values impact interpretation of
 * due_at in todo_app_todos (timezone) and display language (locale), as well as
 * default pagination size for list endpoints (page_size).
 *
 * Validation rules and business logic: Validate timezone against IANA
 * identifiers, locale against BCP 47, and page_size within allowed range
 * (1–100). Update should set updated_at to the current time. If the preference
 * record does not exist for the user, return a not found error, avoiding
 * disclosure beyond the current user context.
 *
 * Related operations: Use POST /users/{userId}/preferences to create a
 * preference record if none exists. Reading preferences can be exposed via a
 * corresponding GET endpoint if required by the client design.
 *
 * Error handling: Provide field-specific validation messages on incorrect
 * formats or ranges. Return not found when no preference record exists for the
 * user. Deny access if an authenticated user attempts to modify another user’s
 * preferences.
 *
 * @param props.connection
 * @param props.userId Owner user’s ID whose preferences are being updated.
 * @param props.body Partial or full updates to timezone, locale, and page size.
 * @path /todoApp/todoUser/users/:userId/preferences
 * @accessor api.functional.todoApp.todoUser.users.preferences.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Owner user’s ID whose preferences are being updated. */
    userId: string & tags.Format<"uuid">;

    /** Partial or full updates to timezone, locale, and page size. */
    body: ITodoAppUserPreference.IUpdate;
  };
  export type Body = ITodoAppUserPreference.IUpdate;
  export type Response = ITodoAppUserPreference;

  export const METADATA = {
    method: "PUT",
    path: "/todoApp/todoUser/users/:userId/preferences",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/preferences`;
  export const random = (): ITodoAppUserPreference =>
    typia.random<ITodoAppUserPreference>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logically delete user preferences (todo_app_user_preferences) by userId.
 *
 * This endpoint marks the preferences record in todo_app_user_preferences as
 * deleted by setting deleted_at. The preferences table is 1:1 with
 * todo_app_users via todo_app_user_id and stores user-controlled presentation
 * and behavior such as timezone, locale, and page_size. Logical deletion
 * preserves history and supports retention workflows consistent with the
 * presence of the deleted_at column in the schema.
 *
 * Security and permissions: only the owner (role "todoUser") can delete their
 * preferences. The provider must verify that the path userId corresponds to the
 * authenticated user, and deny access for cross-user attempts without revealing
 * whether a preferences record exists.
 *
 * Database relationships: the unique constraint on todo_app_user_id ensures a
 * single preferences row per user. This endpoint addresses the preferences by
 * userId rather than a separate preferencesId, aligning with the 1:1 model and
 * typical self-service flows.
 *
 * Behavior and validation: if a preferences record is already deleted or does
 * not exist, the operation should be treated as idempotent with the
 * postcondition that no active preferences remain. Downstream systems
 * interpreting due dates and UI text (timezone, locale, page_size) should fall
 * back to service defaults after deletion until a new preferences record is
 * created.
 *
 * Related operations: separate endpoints typically allow creating or updating
 * preferences. Administrative access to private preference values is out of
 * routine scope.
 *
 * Error handling: validate userId as UUID. Deny unauthenticated requests.
 * Ensure rate limits are respected for destructive actions. The operation sets
 * deleted_at and excludes the record from subsequent normal reads.
 *
 * @param props.connection
 * @param props.userId Identifier of the owning user whose preferences should be
 *   deleted
 * @path /todoApp/todoUser/users/:userId/preferences
 * @accessor api.functional.todoApp.todoUser.users.preferences.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Identifier of the owning user whose preferences should be deleted */
    userId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoApp/todoUser/users/:userId/preferences",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/preferences`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
