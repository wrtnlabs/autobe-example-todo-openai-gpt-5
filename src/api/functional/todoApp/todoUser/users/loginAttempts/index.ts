import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppLoginAttempt } from "../../../../../structures/ITodoAppLoginAttempt";
import { IPageITodoAppLoginAttempt } from "../../../../../structures/IPageITodoAppLoginAttempt";

/**
 * Search login attempts (todo_app_login_attempts) for a specific user with
 * pagination and filters.
 *
 * Retrieve a filtered, paginated list of authentication attempts linked to a
 * user. In the Prisma schema, todo_app_login_attempts captures per-attempt
 * outcomes with columns such as id, optional todo_app_user_id (FK to
 * todo_app_users.id when the email maps to an account), email (as entered),
 * success, ip, optional user_agent, optional failure_reason, occurred_at,
 * created_at, updated_at, and a deleted_at marker. These records support
 * brute-force protection, abuse detection, and security analytics.
 *
 * Security and permissions: Only the authenticated owner should access their
 * own login attempts. Implementations must ensure the caller is the same
 * principal identified by {userId}. Administrators typically do not require
 * routine access to private per-attempt details. Apply appropriate rate
 * limiting to reduce enumeration risks.
 *
 * Entity relationships and filters: When todo_app_user_id is present, filter by
 * equality to {userId}. Depending on policy, systems may also correlate
 * attempts by the user’s current email value, but the canonical filter is the
 * FK match. The response excludes logically deleted items (deleted_at set) from
 * standard results. Typical filters include time windows over occurred_at,
 * success state, IP address, user agent, and free-text search over
 * failure_reason.
 *
 * Validation and error handling: The request body
 * (ITodoAppLoginAttempt.IRequest) defines pagination, sorting, and optional
 * filters. Reject unsupported page sizes or invalid sort keys in provider
 * logic. Common errors include invalid UUID formats for {userId} and
 * authorization failures when a user requests data for another user.
 *
 * @param props.connection
 * @param props.userId Owner user identifier (todo_app_users.id)
 * @param props.body Search, filtering, and pagination parameters for login
 *   attempts
 * @path /todoApp/todoUser/users/:userId/loginAttempts
 * @accessor api.functional.todoApp.todoUser.users.loginAttempts.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Owner user identifier (todo_app_users.id) */
    userId: string & tags.Format<"uuid">;

    /** Search, filtering, and pagination parameters for login attempts */
    body: ITodoAppLoginAttempt.IRequest;
  };
  export type Body = ITodoAppLoginAttempt.IRequest;
  export type Response = IPageITodoAppLoginAttempt.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/todoUser/users/:userId/loginAttempts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/loginAttempts`;
  export const random = (): IPageITodoAppLoginAttempt.ISummary =>
    typia.random<IPageITodoAppLoginAttempt.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get one login attempt (todo_app_login_attempts) for a user by id.
 *
 * Fetch detailed information about a single login attempt. The Prisma model
 * todo_app_login_attempts includes id, optional todo_app_user_id (FK to
 * todo_app_users.id), email (as entered), success, ip, optional user_agent,
 * optional failure_reason, occurred_at, created_at, updated_at, and a
 * deleted_at marker. This record is security-sensitive and is primarily
 * intended for a user reviewing their own account activity.
 *
 * Security and permissions: Enforce ownership by requiring that
 * todo_app_login_attempts.todo_app_user_id equals {userId}. Deny access without
 * confirming existence when a user targets another user’s data. Apply rate
 * limiting to mitigate probing. Records flagged as deleted (deleted_at set)
 * should not be returned in normal circumstances.
 *
 * Expected behavior and errors: Returns a single resource when both {userId}
 * and {loginAttemptId} identify an owned record. Return not found if the
 * identifiers are invalid, do not match, or if the record is not accessible to
 * the caller. This operation is read-only.
 *
 * @param props.connection
 * @param props.userId Owner user identifier (todo_app_users.id)
 * @param props.loginAttemptId Login attempt identifier
 *   (todo_app_login_attempts.id)
 * @path /todoApp/todoUser/users/:userId/loginAttempts/:loginAttemptId
 * @accessor api.functional.todoApp.todoUser.users.loginAttempts.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Owner user identifier (todo_app_users.id) */
    userId: string & tags.Format<"uuid">;

    /** Login attempt identifier (todo_app_login_attempts.id) */
    loginAttemptId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppLoginAttempt;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/todoUser/users/:userId/loginAttempts/:loginAttemptId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/loginAttempts/${encodeURIComponent(props.loginAttemptId ?? "null")}`;
  export const random = (): ITodoAppLoginAttempt =>
    typia.random<ITodoAppLoginAttempt>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("loginAttemptId")(() => typia.assert(props.loginAttemptId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
