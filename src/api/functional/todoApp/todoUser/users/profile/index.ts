import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppUserProfile } from "../../../../../structures/ITodoAppUserProfile";

/**
 * Get the user profile (todo_app_user_profiles) for the specified userId.
 *
 * This operation fetches the profile attached to a specific account in the
 * todoApp. The underlying Prisma model is todo_app_user_profiles, which stores
 * optional display attributes: full_name, nickname, and an avatar_uri that
 * points to an image resource as a URI string. The relation is one-to-one with
 * todo_app_users through the todo_app_user_profiles.todo_app_user_id foreign
 * key. The profile record also contains created_at and updated_at timestamps
 * for auditability and a deleted_at timestamp used to hide records from normal
 * flows.
 *
 * Security and permissions: Only authenticated end users should retrieve their
 * own profile. Although the route encodes a {userId} parameter, the provider
 * function must verify that the authenticated principal’s id matches userId to
 * prevent cross-user access. Administrators do not routinely access private
 * profile content in MVP; therefore, authorization is restricted to todoUser.
 *
 * Relationships and lookup behavior: The request uses userId (UUID) that
 * corresponds to todo_app_users.id. The service locates the profile by the
 * unique constraint on todo_app_user_profiles.todo_app_user_id. If no profile
 * exists for the user, the service returns a not-found condition consistent
 * with business error handling policies.
 *
 * Validation and business logic: No request body is required. The handler
 * should ignore profile records where deleted_at is set. If multiple records
 * exist due to data inconsistency (should not happen because of @@unique on
 * todo_app_user_id), the service must treat it as an error.
 *
 * Related operations: Creation and update of the profile are handled by POST
 * and PUT on the same resource path. Error handling follows the authentication
 * and privacy guidance: deny access when the path userId does not match the
 * authenticated user, and do not reveal existence of other users’ data.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user whose profile is requested.
 * @path /todoApp/todoUser/users/:userId/profile
 * @accessor api.functional.todoApp.todoUser.users.profile.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the user whose profile is requested. */
    userId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppUserProfile;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/todoUser/users/:userId/profile",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/profile`;
  export const random = (): ITodoAppUserProfile =>
    typia.random<ITodoAppUserProfile>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Create a user profile (todo_app_user_profiles) for the specified userId.
 *
 * Purpose: Insert a new profile associated to the user identified by {userId}.
 * The todo_app_user_profiles model contains presentation-oriented fields:
 * full_name, nickname, and avatar_uri (URI string up to 80,000 characters),
 * along with created_at/updated_at timestamps and a deleted_at timestamp for
 * lifecycle governance. A one-to-one link is enforced through a unique
 * constraint on todo_app_user_id.
 *
 * Security: Only the authenticated owner (todoUser) can create their profile.
 * The handler must verify that the authenticated user’s id equals the {userId}
 * path parameter. If the user already has a profile row (as enforced by
 * @@unique on todo_app_user_id), the service should return a conflict error and
 * advise using the update endpoint instead.
 *
 * Validation and business rules: Input values should be trimmed and validated
 * according to presentation rules. avatar_uri must be a valid URI; services
 * should treat it as a reference string (no file upload in this API). Records
 * with deleted_at should not be recreated without explicit recovery
 * policy—attempting to recreate a profile where a logically removed row still
 * exists should be handled according to business rules (typically conflict).
 *
 * Related operations: GET returns the existing profile, PUT updates an existing
 * profile, and this POST creates the first profile row for the user. Errors
 * include unauthorized when path does not match the authenticated principal and
 * conflict when a profile already exists.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user for whom the profile will
 *   be created.
 * @param props.body Profile creation payload for the specified userId.
 * @path /todoApp/todoUser/users/:userId/profile
 * @accessor api.functional.todoApp.todoUser.users.profile.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the user for whom the profile will be created. */
    userId: string & tags.Format<"uuid">;

    /** Profile creation payload for the specified userId. */
    body: ITodoAppUserProfile.ICreate;
  };
  export type Body = ITodoAppUserProfile.ICreate;
  export type Response = ITodoAppUserProfile;

  export const METADATA = {
    method: "POST",
    path: "/todoApp/todoUser/users/:userId/profile",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/profile`;
  export const random = (): ITodoAppUserProfile =>
    typia.random<ITodoAppUserProfile>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update the user profile (todo_app_user_profiles) for the specified userId.
 *
 * Purpose and overview: Modify profile attributes stored in
 * todo_app_user_profiles for the specified account. The model holds optional
 * presentation data (full_name, nickname, avatar_uri) and timestamps
 * (created_at, updated_at). The deleted_at timestamp denotes a record that
 * should be excluded from normal flows. This endpoint updates only the existing
 * profile row linked by the unique todo_app_user_id constraint.
 *
 * Security and authorization: Only the owner (todoUser) can update their
 * profile. The provider must ensure that the authenticated principal’s id
 * equals {userId}. Administrative access to private profile content is not part
 * of routine operations in MVP.
 *
 * Validation and business logic: The request body contains the fields to
 * update. The service should validate avatar_uri as a URI string and preserve
 * constraints on field lengths. If no profile exists for the user, return
 * not-found and direct the client to create it first. If the profile record is
 * marked with a non-null deleted_at, standard handlers should treat it as
 * unavailable for update unless a separate recovery workflow exists.
 *
 * Related operations: GET retrieves the profile; POST creates it if missing.
 * Error handling aligns with privacy requirements: reject cross-user updates
 * without revealing resource existence; return validation messages for
 * malformed inputs.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user whose profile will be
 *   updated.
 * @param props.body Profile update payload for the specified userId.
 * @path /todoApp/todoUser/users/:userId/profile
 * @accessor api.functional.todoApp.todoUser.users.profile.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the user whose profile will be updated. */
    userId: string & tags.Format<"uuid">;

    /** Profile update payload for the specified userId. */
    body: ITodoAppUserProfile.IUpdate;
  };
  export type Body = ITodoAppUserProfile.IUpdate;
  export type Response = ITodoAppUserProfile;

  export const METADATA = {
    method: "PUT",
    path: "/todoApp/todoUser/users/:userId/profile",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/profile`;
  export const random = (): ITodoAppUserProfile =>
    typia.random<ITodoAppUserProfile>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logically delete a user profile (todo_app_user_profiles) by userId.
 *
 * This operation performs a logical removal of a user’s profile in
 * todo_app_user_profiles by setting deleted_at. The profile table stores
 * presentational attributes for a single user (1:1 with todo_app_users)
 * including full_name, nickname, avatar_uri, and timestamps. Deletion hides the
 * profile from standard reads without erasing auditability, aligning with the
 * model’s deleted_at column.
 *
 * Security considerations: only the profile owner (role "todoUser") may delete
 * their profile via this endpoint. The provider must verify that the userId in
 * the path matches the authenticated principal and deny access otherwise
 * without revealing whether a profile exists. Administrative routines should
 * not read private profile attributes without lawful process; operational
 * governance should use separate admin workflows.
 *
 * Entity and relationship context: todo_app_user_profiles has a unique FK to
 * todo_app_users via todo_app_user_id, ensuring at most one profile per
 * account. This endpoint targets the profile by the owning userId rather than a
 * separate profileId to keep the API ergonomic for self-service.
 *
 * Validation rules and business behavior: if no active (non-deleted) profile
 * exists for the specified user, the operation should be idempotent and return
 * a confirmation that no active profile remains. Any cascading effects (e.g.,
 * clearing cached avatar) are handled by provider logic. Since deleted_at
 * exists in the schema, the operation marks the record as deleted rather than
 * permanently removing it.
 *
 * Related operations: future profile create/update endpoints would manage
 * full_name, nickname, and avatar_uri. Audit logging of the deletion action is
 * recommended via system audit mechanisms, but those records are
 * system-generated and not exposed for manual writes.
 *
 * Error handling: validate userId format as UUID. Deny when the caller is
 * unauthenticated or attempts cross-user access. If multiple edge cases occur
 * (e.g., concurrent delete), the operation remains idempotent, ensuring the
 * postcondition is that no active profile exists for the user.
 *
 * @param props.connection
 * @param props.userId Identifier of the owning user whose profile should be
 *   deleted
 * @path /todoApp/todoUser/users/:userId/profile
 * @accessor api.functional.todoApp.todoUser.users.profile.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Identifier of the owning user whose profile should be deleted */
    userId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoApp/todoUser/users/:userId/profile",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/profile`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
