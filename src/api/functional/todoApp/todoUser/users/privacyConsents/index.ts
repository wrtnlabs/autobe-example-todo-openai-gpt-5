import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppPrivacyConsent } from "../../../../../structures/ITodoAppPrivacyConsent";
import { IPageITodoAppPrivacyConsent } from "../../../../../structures/IPageITodoAppPrivacyConsent";

/**
 * Create a new privacy consent event (todo_app_privacy_consents).
 *
 * Create a privacy consent record for the account identified by userId using
 * the append-only model of todo_app_privacy_consents. Each row represents a
 * consent action with fields including purpose_code, purpose_name, granted
 * (true to grant, false to deny/withdraw), granted_at, optional revoked_at and
 * expires_at, policy_version, and optional source, ip, and user_agent. The
 * ownership link is todo_app_user_id; created_at and updated_at timestamps
 * support auditing and reporting.
 *
 * Security and permissions: Only the authenticated owner (role todoUser) may
 * create consent records for their own account. The controller must verify the
 * path userId equals the authenticated subject. Administrative users do not use
 * this endpoint for routine operations.
 *
 * Validation and business rules: Ensure required fields are present and
 * consistent. When granted is true, granted_at should be set; when representing
 * a withdrawal, granted may be false and revoked_at may be set according to
 * policy. purpose_code and policy_version must be valid per current
 * notices/policies. Optional metadata (source, ip, user_agent) may be captured
 * from the request.
 *
 * Related operations: Use PATCH /users/{userId}/privacyConsents to search
 * existing history and GET /users/{userId}/privacyConsents/{privacyConsentId}
 * to view a specific event. Updates to prior records are not typical; changes
 * are recorded as new rows to preserve history.
 *
 * Error handling: Reject attempts to write for another user’s account. Validate
 * enum-like domain values (e.g., format or policy-defined lists for
 * purpose_code) and timestamp fields. Return clear messages on validation
 * failures.
 *
 * @param props.connection
 * @param props.userId Owner user’s ID for whom the consent event is recorded
 * @param props.body Consent creation payload describing purpose,
 *   grant/withdrawal, and policy context
 * @path /todoApp/todoUser/users/:userId/privacyConsents
 * @accessor api.functional.todoApp.todoUser.users.privacyConsents.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Owner user’s ID for whom the consent event is recorded */
    userId: string & tags.Format<"uuid">;

    /**
     * Consent creation payload describing purpose, grant/withdrawal, and
     * policy context
     */
    body: ITodoAppPrivacyConsent.ICreate;
  };
  export type Body = ITodoAppPrivacyConsent.ICreate;
  export type Response = ITodoAppPrivacyConsent;

  export const METADATA = {
    method: "POST",
    path: "/todoApp/todoUser/users/:userId/privacyConsents",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/privacyConsents`;
  export const random = (): ITodoAppPrivacyConsent =>
    typia.random<ITodoAppPrivacyConsent>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search a user’s privacy consent history (todo_app_privacy_consents).
 *
 * Retrieve a filtered, paginated list of privacy consent records for the
 * account identified by userId using the Prisma model
 * todo_app_privacy_consents. This table preserves a historical trail of consent
 * actions with fields including purpose_code, purpose_name, granted (boolean),
 * granted_at, revoked_at (when applicable), expires_at (optional),
 * policy_version, source, ip, and user_agent. The record links to the owner via
 * todo_app_user_id and includes created_at and updated_at for temporal
 * querying.
 *
 * Security and permissions: Only the authenticated owner with role todoUser may
 * list their own privacy consent history. The implementation must ensure the
 * path userId matches the authenticated subject. Administrative use cases
 * review aggregated or non-personal data through separate mechanisms; routine
 * access to private consent content is not permitted.
 *
 * Query behavior: The request body supports search parameters such as purpose
 * filters (by purpose_code or purpose_name), status filters (currently active
 * grants vs revoked), time windows (granted_at ranges, revoked_at ranges,
 * expires_at ranges), and sorting preferences (e.g., granted_at desc by
 * default). Pagination parameters (page, page_size) should follow service-wide
 * conventions with typical limits (e.g., 1–100). The endpoint returns a
 * paginated page wrapper whose data elements are consent records.
 *
 * Related operations: Use POST /users/{userId}/privacyConsents to append a new
 * consent event (grant or withdrawal). Use GET
 * /users/{userId}/privacyConsents/{privacyConsentId} to retrieve a specific
 * consent action by identifier.
 *
 * Error handling: Deny access if the userId does not match the authenticated
 * subject. Validate pagination bounds and filter formats; provide clear
 * messages when constraints are violated.
 *
 * @param props.connection
 * @param props.userId Owner user’s ID whose privacy consents are being listed
 * @param props.body Search, filter, and pagination parameters for listing
 *   privacy consents
 * @path /todoApp/todoUser/users/:userId/privacyConsents
 * @accessor api.functional.todoApp.todoUser.users.privacyConsents.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Owner user’s ID whose privacy consents are being listed */
    userId: string & tags.Format<"uuid">;

    /**
     * Search, filter, and pagination parameters for listing privacy
     * consents
     */
    body: ITodoAppPrivacyConsent.IRequest;
  };
  export type Body = ITodoAppPrivacyConsent.IRequest;
  export type Response = IPageITodoAppPrivacyConsent;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/todoUser/users/:userId/privacyConsents",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/privacyConsents`;
  export const random = (): IPageITodoAppPrivacyConsent =>
    typia.random<IPageITodoAppPrivacyConsent>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific privacy consent by ID (todo_app_privacy_consents).
 *
 * Return a single privacy consent record from todo_app_privacy_consents
 * matching privacyConsentId that belongs to the account identified by userId.
 * The consent record contains business fields like purpose_code, purpose_name,
 * granted, granted_at, optional revoked_at and expires_at, policy_version, and
 * optional source, ip, and user_agent for traceability. Ownership is enforced
 * via todo_app_user_id; temporal fields (created_at/updated_at) support
 * auditing.
 *
 * Security and permissions: Only the authenticated owner with role todoUser may
 * access this resource, and the path userId must match the authenticated
 * subject. The implementation must also verify ownership: the consent record’s
 * todo_app_user_id equals userId. Requests for resources not owned by the
 * caller must be denied without revealing existence.
 *
 * Behavior and validation: If the record is not found or does not belong to the
 * specified user, return a not-found style response without disclosing
 * sensitive details. This endpoint is read-only and returns the stored consent
 * event as-is, reflecting the append-only design for consent history.
 *
 * Related operations: Use PATCH /users/{userId}/privacyConsents to search a
 * user’s consent history. Use POST /users/{userId}/privacyConsents to append a
 * new consent decision event.
 *
 * Error handling: Handle invalid UUID formats for either path parameter with
 * appropriate validation messages. Protect against enumeration by applying
 * ownership checks before returning data.
 *
 * @param props.connection
 * @param props.userId Owner user’s ID to which the consent must belong
 * @param props.privacyConsentId Target privacy consent record’s ID
 * @path /todoApp/todoUser/users/:userId/privacyConsents/:privacyConsentId
 * @accessor api.functional.todoApp.todoUser.users.privacyConsents.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Owner user’s ID to which the consent must belong */
    userId: string & tags.Format<"uuid">;

    /** Target privacy consent record’s ID */
    privacyConsentId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppPrivacyConsent;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/todoUser/users/:userId/privacyConsents/:privacyConsentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/privacyConsents/${encodeURIComponent(props.privacyConsentId ?? "null")}`;
  export const random = (): ITodoAppPrivacyConsent =>
    typia.random<ITodoAppPrivacyConsent>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("privacyConsentId")(() =>
        typia.assert(props.privacyConsentId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
