import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppEmailVerification } from "../../../../../structures/ITodoAppEmailVerification";
import { IPageITodoAppEmailVerification } from "../../../../../structures/IPageITodoAppEmailVerification";

/**
 * Search email verifications (todo_app_email_verifications) for a user with
 * pagination and filters.
 *
 * List and filter email verification records associated with a user account.
 * The Prisma model todo_app_email_verifications stores id, todo_app_user_id (FK
 * to todo_app_users.id), token and token_hash, target_email, sent_at,
 * expires_at, optional consumed_at, failure_count, optional consumed_by_ip,
 * created_at, updated_at, and a deleted_at marker. These records support
 * account activation and email-change verification flows; for security,
 * responses and logs must avoid exposing raw token secrets.
 *
 * Security and permissions: Only the authenticated owner should view their own
 * verification records. Enforce that the caller corresponds to {userId}.
 * Administrative access is not required during normal operations. Apply rate
 * limiting to mitigate probing.
 *
 * Filtering and sorting: Typical filters include time windows (sent_at,
 * expires_at), consumption state (consumed_at presence), and failure_count
 * ranges. Default sorting may be by sent_at or created_at in descending order.
 * Records with a deletion marker (deleted_at set) are generally excluded from
 * ordinary results.
 *
 * Behavior and errors: Request body (ITodoAppEmailVerification.IRequest)
 * supplies pagination and filter parameters; the response is a paginated
 * summary list. Common errors include invalid UUID format for {userId} and
 * insufficient authorization when attempting to access another user’s data.
 *
 * @param props.connection
 * @param props.userId Owner user identifier (todo_app_users.id)
 * @param props.body Search criteria and pagination for email verifications
 * @path /todoApp/todoUser/users/:userId/emailVerifications
 * @accessor api.functional.todoApp.todoUser.users.emailVerifications.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Owner user identifier (todo_app_users.id) */
    userId: string & tags.Format<"uuid">;

    /** Search criteria and pagination for email verifications */
    body: ITodoAppEmailVerification.IRequest;
  };
  export type Body = ITodoAppEmailVerification.IRequest;
  export type Response = IPageITodoAppEmailVerification.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/todoUser/users/:userId/emailVerifications",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/emailVerifications`;
  export const random = (): IPageITodoAppEmailVerification.ISummary =>
    typia.random<IPageITodoAppEmailVerification.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific email verification (todo_app_email_verifications) for a user.
 *
 * Fetch a single email verification token record associated with the specified
 * user. The underlying Prisma model todo_app_email_verifications includes
 * fields: id (UUID), todo_app_user_id (FK to todo_app_users.id), token
 * (deprecated in comments), token_hash (preferred for lookups), target_email,
 * sent_at, expires_at, consumed_at, failure_count, consumed_by_ip, created_at,
 * updated_at, and deleted_at. In accordance with the schema comments,
 * implementations should avoid exposing sensitive token values and rely on
 * token_hash for security-sensitive workflows; client responses should
 * prioritize metadata such as target_email and lifecycle timestamps.
 *
 * Security and access control: Only the owner (todoUser) may retrieve their own
 * record. The provider must verify that the path userId matches the
 * authenticated principal and that the requested emailVerificationId is owned
 * by that user (todo_app_email_verifications.todo_app_user_id). Requests from
 * other users must be denied without revealing resource existence.
 *
 * Entity relations and validation: The todo_app_email_verifications record
 * references todo_app_users. This read-only operation does not perform any
 * modifications. It should return records that still exist and are not
 * considered removed (for typical queries, treat rows with a non-null
 * deleted_at as removed from normal access). If the specified id does not exist
 * for the owner, return a not-found response pattern.
 *
 * Related operations: Account lifecycle endpoints (e.g., registration and
 * verification confirmation triggers) are separate write processes and are not
 * covered here. This operation is complementary to user security views and
 * audit diagnostics where applicable.
 *
 * @param props.connection
 * @param props.userId Owner user’s ID (UUID) of the email verification record
 * @param props.emailVerificationId Email verification record ID (UUID) to
 *   retrieve
 * @path /todoApp/todoUser/users/:userId/emailVerifications/:emailVerificationId
 * @accessor api.functional.todoApp.todoUser.users.emailVerifications.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Owner user’s ID (UUID) of the email verification record */
    userId: string & tags.Format<"uuid">;

    /** Email verification record ID (UUID) to retrieve */
    emailVerificationId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppEmailVerification;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/todoUser/users/:userId/emailVerifications/:emailVerificationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/emailVerifications/${encodeURIComponent(props.emailVerificationId ?? "null")}`;
  export const random = (): ITodoAppEmailVerification =>
    typia.random<ITodoAppEmailVerification>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("emailVerificationId")(() =>
        typia.assert(props.emailVerificationId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
