import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppPasswordReset } from "../../../../../structures/ITodoAppPasswordReset";
import { IPageITodoAppPasswordReset } from "../../../../../structures/IPageITodoAppPasswordReset";

/**
 * List/search password resets (todo_app_password_resets) for a user.
 *
 * Return a paginated list of password reset records that belong to the
 * specified user. The underlying Prisma model todo_app_password_resets
 * includes: id (UUID), todo_app_user_id (nullable FK to todo_app_users.id for
 * privacy-preserving requests), email, token (deprecated in comments),
 * token_hash (preferred), requested_at, expires_at, consumed_at,
 * requested_by_ip, created_at, updated_at, and deleted_at. In alignment with
 * the schema comments, implementations should avoid exposing sensitive token
 * values and rely on hashed representations server-side; list responses should
 * present non-sensitive metadata such as email, timestamps, and status derived
 * from consumed_at/expired comparisons.
 *
 * Security and permissions: Access is restricted to the owner (todoUser). The
 * provider must ensure the path userId corresponds to the authenticated user
 * and filter the list to entries where
 * todo_app_password_resets.todo_app_user_id equals that userId when present,
 * and where appropriate align on privacy behavior for email-only requests.
 * Requests from other accounts must be denied without revealing whether records
 * exist.
 *
 * Pagination and filtering: The request body (ITodoAppPasswordReset.IRequest)
 * should support common list behaviors noted in business
 * requirements—pagination (default page size often 20 within 1–100 range),
 * sorting by requested_at or expires_at, and optional search over non-sensitive
 * fields (e.g., email domain). Exclude rows considered removed from normal
 * access (records where deleted_at is not null). Handle empty result sets
 * gracefully.
 *
 * @param props.connection
 * @param props.userId Target user’s ID (UUID) whose password reset records are
 *   queried
 * @param props.body Filtering, sorting, and pagination criteria for listing
 *   password reset records
 * @path /todoApp/todoUser/users/:userId/passwordResets
 * @accessor api.functional.todoApp.todoUser.users.passwordResets.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Target user’s ID (UUID) whose password reset records are queried */
    userId: string & tags.Format<"uuid">;

    /**
     * Filtering, sorting, and pagination criteria for listing password
     * reset records
     */
    body: ITodoAppPasswordReset.IRequest;
  };
  export type Body = ITodoAppPasswordReset.IRequest;
  export type Response = IPageITodoAppPasswordReset.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/todoUser/users/:userId/passwordResets",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/passwordResets`;
  export const random = (): IPageITodoAppPasswordReset.ISummary =>
    typia.random<IPageITodoAppPasswordReset.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific password reset (todo_app_password_resets) for a user.
 *
 * Fetch detailed metadata for one password reset record owned by the specified
 * user. In Prisma, todo_app_password_resets defines: id (UUID), optional
 * todo_app_user_id (FK), email, token (deprecated), token_hash (preferred),
 * requested_at, expires_at, consumed_at, requested_by_ip, created_at,
 * updated_at, and deleted_at. Consistent with the schema’s guidance,
 * implementations must avoid exposing raw token values; responses should focus
 * on safe metadata such as email, timestamps, and lifecycle status inferred
 * from consumed_at and expiration.
 *
 * Security model: Only the owner (todoUser) may access their record. The
 * provider must verify ownership by checking that the record either references
 * the user via todo_app_user_id or otherwise corresponds to an allowed
 * privacy-preserving access pattern aligned with policy. If the record is not
 * owned by the user, the service must deny access without acknowledging
 * existence.
 *
 * Behavior and errors: This is a read-only retrieval. Records treated as
 * removed from normal access (deleted_at set) should not be returned in
 * standard flows. If no matching record is found for the owner, return a
 * not-found response pattern.
 *
 * @param props.connection
 * @param props.userId Owner user’s ID (UUID)
 * @param props.passwordResetId Password reset record ID (UUID) to retrieve
 * @path /todoApp/todoUser/users/:userId/passwordResets/:passwordResetId
 * @accessor api.functional.todoApp.todoUser.users.passwordResets.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Owner user’s ID (UUID) */
    userId: string & tags.Format<"uuid">;

    /** Password reset record ID (UUID) to retrieve */
    passwordResetId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppPasswordReset;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/todoUser/users/:userId/passwordResets/:passwordResetId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/todoUser/users/${encodeURIComponent(props.userId ?? "null")}/passwordResets/${encodeURIComponent(props.passwordResetId ?? "null")}`;
  export const random = (): ITodoAppPasswordReset =>
    typia.random<ITodoAppPasswordReset>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("passwordResetId")(() =>
        typia.assert(props.passwordResetId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
