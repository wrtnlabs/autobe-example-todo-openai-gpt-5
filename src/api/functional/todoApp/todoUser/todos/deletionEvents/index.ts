import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppTodoDeletionEvent } from "../../../../../structures/ITodoAppTodoDeletionEvent";
import { IPageITodoAppTodoDeletionEvent } from "../../../../../structures/IPageITodoAppTodoDeletionEvent";

/**
 * List deletion audit entries for a Todo from todo_app_todo_deletion_events.
 *
 * Purpose and overview: Lists deletion audit records tied to a Todo using the
 * todo_app_todo_deletion_events model. Each record includes a link to the
 * deleted Todo (nullable for preservation), the deleting user (nullable), a
 * human-readable reason, and occurred_at timestamps. This endpoint provides
 * transparency for deletion workflows and complements the soft deletion
 * behavior supported by todo_app_todos.deleted_at.
 *
 * Security and authorization: Only the owner (role todoUser) may list deletion
 * events for their Todo. Providers must validate that the Todo identified by
 * todoId belongs to the authenticated user. Unauthorized access attempts must
 * be denied without revealing whether the resource exists.
 *
 * DB relationships and behavior: Deletion events relate to todo_app_todos and
 * todo_app_users with onDelete behaviors chosen to preserve history (nullable
 * FKs). Providers should constrain results to events for the specified Todo,
 * apply pagination and sorting, and optionally expose keyword filtering on
 * reason leveraging the available trigram index.
 *
 * Validation and errors: Reject requests with invalid UUIDs or when the
 * specified Todo is not found/owned by the caller. This endpoint is read-only
 * and does not create, change, or remove deletion events. Related operations
 * include DELETE /todoApp/todoUser/todos/{todoId} to perform the deletion and
 * PATCH /todoApp/todoUser/todos/{todoId}/activities to review broader activity
 * history.
 *
 * @param props.connection
 * @param props.todoId Identifier of the parent todo
 * @param props.body Search, filter, sort, and pagination parameters for
 *   deletion events
 * @path /todoApp/todoUser/todos/:todoId/deletionEvents
 * @accessor api.functional.todoApp.todoUser.todos.deletionEvents.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Identifier of the parent todo */
    todoId: string & tags.Format<"uuid">;

    /** Search, filter, sort, and pagination parameters for deletion events */
    body: ITodoAppTodoDeletionEvent.IRequest;
  };
  export type Body = ITodoAppTodoDeletionEvent.IRequest;
  export type Response = IPageITodoAppTodoDeletionEvent.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/todoUser/todos/:todoId/deletionEvents",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/todoUser/todos/${encodeURIComponent(props.todoId ?? "null")}/deletionEvents`;
  export const random = (): IPageITodoAppTodoDeletionEvent.ISummary =>
    typia.random<IPageITodoAppTodoDeletionEvent.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific Todo deletion audit entry (todo_app_todo_deletion_events) by
 * identifiers.
 *
 * This endpoint returns a single deletion audit entry for a Todo. The
 * underlying storage is the Prisma model todo_app_todo_deletion_events, which
 * records point‑in‑time deletion audit entries for todos, including who deleted
 * the todo and when, with an optional human‑readable reason. The model includes
 * columns like id (primary key), todo_app_todo_id (nullable FK to
 * todo_app_todos), todo_app_user_id (nullable FK to todo_app_users as the
 * deleter), reason (optional text), occurred_at (business event time), and
 * created_at/updated_at timestamps. It preserves audit history by allowing the
 * foreign keys to be nullable so that records remain valid even if parent
 * entities are purged. A logical deletion timestamp exists for rare
 * administrative redactions under policy, and such records must be excluded
 * from normal retrievals.
 *
 * Security and permissions must ensure that only the owner of the parent todo
 * can access the associated deletion event. Provider logic should verify that
 * the authenticated identity corresponds to todo_app_todos.todo_app_user_id for
 * the given todoId, and that the deletion event’s todo_app_todo_id matches the
 * provided todoId. If either check fails, the provider should behave as if the
 * resource is not available to avoid leaking information about other users’
 * data.
 *
 * The operation is read‑only; it does not create or alter any audit records. It
 * is related to other read operations such as retrieving a Todo detail or
 * listing all deletion events under a Todo (if provided elsewhere). Expected
 * behaviors include returning a single audit record when both identifiers match
 * and the user is authorized, or an appropriate not‑found/authorization failure
 * outcome when identifiers do not correspond or access is denied. Records with
 * a logical deletion timestamp should be filtered out from standard responses.
 *
 * @param props.connection
 * @param props.todoId Identifier of the parent Todo to which the deletion event
 *   belongs
 * @param props.deletionEventId Identifier of the target deletion event entry
 * @path /todoApp/todoUser/todos/:todoId/deletionEvents/:deletionEventId
 * @accessor api.functional.todoApp.todoUser.todos.deletionEvents.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the parent Todo to which the deletion event belongs */
    todoId: string & tags.Format<"uuid">;

    /** Identifier of the target deletion event entry */
    deletionEventId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppTodoDeletionEvent;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/todoUser/todos/:todoId/deletionEvents/:deletionEventId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/todoUser/todos/${encodeURIComponent(props.todoId ?? "null")}/deletionEvents/${encodeURIComponent(props.deletionEventId ?? "null")}`;
  export const random = (): ITodoAppTodoDeletionEvent =>
    typia.random<ITodoAppTodoDeletionEvent>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
      assert.param("deletionEventId")(() =>
        typia.assert(props.deletionEventId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
