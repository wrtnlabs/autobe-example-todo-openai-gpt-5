import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppTodo } from "../../../../structures/ITodoAppTodo";
import { IPageITodoAppTodo } from "../../../../structures/IPageITodoAppTodo";
export * as activities from "./activities/index";
export * as deletionEvents from "./deletionEvents/index";

/**
 * Create a new Todo (todo_app_todos) owned by the authenticated user.
 *
 * Create a Todo in todo_app_todos for the caller as owner. The Prisma schema
 * defines: id (UUID), todo_app_user_id (owner), title (required short text;
 * business rule 1–120 characters after trimming), description (optional longer
 * text, commonly limited by policy to 1000–2000 chars), due_at (optional
 * timestamptz in the owner’s timezone), status (expected 'open' or
 * 'completed'), completed_at (null on creation), created_at, updated_at, and a
 * deleted_at field used by the system to exclude records from normal views. On
 * successful creation, implementation sets status to 'open', records
 * timestamps, and associates ownership via todo_app_user_id.
 *
 * Security and validation: Only authenticated users can create Todos; the
 * service assigns todo_app_user_id from the caller’s identity and validates
 * inputs. The title must be non-empty after trimming and within the allowed
 * length. Description and due_at are optional with policy-based constraints;
 * due_at must be a valid date-time. The result returns the full ITodoAppTodo to
 * support immediate UI rendering. System artifacts like activity logs and
 * business events may be recorded automatically by the service as side effects
 * and are not part of the request.
 *
 * Related operations: After creation, clients generally call GET
 * /todoApp/todoUser/todos/{todoId} for detail, PUT
 * /todoApp/todoUser/todos/{todoId} to update fields or toggle completion, and
 * PATCH /todoApp/todoUser/todos for list/search views.
 *
 * @param props.connection
 * @param props.body Fields required to create a Todo (title required; optional
 *   description and due_at)
 * @path /todoApp/todoUser/todos
 * @accessor api.functional.todoApp.todoUser.todos.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Fields required to create a Todo (title required; optional
     * description and due_at)
     */
    body: ITodoAppTodo.ICreate;
  };
  export type Body = ITodoAppTodo.ICreate;
  export type Response = ITodoAppTodo;

  export const METADATA = {
    method: "POST",
    path: "/todoApp/todoUser/todos",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/todoUser/todos";
  export const random = (): ITodoAppTodo => typia.random<ITodoAppTodo>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/search Todos (todo_app_todos) with pagination, filters, and sorting for
 * the authenticated owner.
 *
 * Retrieve a filtered and paginated list of the caller’s own Todo items from
 * the todo_app_todos table. According to the Prisma schema, todo_app_todos
 * stores: id (UUID), todo_app_user_id (owner reference to todo_app_users),
 * title (required), description (optional), due_at (optional timestamptz
 * interpreted in the owner’s timezone), status (expected business values 'open'
 * or 'completed'), completed_at (set when completed), created_at, updated_at,
 * and a deleted_at timestamp used by the system to exclude records from normal
 * queries. Title is described as a required short text (business rule 1–120
 * characters after trimming), while description can be longer (typically up to
 * 1000–2000 chars by policy). The list view MUST scope results to the
 * authenticated user via todo_app_user_id and exclude records where deleted_at
 * is not null.
 *
 * Security and permissions: access is restricted to authenticated end users
 * acting as owners of their own Todos. The operation must enforce owner
 * isolation using the relationship from todo_app_todos.todo_app_user_id to
 * todo_app_users.id. Administrative or system-generated tables (e.g., activity
 * trails, business events, counters) are not exposed or modified by this
 * endpoint. Rate-limiting and throttling may be applied according to governance
 * policies but are out of scope of this API contract.
 *
 * Filtering, search, and sorting: the request body ITodoAppTodo.IRequest
 * conveys pagination (page number and size within 1–100), status filters
 * (open/completed/all), optional due-window filters (e.g., overdue, dueToday,
 * future), and a keyword query applied case-insensitively to title and
 * description. By default, results sort by created_at descending (newest
 * first). When sorting by due_at ascending, items without due_at should appear
 * after those with a due date; ties may be resolved by created_at descending.
 * The response is a paginated container IPageITodoAppTodo.ISummary
 * encapsulating list data and pagination metadata suitable for UI list
 * rendering.
 *
 * Related operations: use GET /todoApp/todoUser/todos to create via POST
 * /todoApp/todoUser/todos, GET /todoApp/todoUser/todos/{todoId} to retrieve a
 * single Todo’s full details, and PUT /todoApp/todoUser/todos/{todoId} to
 * update fields or toggle completion. System-generated records like
 * todo_app_todo_activities or todo_app_business_events are written by service
 * logic as side effects and do not have manual write endpoints in this set.
 *
 * @param props.connection
 * @param props.body Search, filtering, and pagination criteria for listing the
 *   caller’s Todos
 * @path /todoApp/todoUser/todos
 * @accessor api.functional.todoApp.todoUser.todos.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filtering, and pagination criteria for listing the caller’s
     * Todos
     */
    body: ITodoAppTodo.IRequest;
  };
  export type Body = ITodoAppTodo.IRequest;
  export type Response = IPageITodoAppTodo.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/todoUser/todos",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/todoUser/todos";
  export const random = (): IPageITodoAppTodo.ISummary =>
    typia.random<IPageITodoAppTodo.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single Todo (todo_app_todos) by id for the authenticated owner.
 *
 * Retrieve a single Todo from todo_app_todos by its id, ensuring it belongs to
 * the requesting user. The Prisma model defines fields including id (UUID),
 * todo_app_user_id (FK to todo_app_users establishing ownership), title
 * (required), description (optional), due_at (optional timestamptz), status
 * (business-level 'open' or 'completed'), completed_at (set when completed,
 * cleared when reopened), created_at, updated_at, and deleted_at (records with
 * deleted_at not null are excluded from normal views). This operation presents
 * the detailed entity ITodoAppTodo for display or editing.
 *
 * Security and access control: Only authenticated users may call this endpoint,
 * and access is limited to records where todo_app_todos.todo_app_user_id equals
 * the caller’s user id. If the target id does not belong to the caller or
 * refers to a record considered deleted in normal flows, the service should
 * deny access without revealing resource existence. Administrative and system
 * tables (activities, events, counters) are out of scope for direct
 * manipulation.
 *
 * Error handling and related operations: If the identifier is malformed (not a
 * UUID) or the record is not accessible to the caller, the service returns an
 * appropriate error. Clients typically use this endpoint together with POST
 * /todoApp/todoUser/todos (creation), PUT /todoApp/todoUser/todos/{todoId}
 * (updates), and PATCH /todoApp/todoUser/todos (lists with filters) to complete
 * the CRUD workflow.
 *
 * @param props.connection
 * @param props.todoId Identifier of the target Todo (UUID)
 * @path /todoApp/todoUser/todos/:todoId
 * @accessor api.functional.todoApp.todoUser.todos.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the target Todo (UUID) */
    todoId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppTodo;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/todoUser/todos/:todoId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/todoUser/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): ITodoAppTodo => typia.random<ITodoAppTodo>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a Todo (todo_app_todos) by id for the authenticated owner.
 *
 * Modify a Todo identified by id in todo_app_todos. The Prisma schema includes
 * fields id (UUID), todo_app_user_id (owner), title, description, due_at,
 * status, completed_at, created_at, updated_at, and deleted_at. Valid updates
 * include changing title (respecting business rule 1–120 trimmed characters),
 * description (policy length range), and due_at (valid date-time in the owner’s
 * timezone). Status transitions to 'completed' should set completed_at;
 * transitions back to 'open' should clear completed_at. The service maintains
 * updated_at on successful updates.
 *
 * Security and permissions: Only the owner may update their Todo; ownership is
 * enforced via todo_app_user_id against the caller identity. If the resource is
 * not owned by the caller or is considered deleted from normal flows, the
 * request must be denied without revealing existence. System tables that
 * capture activities or events are updated by the service automatically and are
 * not directly manipulated through this API.
 *
 * Interoperation and errors: Use GET /todoApp/todoUser/todos/{todoId} to fetch
 * the current state before or after an update and PATCH /todoApp/todoUser/todos
 * to retrieve lists. Validation failures (e.g., empty or overlong title,
 * invalid due_at) result in field-specific errors. On success, the endpoint
 * returns the updated ITodoAppTodo.
 *
 * @param props.connection
 * @param props.todoId Identifier of the target Todo (UUID)
 * @param props.body Fields to update on the Todo, including optional status
 *   transitions
 * @path /todoApp/todoUser/todos/:todoId
 * @accessor api.functional.todoApp.todoUser.todos.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Identifier of the target Todo (UUID) */
    todoId: string & tags.Format<"uuid">;

    /** Fields to update on the Todo, including optional status transitions */
    body: ITodoAppTodo.IUpdate;
  };
  export type Body = ITodoAppTodo.IUpdate;
  export type Response = ITodoAppTodo;

  export const METADATA = {
    method: "PUT",
    path: "/todoApp/todoUser/todos/:todoId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/todoUser/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): ITodoAppTodo => typia.random<ITodoAppTodo>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a Todo by ID in todo_app_todos using soft deletion and record audit
 * entries.
 *
 * Delete a single Todo belonging to the caller. The underlying Prisma model is
 * todo_app_todos, which stores ownership (todo_app_user_id), core fields
 * (title, description, due_at, status), and lifecycle timestamps (created_at,
 * updated_at, completed_at). The model includes a deleted_at column that, when
 * set, excludes the record from normal listings. This endpoint sets deleted_at
 * to the current time to implement the schema-supported deletion behavior,
 * preserving privacy and enabling recovery windows and auditability described
 * in related tables.
 *
 * Security and authorization: Only a user with role todoUser acting on their
 * own record may delete it. The service must confirm that the path todoId
 * resolves to a row where todo_app_todos.todo_app_user_id equals the
 * authenticated user’s id. If not, deny without revealing whether the Todo
 * exists, consistent with access-control requirements.
 *
 * Relationships and audit trail: Related append-only audit models include
 * todo_app_todo_deletion_events (records occurred_at, optional reason, and
 * links to the todo and deleter) and todo_app_todo_activities (records
 * activity_type such as 'delete', details, changed_fields, and timestamps).
 * Providers should create these audit entries as part of the deletion workflow
 * to preserve a historical trail. Optionally, providers may also emit
 * todo_app_business_events for analytics using a suitable event type.
 *
 * Validation and behavior: If the Todo has already been marked deleted
 * (deleted_at not null), the operation should be treated as idempotent—perform
 * no additional state changes and return success without error. If the todoId
 * is not a valid UUID or cannot be resolved (with ownership), respond with a
 * suitable error. No request body is required, and no response body is returned
 * upon success. This operation performs a soft deletion as indicated by the
 * presence of the deleted_at column in the Prisma schema, not a permanent
 * physical removal.
 *
 * Related operations: Use PATCH /todoApp/todoUser/todos/{todoId}/activities to
 * review the activity history recorded in todo_app_todo_activities and PATCH
 * /todoApp/todoUser/todos/{todoId}/deletionEvents to inspect deletion audit
 * records in todo_app_todo_deletion_events.
 *
 * @param props.connection
 * @param props.todoId Unique identifier of the target todo
 * @path /todoApp/todoUser/todos/:todoId
 * @accessor api.functional.todoApp.todoUser.todos.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the target todo */
    todoId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoApp/todoUser/todos/:todoId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/todoUser/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
