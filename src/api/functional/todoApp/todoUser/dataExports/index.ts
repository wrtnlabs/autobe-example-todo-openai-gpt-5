import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppDataExport } from "../../../../structures/ITodoAppDataExport";
import { IPageITodoAppDataExport } from "../../../../structures/IPageITodoAppDataExport";

/**
 * List/search personal data export jobs (todo_app_data_exports) for the
 * authenticated user.
 *
 * This operation returns a filtered and paginated list of personal data export
 * jobs for the signed-in user from the todo_app_data_exports table. The table
 * stores export workflow metadata including status, export_format,
 * download_uri, file_size_bytes, checksum, status_message, completed_at,
 * expires_at, request_ip, request_user_agent, created_at, updated_at, and a
 * logical deletion timestamp used for retention workflows. The owner is linked
 * through todo_app_user_id referencing todo_app_users.id. Results must be
 * restricted to the caller’s own records.
 *
 * Security and permissions: access is restricted to users authenticated as the
 * owner (role: todoUser). The provider must filter by
 * todo_app_data_exports.todo_app_user_id = auth.userId. Administrators may
 * audit exports across users via separate governance endpoints not covered
 * here; this endpoint is strictly user-scoped.
 *
 * Filtering and search: clients can filter by status, export_format, date
 * ranges on created_at, completed_at, and expires_at, and perform free-text
 * search over status_message when supported. Sorting supports created_at,
 * completed_at, and expires_at fields with created_at descending as the
 * default. Pagination follows the user’s preferences (e.g., page_size from
 * todo_app_user_preferences) or explicit request values.
 *
 * Validation and behavior: only records with non-null download_uri should be
 * considered ready for download; clients should honor expires_at to avoid
 * presenting stale links. The status field reflects the job lifecycle (e.g.,
 * requested, processing, completed, failed, expired) as described in the Prisma
 * comments. Records marked for lifecycle retention via the deleted timestamp
 * should be excluded from normal listings by implementation policy.
 *
 * Related operations: use GET /todoApp/todoUser/dataExports/{dataExportId} for
 * details about a specific export job, including its download_uri and
 * timestamps. Creating export jobs is typically initiated by a separate
 * creation endpoint or workflow; this route is for listing and searching
 * existing jobs.
 *
 * @param props.connection
 * @param props.body Search, filter, sort, and paginate parameters for listing
 *   data export jobs
 * @path /todoApp/todoUser/dataExports
 * @accessor api.functional.todoApp.todoUser.dataExports.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filter, sort, and paginate parameters for listing data export
     * jobs
     */
    body: ITodoAppDataExport.IRequest;
  };
  export type Body = ITodoAppDataExport.IRequest;
  export type Response = IPageITodoAppDataExport.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/todoUser/dataExports",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/todoUser/dataExports";
  export const random = (): IPageITodoAppDataExport.ISummary =>
    typia.random<IPageITodoAppDataExport.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific data export job (todo_app_data_exports) by ID for the
 * authenticated user.
 *
 * This operation fetches a single data export job from todo_app_data_exports by
 * its primary key id. The model captures the export lifecycle through status
 * and timestamps (created_at, updated_at, completed_at, expires_at) and
 * provides download_uri and file_size_bytes when available. Ownership is
 * enforced via todo_app_user_id referencing todo_app_users.id; implementations
 * must ensure the requested record belongs to the authenticated user.
 *
 * Security: only authenticated users in the todoUser role can access this
 * endpoint and only for their own records. Attempting to access another user’s
 * export must result in a generic denial without revealing existence.
 * Administrators should use separate governance endpoints for cross-user
 * audits.
 *
 * Behavior and validations: if the export is not completed or the expires_at
 * has passed, clients should avoid presenting an invalid download_uri. When
 * status is failed, status_message may include human-readable context. The
 * presence of a logical deletion timestamp indicates records hidden by
 * retention policies and should not be served by this endpoint. The response
 * includes all relevant fields necessary for the user to verify export
 * readiness and audit their request.
 *
 * Related operations: to explore multiple exports with filters and pagination,
 * use PATCH /todoApp/todoUser/dataExports. Export job creation is handled
 * elsewhere in the privacy workflow.
 *
 * @param props.connection
 * @param props.dataExportId Identifier of the data export job (UUID)
 * @path /todoApp/todoUser/dataExports/:dataExportId
 * @accessor api.functional.todoApp.todoUser.dataExports.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the data export job (UUID) */
    dataExportId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppDataExport;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/todoUser/dataExports/:dataExportId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/todoUser/dataExports/${encodeURIComponent(props.dataExportId ?? "null")}`;
  export const random = (): ITodoAppDataExport =>
    typia.random<ITodoAppDataExport>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("dataExportId")(() => typia.assert(props.dataExportId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
