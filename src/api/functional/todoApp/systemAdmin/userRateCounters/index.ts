import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppUserRateCounter } from "../../../../structures/ITodoAppUserRateCounter";
import { IPageITodoAppUserRateCounter } from "../../../../structures/IPageITodoAppUserRateCounter";

/**
 * Search user rate counters (todo_app_user_rate_counters).
 *
 * This endpoint provides a read/search interface over user rate limit counters
 * stored in todo_app_user_rate_counters. The schema defines references to
 * todo_app_rate_limits (rateLimit relation) and todo_app_users (user relation).
 * Each record captures the counting window (window_started_at/window_ends_at),
 * the current count, last_action_at, and an optional blocked_until timestamp
 * indicating a cooldown in effect. Administrators use this view to investigate
 * throttling behavior, analyze abuse patterns, and tune policies.
 *
 * Security and permissions: Because counters span multiple users and reveal
 * operational throttling information, access is restricted to administrative
 * personnel. The authorization role systemAdmin aligns with the governance role
 * defined by the role-assignment models and business requirements.
 * Implementations should default to excluding records marked for retention via
 * deleted_at unless explicitly requested by policy.
 *
 * Entity relationships and query shape: Clients may filter by
 * todo_app_rate_limit_id (linking to todo_app_rate_limits), todo_app_user_id
 * (linking to todo_app_users), window date ranges, and whether blocked_until is
 * present or extends beyond the current time. Sorting commonly uses
 * window_started_at descending and then last_action_at. The response returns
 * the ITodoAppUserRateCounter entities wrapped in a paginated structure.
 *
 * Validation and behavior: The IRequest payload may include pagination
 * (page/size), sorting keys (e.g., window_started_at desc), and filters (policy
 * id, user id, window overlap, blocked state). This is a read-only query
 * operation; it does not mutate counters or policies. For policy definitions
 * themselves, refer to todo_app_rate_limits in administrative configuration
 * surfaces.
 *
 * Related operations: To inspect a single counter window, use GET
 * /userRateCounters/{userRateCounterId}. To filter counters for a specific
 * policy, use PATCH /rateLimits/{rateLimitId}/userRateCounters.
 *
 * Errors and edge cases: Invalid identifiers (non-UUIDs) should return
 * validation errors. Lack of authorization should produce an access denial.
 * Empty result sets return an empty page with pagination metadata.
 *
 * @param props.connection
 * @param props.body Search, filter, and pagination criteria for user rate
 *   counter windows
 * @path /todoApp/systemAdmin/userRateCounters
 * @accessor api.functional.todoApp.systemAdmin.userRateCounters.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filter, and pagination criteria for user rate counter windows */
    body: ITodoAppUserRateCounter.IRequest;
  };
  export type Body = ITodoAppUserRateCounter.IRequest;
  export type Response = IPageITodoAppUserRateCounter;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/userRateCounters",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/systemAdmin/userRateCounters";
  export const random = (): IPageITodoAppUserRateCounter =>
    typia.random<IPageITodoAppUserRateCounter>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get user rate counter by ID (todo_app_user_rate_counters).
 *
 * Fetch a single counter record from todo_app_user_rate_counters by ID for
 * precise inspection. The schema provides fields window_started_at,
 * window_ends_at, count, last_action_at, and blocked_until, with relations to
 * todo_app_rate_limits and todo_app_users. This read operation allows
 * administrators to verify if a user is currently blocked under a policy,
 * inspect counts within a window, and confirm the exact time boundaries used
 * for enforcement.
 *
 * Security considerations: The information is sensitive operational metadata
 * across users; therefore, access is restricted to the systemAdmin role.
 * Results omit records that are flagged for retention via deleted_at unless
 * governance tooling explicitly requests them.
 *
 * Database relationships: The counter relates to a single rate limit policy via
 * todo_app_rate_limit_id and to a single user via todo_app_user_id. Additional
 * indices on the table facilitate efficient lookups and time-window queries.
 * This endpoint returns a single ITodoAppUserRateCounter entity.
 *
 * Validation and error handling: The userRateCounterId path parameter must be a
 * valid UUID. Non-existent identifiers should return a not-found response.
 * Authorization failures return access denied. This is a read-only operation
 * with no side effects.
 *
 * @param props.connection
 * @param props.userRateCounterId Identifier of the user rate counter window to
 *   retrieve
 * @path /todoApp/systemAdmin/userRateCounters/:userRateCounterId
 * @accessor api.functional.todoApp.systemAdmin.userRateCounters.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the user rate counter window to retrieve */
    userRateCounterId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppUserRateCounter;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/userRateCounters/:userRateCounterId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/userRateCounters/${encodeURIComponent(props.userRateCounterId ?? "null")}`;
  export const random = (): ITodoAppUserRateCounter =>
    typia.random<ITodoAppUserRateCounter>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userRateCounterId")(() =>
        typia.assert(props.userRateCounterId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
