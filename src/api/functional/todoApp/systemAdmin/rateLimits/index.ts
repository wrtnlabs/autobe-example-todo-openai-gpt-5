import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppRateLimit } from "../../../../structures/ITodoAppRateLimit";
import { IPageITodoAppRateLimit } from "../../../../structures/IPageITodoAppRateLimit";
export * as userRateCounters from "./userRateCounters/index";
export * as ipRateCounters from "./ipRateCounters/index";

/**
 * Create a rate limit policy in todo_app_rate_limits.
 *
 * Insert a new throttling policy into todo_app_rate_limits. As described in the
 * schema comments, this table defines system-wide throttling policies managed
 * by administrators. Important fields include a unique code for safe
 * referencing, a human-readable name, optional description, scope (such as
 * "user", "ip", or "global"), category (such as "read", "write", or "auth"),
 * window_seconds, max_requests, optional burst_size, a sliding_window boolean,
 * and an enabled flag indicating whether the policy is enforced. Created
 * records carry created_at and updated_at timestamps for operational audit.
 *
 * Only authorized administrators should be permitted to create new policies.
 * Creation should validate uniqueness of code, acceptable ranges for
 * window_seconds and max_requests, and the general consistency of provided
 * fields. While the schema uses string types for scope and category,
 * implementations often validate these against known application categories.
 * The create DTO should include clear error messaging when constraints are
 * violated (e.g., duplicate code).
 *
 * Newly created policies may be used by enforcement mechanisms consulted by
 * todo_app_user_rate_counters and todo_app_ip_rate_counters. If the platform
 * caches policies, the provider logic should ensure appropriate cache refresh
 * or invalidation so that new limits take effect as intended. On success, this
 * endpoint returns the full ITodoAppRateLimit record for immediate confirmation
 * and display.
 *
 * @param props.connection
 * @param props.body New rate limit policy configuration to create
 * @path /todoApp/systemAdmin/rateLimits
 * @accessor api.functional.todoApp.systemAdmin.rateLimits.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** New rate limit policy configuration to create */
    body: ITodoAppRateLimit.ICreate;
  };
  export type Body = ITodoAppRateLimit.ICreate;
  export type Response = ITodoAppRateLimit;

  export const METADATA = {
    method: "POST",
    path: "/todoApp/systemAdmin/rateLimits",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/systemAdmin/rateLimits";
  export const random = (): ITodoAppRateLimit =>
    typia.random<ITodoAppRateLimit>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List and search rate limit policies from Prisma table todo_app_rate_limits.
 *
 * Retrieve a filtered, paginated list of rate limit policies from the
 * todo_app_rate_limits table. According to the Prisma schema comments, this
 * model defines system-wide throttling policy definitions that administrators
 * manage. Key columns include id (UUID primary key), code (unique business
 * identifier), name, description (optional), scope (such as "user", "ip", or
 * "global"), category (for action grouping such as "read", "write", or "auth"),
 * window_seconds (fixed window duration), max_requests, burst_size (optional),
 * sliding_window (boolean), and enabled (boolean). Timestamps (created_at,
 * updated_at) support administrative review.
 *
 * Access to this endpoint should be restricted to operational administrators
 * responsible for governance. The authorization model should ensure only users
 * with appropriate administrative role can list and inspect these policies.
 * Listings are intended for console pages and audit tools; ordinary end users
 * do not need visibility into these configurations.
 *
 * This operation integrates directly with the todo_app_rate_limits entity and
 * is related to enforcement counters stored in todo_app_user_rate_counters and
 * todo_app_ip_rate_counters, which reference rate limit policies to apply
 * per-subject throttling. While those counter tables are maintained by system
 * logic, administrators depend on this listing to verify which policies are
 * active and how they are configured.
 *
 * Validation and business logic include supporting common filters such as by
 * category, scope, enabled flag, and sliding_window, as well as range filters
 * on window_seconds and max_requests. Sorting typically supports created_at,
 * code, category, and scope. Full-text search can apply to name and description
 * as hinted by the schema's trigram indexes. Error handling should clarify
 * invalid sort keys, unknown filter values, or pagination bounds.
 *
 * @param props.connection
 * @param props.body Search criteria, pagination, and sorting parameters for
 *   listing rate limit policies
 * @path /todoApp/systemAdmin/rateLimits
 * @accessor api.functional.todoApp.systemAdmin.rateLimits.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, pagination, and sorting parameters for listing rate
     * limit policies
     */
    body: ITodoAppRateLimit.IRequest;
  };
  export type Body = ITodoAppRateLimit.IRequest;
  export type Response = IPageITodoAppRateLimit.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/rateLimits",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/systemAdmin/rateLimits";
  export const random = (): IPageITodoAppRateLimit.ISummary =>
    typia.random<IPageITodoAppRateLimit.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific rate limit policy (todo_app_rate_limits) by ID.
 *
 * Retrieve one rate limit policy from todo_app_rate_limits using its id (UUID).
 * Per the schema comments, this table stores system-wide throttling policy
 * definitions with fields like code (unique business identifier), name,
 * description, scope (e.g., "user", "ip", "global"), category (e.g., "read",
 * "write", "auth"), window_seconds, max_requests, burst_size (optional),
 * sliding_window, and enabled. Timestamps (created_at, updated_at) allow
 * administrators to audit when a policy was created or last changed.
 *
 * Only administrators charged with governance should access this endpoint. It
 * is intended for configuration consoles and operational tooling. The endpoint
 * returns detailed configuration suitable for editing or for correlating with
 * observed throttling behavior in related counter tables.
 *
 * This operation is directly related to todo_app_user_rate_counters and
 * todo_app_ip_rate_counters which reference policies for enforcement. When
 * investigating throttling outcomes, administrators typically use this GET
 * detail view after finding a policy in the list endpoint.
 *
 * Validation rules include ensuring the provided rateLimitId is a well-formed
 * UUID and that the referenced policy exists. If the identifier does not match
 * any record, the implementation should return a not-found response without
 * exposing internal details.
 *
 * @param props.connection
 * @param props.rateLimitId Unique identifier of the target rate limit policy
 * @path /todoApp/systemAdmin/rateLimits/:rateLimitId
 * @accessor api.functional.todoApp.systemAdmin.rateLimits.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the target rate limit policy */
    rateLimitId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppRateLimit;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/rateLimits/:rateLimitId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/rateLimits/${encodeURIComponent(props.rateLimitId ?? "null")}`;
  export const random = (): ITodoAppRateLimit =>
    typia.random<ITodoAppRateLimit>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("rateLimitId")(() => typia.assert(props.rateLimitId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a rate limit policy (todo_app_rate_limits) by ID.
 *
 * Modify a throttling policy stored in todo_app_rate_limits. The schema
 * describes this table as the canonical source for system-wide rate limit
 * configurations, including code (unique), name, description, scope (e.g.,
 * "user", "ip", "global"), category (e.g., "read", "write", "auth"),
 * window_seconds, max_requests, optional burst_size, sliding_window flag, and
 * enabled flag. Updating these fields allows administrators to tune throttling
 * behavior without touching enforcement counters directly.
 *
 * Access control must restrict this operation to administrators. Validation
 * should ensure the path parameter is a valid UUID, the target record exists,
 * and any changes respect uniqueness for code and reasonable bounds for numeric
 * fields like window_seconds and max_requests. Applications commonly validate
 * scope/category values against known sets even though they are stored as
 * strings in the schema comments.
 *
 * This endpoint complements the list, detail, and create operations. After
 * updates, downstream enforcement that references these configurations—such as
 * logic maintaining todo_app_user_rate_counters and
 * todo_app_ip_rate_counters—should observe the changed limits according to the
 * system's cache and propagation rules. The updated ITodoAppRateLimit object is
 * returned so operators can immediately verify the resulting configuration.
 *
 * @param props.connection
 * @param props.rateLimitId Unique identifier of the rate limit policy to update
 * @param props.body Partial or full updates for the rate limit policy
 * @path /todoApp/systemAdmin/rateLimits/:rateLimitId
 * @accessor api.functional.todoApp.systemAdmin.rateLimits.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the rate limit policy to update */
    rateLimitId: string & tags.Format<"uuid">;

    /** Partial or full updates for the rate limit policy */
    body: ITodoAppRateLimit.IUpdate;
  };
  export type Body = ITodoAppRateLimit.IUpdate;
  export type Response = ITodoAppRateLimit;

  export const METADATA = {
    method: "PUT",
    path: "/todoApp/systemAdmin/rateLimits/:rateLimitId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/systemAdmin/rateLimits/${encodeURIComponent(props.rateLimitId ?? "null")}`;
  export const random = (): ITodoAppRateLimit =>
    typia.random<ITodoAppRateLimit>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("rateLimitId")(() => typia.assert(props.rateLimitId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retire a rate limit policy (todo_app_rate_limits) by ID.
 *
 * Remove a rate limit policy from administrative use by targeting its unique
 * identifier in the todo_app_rate_limits table. The schema defines functional
 * attributes including code (unique), scope (e.g., "user", "ip", "global"),
 * category (e.g., "read", "write", "auth"), window_seconds, max_requests,
 * burst_size, sliding_window, and an enabled flag used by enforcement.
 * Lifecycle fields include created_at, updated_at, and a deleted_at timestamp.
 *
 * Access to this operation is restricted to system administrators responsible
 * for governance. It is designed to prevent accidental loss of operational
 * history. Instead of physically removing the row, the provider should set the
 * deleted_at timestamp to indicate the policy is retired. This approach
 * preserves referential integrity and auditability for related counters in
 * todo_app_user_rate_counters and todo_app_ip_rate_counters, which reference
 * todo_app_rate_limits via foreign keys.
 *
 * From a business rules perspective, administrators typically disable
 * enforcement (enabled=false) before retiring a policy to avoid abrupt changes
 * in production. Providers may enforce preconditions such as rejecting removal
 * when enabled=true. The operation should be idempotent: invoking it again on a
 * record already marked as deleted has no additional effect beyond confirming
 * the record remains retired.
 *
 * Error handling includes: 1) returning a not-found style outcome when
 * rateLimitId does not correspond to an existing, currently retained record; 2)
 * conflict-style outcomes when policy constraints require disabling before
 * retirement; and 3) authorization failures for non-admin actors.
 *
 * @param props.connection
 * @param props.rateLimitId Target rate limit policy identifier
 *   (todo_app_rate_limits.id)
 * @path /todoApp/systemAdmin/rateLimits/:rateLimitId
 * @accessor api.functional.todoApp.systemAdmin.rateLimits.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Target rate limit policy identifier (todo_app_rate_limits.id) */
    rateLimitId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoApp/systemAdmin/rateLimits/:rateLimitId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/rateLimits/${encodeURIComponent(props.rateLimitId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("rateLimitId")(() => typia.assert(props.rateLimitId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
