import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppUserRateCounter } from "../../../../../structures/ITodoAppUserRateCounter";
import { IPageITodoAppUserRateCounter } from "../../../../../structures/IPageITodoAppUserRateCounter";

/**
 * Search user rate counters by policy (todo_app_user_rate_counters).
 *
 * This operation returns user rate counter windows for a particular policy
 * identified by rateLimitId. The underlying Prisma model
 * todo_app_user_rate_counters contains references to todo_app_rate_limits
 * (todo_app_rate_limit_id) and to users (todo_app_user_id), along with
 * window_started_at/window_ends_at, count, last_action_at, and optional
 * blocked_until for cooldowns. Restricting by policy via the path parameter
 * aligns with common admin workflows that examine policy-specific impacts
 * across users.
 *
 * Security and permissions: Access is limited to administrators (systemAdmin)
 * due to the cross-user operational detail exposed. Implementations should
 * exclude records where deleted_at is present by default, consistent with
 * retention handling.
 *
 * Entity relationships and filtering: The IRequest payload may include
 * pagination, sorting, and additional filters such as userId, window overlap
 * periods, whether blocked_until is set or in the future, and ordering
 * preferences. The service must apply the policy constraint derived from the
 * path parameter in addition to any request body filters.
 *
 * Related operations: Use PATCH /userRateCounters for a global search across
 * all policies or GET /userRateCounters/{userRateCounterId} for a single
 * record. Policy configurations themselves are managed via the
 * todo_app_rate_limits entity in separate administrative surfaces.
 *
 * Error handling: Invalid UUID for rateLimitId should cause a validation error.
 * Authorization failures should deny access. An empty result is returned as an
 * empty page with pagination metadata.
 *
 * @param props.connection
 * @param props.rateLimitId Rate limit policy ID to scope user rate counter
 *   results
 * @param props.body Additional filters, sorting, and pagination for counters
 *   within the policy
 * @path /todoApp/systemAdmin/rateLimits/:rateLimitId/userRateCounters
 * @accessor api.functional.todoApp.systemAdmin.rateLimits.userRateCounters.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Rate limit policy ID to scope user rate counter results */
    rateLimitId: string & tags.Format<"uuid">;

    /**
     * Additional filters, sorting, and pagination for counters within the
     * policy
     */
    body: ITodoAppUserRateCounter.IRequest;
  };
  export type Body = ITodoAppUserRateCounter.IRequest;
  export type Response = IPageITodoAppUserRateCounter;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/rateLimits/:rateLimitId/userRateCounters",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/systemAdmin/rateLimits/${encodeURIComponent(props.rateLimitId ?? "null")}/userRateCounters`;
  export const random = (): IPageITodoAppUserRateCounter =>
    typia.random<IPageITodoAppUserRateCounter>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("rateLimitId")(() => typia.assert(props.rateLimitId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single user rate counter (todo_app_user_rate_counters) under a specific
 * rate limit.
 *
 * Fetch detailed information about a single user rate counter record tied to a
 * specific rate limit policy. The underlying Prisma model
 * todo_app_user_rate_counters stores per-user counters with fields including id
 * (UUID), todo_app_rate_limit_id (link to todo_app_rate_limits),
 * todo_app_user_id (link to todo_app_users), window_started_at, window_ends_at,
 * count, last_action_at, blocked_until, and system timestamps (created_at,
 * updated_at). The schema comment explains this table is used to enforce
 * fair-use and cooldowns and is not directly managed by end users.
 *
 * Security and authorization: Access to user-level counters exposes operational
 * telemetry and must be restricted. Only system administrators should query
 * arbitrary users’ counters for investigations and support. End users do not
 * modify these records; the system updates them as requests are processed.
 * Implementations should ensure that records with archival markers (deleted_at
 * not null) are excluded from normal responses unless an explicit audit mode is
 * used.
 *
 * Data relationships and validation: The returned record references
 * todo_app_rate_limits via todo_app_rate_limit_id to bind the counter to a
 * configured policy (window_seconds, max_requests, scope, category). It also
 * references todo_app_users via todo_app_user_id to identify the subject
 * account. The path requires both rateLimitId and userRateCounterId; providers
 * should verify that the counter’s todo_app_rate_limit_id matches the
 * rateLimitId to prevent cross-policy leakage. If not found or mismatched,
 * return a not-found outcome.
 *
 * Usage and error handling: Typical use cases include diagnosing throttled
 * users (blocked_until set), verifying counter behavior within a window
 * (window_started_at/window_ends_at), and correlating with admin actions or
 * audit logs. Error scenarios include nonexistent IDs, mismatched parent-child
 * relation (counter not under the specified rate limit), or access without
 * sufficient privileges. As this is a read-only operation, no side effects
 * occur.
 *
 * @param props.connection
 * @param props.rateLimitId Target rate limit policy ID to which the user rate
 *   counter must belong.
 * @param props.userRateCounterId Identifier of the user rate counter to
 *   retrieve.
 * @path /todoApp/systemAdmin/rateLimits/:rateLimitId/userRateCounters/:userRateCounterId
 * @accessor api.functional.todoApp.systemAdmin.rateLimits.userRateCounters.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Target rate limit policy ID to which the user rate counter must
     * belong.
     */
    rateLimitId: string & tags.Format<"uuid">;

    /** Identifier of the user rate counter to retrieve. */
    userRateCounterId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppUserRateCounter;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/rateLimits/:rateLimitId/userRateCounters/:userRateCounterId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/rateLimits/${encodeURIComponent(props.rateLimitId ?? "null")}/userRateCounters/${encodeURIComponent(props.userRateCounterId ?? "null")}`;
  export const random = (): ITodoAppUserRateCounter =>
    typia.random<ITodoAppUserRateCounter>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("rateLimitId")(() => typia.assert(props.rateLimitId));
      assert.param("userRateCounterId")(() =>
        typia.assert(props.userRateCounterId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
