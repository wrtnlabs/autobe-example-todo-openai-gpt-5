import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppIpRateCounter } from "../../../../../structures/ITodoAppIpRateCounter";
import { IPageITodoAppIpRateCounter } from "../../../../../structures/IPageITodoAppIpRateCounter";

/**
 * Search IP rate counters (todo_app_ip_rate_counters) for a specific rate limit
 * policy.
 *
 * Retrieve a filtered, paginated list of IP rate counters from
 * todo_app_ip_rate_counters restricted to a given policy (todo_app_rate_limits)
 * via the path parameter rateLimitId. The underlying schema defines fields
 * including id (UUID), todo_app_rate_limit_id, ip, window_started_at,
 * window_ends_at, count, last_action_at, blocked_until, created_at, and
 * updated_at. These counters are maintained by system processes to enforce
 * throttling and cooldown behavior.
 *
 * Security and access: Because this operation surfaces operational telemetry
 * per policy, it should be limited to system administrators. End users have no
 * direct control over these records. Providers should ignore archival rows
 * where deleted_at is set in normal listings unless explicitly operating in an
 * audit context.
 *
 * Filtering and pagination: The request body (ITodoAppIpRateCounter.IRequest)
 * can include additional filters such as IP substring match, window ranges,
 * count thresholds, blocked vs. unblocked state, and sorting preferences (e.g.,
 * latest last_action_at first). Pagination should observe business defaults and
 * limits for page size and page index. Records must be filtered to the
 * specified rateLimitId regardless of request body content to avoid
 * cross-policy leakage.
 *
 * Related operations and errors: Use GET /ipRateCounters/{ipRateCounterId} to
 * drill into a single record after identifying it in this list. If the
 * specified rateLimitId does not exist, the operation should return an empty
 * page. As a read-only search, no side effects occur.
 *
 * @param props.connection
 * @param props.rateLimitId Rate limit policy ID used to constrain IP rate
 *   counters.
 * @param props.body Search criteria, sorting, and pagination; results are
 *   constrained by rateLimitId.
 * @path /todoApp/systemAdmin/rateLimits/:rateLimitId/ipRateCounters
 * @accessor api.functional.todoApp.systemAdmin.rateLimits.ipRateCounters.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Rate limit policy ID used to constrain IP rate counters. */
    rateLimitId: string & tags.Format<"uuid">;

    /**
     * Search criteria, sorting, and pagination; results are constrained by
     * rateLimitId.
     */
    body: ITodoAppIpRateCounter.IRequest;
  };
  export type Body = ITodoAppIpRateCounter.IRequest;
  export type Response = IPageITodoAppIpRateCounter.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/rateLimits/:rateLimitId/ipRateCounters",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/systemAdmin/rateLimits/${encodeURIComponent(props.rateLimitId ?? "null")}/ipRateCounters`;
  export const random = (): IPageITodoAppIpRateCounter.ISummary =>
    typia.random<IPageITodoAppIpRateCounter.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("rateLimitId")(() => typia.assert(props.rateLimitId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get an IP rate counter under a rate limit from todo_app_ip_rate_counters.
 *
 * This endpoint retrieves a single IP-based rate counter under a particular
 * rate limit, enabling administrators to inspect throttling state for a given
 * IP within a configured policy window. It operates on the
 * todo_app_ip_rate_counters table, which aggregates request counts per IP and
 * policy window and stores critical fields such as window_started_at,
 * window_ends_at, count, last_action_at, and blocked_until. The parent
 * configuration resides in todo_app_rate_limits, which defines the policy code,
 * scope (e.g., "ip"), category (e.g., "read", "write", "auth"), window_seconds,
 * max_requests, and optional burst_size. This endpoint ensures that the counter
 * returned is scoped to the provided rateLimitId through the foreign key
 * todo_app_rate_limit_id.
 *
 * Security and authorization are restricted to system administrators because
 * these counters expose operational details of enforcement and could reveal
 * sensitive patterns about traffic and abuse protection. Only users with the
 * systemAdmin role should have access. Requests must provide valid UUIDs for
 * both rateLimitId and ipRateCounterId. The service must also ensure that the
 * counterâ€™s todo_app_rate_limit_id equals the path rateLimitId; otherwise, the
 * request is treated as not found to avoid leaking cross-scope information.
 *
 * From a data model perspective, the todo_app_ip_rate_counters table tracks
 * per-policy, per-IP counters using a fixed or sliding window as configured by
 * the linked todo_app_rate_limits record (fields include scope, category,
 * window_seconds, max_requests, burst_size, sliding_window, and enabled).
 * Relevant operational timestamps include last_action_at for the most recent
 * contributing request and blocked_until for the cooldown end time when
 * throttling has been applied. Standard lifecycle timestamps created_at and
 * updated_at are system-managed. Records where deleted_at is non-null are
 * considered deleted and should be excluded from normal responses.
 *
 * Validation and behavior: If either identifier is not a valid UUID, the
 * provider should reject the request. If the ipRateCounterId does not exist, is
 * marked deleted via deleted_at, or exists but is linked to a different rate
 * limit than rateLimitId, the provider should return a not-found outcome. When
 * successful, the response includes the full rate counter entity. This endpoint
 * is read-only and does not modify any counters.
 *
 * Related operations that typically appear alongside this one include a
 * list/search endpoint to filter IP rate counters by rateLimitId and time
 * windows (using pagination and sorting), and administrative actions to view
 * user-level counters (todo_app_user_rate_counters). Write operations
 * (creation, modification, or deletion) for counters are not exposed because
 * counters are system-managed and updated automatically by enforcement logic.
 *
 * @param props.connection
 * @param props.rateLimitId Identifier of the rate limit policy
 *   (todo_app_rate_limits.id) that owns this counter
 * @param props.ipRateCounterId Identifier of the IP rate counter record
 *   (todo_app_ip_rate_counters.id) to retrieve
 * @path /todoApp/systemAdmin/rateLimits/:rateLimitId/ipRateCounters/:ipRateCounterId
 * @accessor api.functional.todoApp.systemAdmin.rateLimits.ipRateCounters.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Identifier of the rate limit policy (todo_app_rate_limits.id) that
     * owns this counter
     */
    rateLimitId: string & tags.Format<"uuid">;

    /**
     * Identifier of the IP rate counter record
     * (todo_app_ip_rate_counters.id) to retrieve
     */
    ipRateCounterId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppIpRateCounter;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/rateLimits/:rateLimitId/ipRateCounters/:ipRateCounterId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/rateLimits/${encodeURIComponent(props.rateLimitId ?? "null")}/ipRateCounters/${encodeURIComponent(props.ipRateCounterId ?? "null")}`;
  export const random = (): ITodoAppIpRateCounter =>
    typia.random<ITodoAppIpRateCounter>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("rateLimitId")(() => typia.assert(props.rateLimitId));
      assert.param("ipRateCounterId")(() =>
        typia.assert(props.ipRateCounterId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
