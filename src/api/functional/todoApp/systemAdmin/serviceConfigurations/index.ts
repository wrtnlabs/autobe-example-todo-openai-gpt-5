import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppServiceConfiguration } from "../../../../structures/ITodoAppServiceConfiguration";
import { IPageITodoAppServiceConfiguration } from "../../../../structures/IPageITodoAppServiceConfiguration";

/**
 * Create a new service configuration (todo_app_service_configurations).
 *
 * Insert a configuration item into todo_app_service_configurations. Required
 * and optional columns include: namespace (string), environment (nullable
 * string), key (string), value (string), value_type (string), is_secret
 * (boolean), description (nullable string), active (boolean),
 * effective_from/effective_to (nullable DateTime), and system-managed
 * created_at/updated_at timestamps. The table enforces uniqueness across
 * (namespace, key, environment) and supports referential links to
 * todo_app_users (todo_app_user_id) and todo_app_service_policies
 * (todo_app_service_policy_id).
 *
 * Only users with the systemAdmin role may create configuration items.
 * Implementations must validate input lengths and formats as appropriate for
 * the domain and ensure the value is interpreted according to value_type. When
 * is_secret=true, providers should ensure the value is protected in logs and
 * list summaries. Records with non-null deleted_at are excluded from normal
 * flows; this endpoint creates active records and does not interact with
 * removed records.
 *
 * On success, the operation returns the full configuration entity. Conflicts
 * due to duplicate (namespace, key, environment) combinations should be
 * surfaced as a clear validation error. Related endpoints: PATCH
 * /serviceConfigurations for listing, GET
 * /serviceConfigurations/{configurationId} for details, PUT
 * /serviceConfigurations/{configurationId} for updates.
 *
 * @param props.connection
 * @param props.body Creation payload for a configuration item.
 * @path /todoApp/systemAdmin/serviceConfigurations
 * @accessor api.functional.todoApp.systemAdmin.serviceConfigurations.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Creation payload for a configuration item. */
    body: ITodoAppServiceConfiguration.ICreate;
  };
  export type Body = ITodoAppServiceConfiguration.ICreate;
  export type Response = ITodoAppServiceConfiguration;

  export const METADATA = {
    method: "POST",
    path: "/todoApp/systemAdmin/serviceConfigurations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/systemAdmin/serviceConfigurations";
  export const random = (): ITodoAppServiceConfiguration =>
    typia.random<ITodoAppServiceConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and paginate service configurations (todo_app_service_configurations).
 *
 * Retrieve a filtered, sorted, and paginated collection of configuration items
 * defined in the todo_app_service_configurations table. Columns include: id
 * (UUID), namespace (string), environment (nullable string), key (string),
 * value (string), value_type (string), is_secret (boolean), description
 * (nullable string), active (boolean), effective_from/effective_to (nullable
 * DateTime), created_at/updated_at (DateTime), optional references to a
 * creating/updating user (todo_app_user_id) and a governing policy
 * (todo_app_service_policy_id), and a deleted_at timestamp that denotes records
 * removed from normal flows.
 *
 * Access is restricted to administrative users responsible for operations and
 * governance. Only users with the systemAdmin role are allowed to search
 * configuration keys. Implementations should ensure that sensitive values
 * (is_secret=true) are not exposed in list responses; returning metadata and
 * redacted value representations is recommended for the summary collection.
 *
 * The operation is tightly coupled with underlying relations: user references
 * todo_app_users and policy references todo_app_service_policies. Consumers
 * commonly filter by namespace, environment, active, value_type, and effective
 * window intersections (e.g., records that are currently effective based on
 * effective_from/effective_to). Free-text search over key and description is
 * supported, aligning with GIN trigram indexes declared in the schema for key
 * and description. Records where deleted_at is not null must be excluded from
 * standard results.
 *
 * Validation and business logic include enforcing the unique constraint on
 * (namespace, key, environment) at creation time (handled by the creation API).
 * This search endpoint supports pagination (page/size), sorting (e.g.,
 * created_at desc by default), and keyword search. Related endpoints: GET
 * /serviceConfigurations/{configurationId} for details, POST
 * /serviceConfigurations for creation, and PUT
 * /serviceConfigurations/{configurationId} for updates.
 *
 * @param props.connection
 * @param props.body Search criteria, pagination, and sorting options for
 *   configuration listing.
 * @path /todoApp/systemAdmin/serviceConfigurations
 * @accessor api.functional.todoApp.systemAdmin.serviceConfigurations.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, pagination, and sorting options for configuration
     * listing.
     */
    body: ITodoAppServiceConfiguration.IRequest;
  };
  export type Body = ITodoAppServiceConfiguration.IRequest;
  export type Response = IPageITodoAppServiceConfiguration.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/serviceConfigurations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/systemAdmin/serviceConfigurations";
  export const random = (): IPageITodoAppServiceConfiguration.ISummary =>
    typia.random<IPageITodoAppServiceConfiguration.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get one service configuration by id (todo_app_service_configurations).
 *
 * Fetch a specific configuration by identifier from
 * todo_app_service_configurations. The table stores: id (UUID), namespace,
 * optional environment, key, value, value_type, is_secret flag, optional
 * description, active flag, optional effective_from/effective_to, and
 * timestamps (created_at, updated_at). It also references an optional
 * administrator user via todo_app_user_id and an optional policy via
 * todo_app_service_policy_id. A non-null deleted_at indicates the record is
 * removed from normal flows and must not be included in standard reads.
 *
 * Security considerations limit access to system administrators.
 * Implementations should handle value exposure carefully when is_secret=true.
 * While list endpoints typically redact sensitive values, detailed reads for
 * systemAdmin users may return the full value subject to organizational policy
 * and auditing requirements.
 *
 * If the identifier does not correspond to an available record (including when
 * the record is removed from normal flows), the operation should respond with
 * an appropriate not-found outcome without leaking existence information to
 * unauthorized roles. Related endpoints: PATCH /serviceConfigurations for
 * searching, POST /serviceConfigurations for creating new keys, and PUT
 * /serviceConfigurations/{configurationId} for updates.
 *
 * @param props.connection
 * @param props.configurationId Target configuration's UUID
 * @path /todoApp/systemAdmin/serviceConfigurations/:configurationId
 * @accessor api.functional.todoApp.systemAdmin.serviceConfigurations.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Target configuration's UUID */
    configurationId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppServiceConfiguration;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/serviceConfigurations/:configurationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/serviceConfigurations/${encodeURIComponent(props.configurationId ?? "null")}`;
  export const random = (): ITodoAppServiceConfiguration =>
    typia.random<ITodoAppServiceConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("configurationId")(() =>
        typia.assert(props.configurationId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing service configuration (todo_app_service_configurations).
 *
 * Modify a configuration item stored in todo_app_service_configurations.
 * Updatable fields typically include: value (string), value_type (string),
 * is_secret (boolean), description (nullable string), active (boolean), and
 * effective_from/effective_to (nullable DateTime). Depending on governance
 * policy, administrators may also adjust namespace, environment, or key, but
 * care must be taken to maintain the unique composition across (namespace, key,
 * environment). System-managed columns created_at and updated_at are maintained
 * automatically; records with non-null deleted_at are excluded from standard
 * update flows.
 *
 * Only systemAdmin users can perform updates. When is_secret=true, service
 * providers should avoid exposing values in logs and audit channels and should
 * consider redaction in UI list contexts. If todo_app_service_policy_id is
 * supplied, it must reference an existing policy in todo_app_service_policies.
 * Attempts to update to a duplicate (namespace, key, environment) combination
 * should produce a validation conflict.
 *
 * Related endpoints include: PATCH /serviceConfigurations for searching, GET
 * /serviceConfigurations/{configurationId} for retrieving details, and POST
 * /serviceConfigurations for creating new records. Error handling should
 * include not-found outcomes for unknown ids and conflict responses for
 * uniqueness violations.
 *
 * @param props.connection
 * @param props.configurationId Target configuration's UUID
 * @param props.body Update payload for the target configuration item.
 * @path /todoApp/systemAdmin/serviceConfigurations/:configurationId
 * @accessor api.functional.todoApp.systemAdmin.serviceConfigurations.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Target configuration's UUID */
    configurationId: string & tags.Format<"uuid">;

    /** Update payload for the target configuration item. */
    body: ITodoAppServiceConfiguration.IUpdate;
  };
  export type Body = ITodoAppServiceConfiguration.IUpdate;
  export type Response = ITodoAppServiceConfiguration;

  export const METADATA = {
    method: "PUT",
    path: "/todoApp/systemAdmin/serviceConfigurations/:configurationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/systemAdmin/serviceConfigurations/${encodeURIComponent(props.configurationId ?? "null")}`;
  export const random = (): ITodoAppServiceConfiguration =>
    typia.random<ITodoAppServiceConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("configurationId")(() =>
        typia.assert(props.configurationId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a service configuration by ID in todo_app_service_configurations
 * (logical deletion via deleted_at).
 *
 * This operation targets the Systematic configuration store represented by the
 * Prisma model todo_app_service_configurations. According to the schema
 * comments, it manages key/value settings grouped by namespace and optionally
 * by environment, with an explicit value_type to inform runtime interpretation.
 * Records carry flags such as is_secret to indicate sensitive contents and
 * active to control evaluation, as well as effective_from and effective_to to
 * bound their applicability. The model enforces a uniqueness constraint across
 * (namespace, key, environment) and provides relations to a governing policy
 * (todo_app_service_policies) and an administrative user (todo_app_users).
 *
 * Security and permissions: Configuration lifecycle is an administrative
 * responsibility. Access is therefore restricted to system administrators.
 * Since the table includes sensitive configuration values (some marked as
 * is_secret), responses, logs, and business logic must ensure secrets are not
 * exposed inadvertently during deletion workflows.
 *
 * Behavior and lifecycle: Because todo_app_service_configurations has a
 * deleted_at column, deletion is implemented by marking the record as deleted
 * (setting deleted_at). This ensures the record is excluded from normal flows
 * while preserving historical context and references. Consider how uniqueness
 * rules and any downstream caches behave after deletion. If your system
 * requires re-introducing a configuration with the same (namespace, key,
 * environment), ensure that either the existing record is updated/reused or
 * your business logic supports handling archived entries appropriately.
 *
 * Validation and errors: The endpoint expects a valid UUID for configurationId.
 * If the record does not exist or is already deleted, providers should respond
 * idempotently—acknowledging the state without exposing sensitive details.
 * Related APIs include listing and detail retrieval endpoints for
 * configurations (not covered here) and policy management endpoints if
 * configurations are governed by todo_app_service_policies.
 *
 * @param props.connection
 * @param props.configurationId Unique identifier of the service configuration
 *   to delete
 * @path /todoApp/systemAdmin/serviceConfigurations/:configurationId
 * @accessor api.functional.todoApp.systemAdmin.serviceConfigurations.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the service configuration to delete */
    configurationId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoApp/systemAdmin/serviceConfigurations/:configurationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/serviceConfigurations/${encodeURIComponent(props.configurationId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("configurationId")(() =>
        typia.assert(props.configurationId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
