import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppFeatureFlag } from "../../../../structures/ITodoAppFeatureFlag";
import { IPageITodoAppFeatureFlag } from "../../../../structures/IPageITodoAppFeatureFlag";

/**
 * Create a new feature flag (todo_app_feature_flags).
 *
 * This operation inserts a new feature flag as defined by the Prisma model
 * todo_app_feature_flags. The schema comments emphasize environment and
 * namespace scoping, percentage rollouts, and optional targeting notes. Fields
 * include namespace, environment, code, name, description, active,
 * rollout_percentage, target_audience, start_at, end_at, and lifecycle
 * timestamps (created_at, updated_at, deleted_at). Optional relations to
 * todo_app_service_policies and todo_app_users capture governance and
 * administrative ownership. A composite uniqueness constraint requires that
 * (namespace, code, environment) be unique.
 *
 * Security and permissions: Feature flag creation is an administrative action.
 * Only system administrators should be allowed. The business logic must
 * validate required fields, ensure rollout_percentage is within 0–100, and
 * confirm uniqueness before insertion. Sensitive internal notes should remain
 * in description/targeting fields only if appropriate.
 *
 * Validation and errors: Providers should perform input validation (e.g.,
 * non-empty namespace/code/name, rollout_percentage bounds, start/end window
 * consistency). If a duplicate (namespace, code, environment) exists—even if
 * archived logic is applied—surface a clear conflict error. On success, return
 * the full feature flag entity.
 *
 * Related operations: Use PATCH /featureFlags for listing/searching and GET
 * /featureFlags/{featureFlagId} to view details of the newly created flag.
 * Update and archival endpoints (not included here) typically complete the flag
 * lifecycle.
 *
 * @param props.connection
 * @param props.body Feature flag creation payload with validation per model
 *   constraints
 * @path /todoApp/systemAdmin/featureFlags
 * @accessor api.functional.todoApp.systemAdmin.featureFlags.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Feature flag creation payload with validation per model constraints */
    body: ITodoAppFeatureFlag.ICreate;
  };
  export type Body = ITodoAppFeatureFlag.ICreate;
  export type Response = ITodoAppFeatureFlag;

  export const METADATA = {
    method: "POST",
    path: "/todoApp/systemAdmin/featureFlags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/systemAdmin/featureFlags";
  export const random = (): ITodoAppFeatureFlag =>
    typia.random<ITodoAppFeatureFlag>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and list feature flags (todo_app_feature_flags) with filtering,
 * sorting, and pagination.
 *
 * This endpoint lists feature flags stored in the Prisma model
 * todo_app_feature_flags. Per the schema comments, flags enable conditional
 * behavior and staged rollouts. Each flag has namespace, optional environment,
 * code, name, description, an active switch, rollout_percentage (0–100),
 * optional targeting notes, and optional time bounds (start_at/end_at).
 * Administrative actors may associate flags with a governing policy
 * (todo_app_service_policies), and relations to todo_app_users capture
 * ownership. The table includes created_at, updated_at, and deleted_at
 * lifecycle columns and GIN indices for name/description to support search.
 *
 * Security considerations: Only system administrators should query full
 * administrative listings, as flags can reveal internal rollout strategies.
 * Although this is a read operation, the data may carry operational sensitivity
 * (e.g., unreleased features). Providers should filter out logically deleted
 * rows (where deleted_at is set) in normal listings unless an explicit
 * include-archived option is requested by policy.
 *
 * Filtering, pagination, and sorting: Business logic should support filters by
 * namespace, environment, code, name, active status, rollout_percentage ranges,
 * association to a specific policy, effective windows (start_at/end_at), and
 * general date ranges (created_at/updated_at). Free-text search should leverage
 * the indexed fields (name, description). Sorting typically includes created_at
 * desc by default, with options to sort by namespace/code/name, active,
 * rollout_percentage, or time windows. Pagination parameters (page number/size)
 * must respect admin-configured limits.
 *
 * Related operations: Use GET /featureFlags/{featureFlagId} to fetch a single
 * flag record and POST /featureFlags to create a new one. Update and archival
 * endpoints would complement this search to form a full administrative
 * workflow.
 *
 * @param props.connection
 * @param props.body Search criteria, filters, sorting, and pagination controls
 *   for feature flags
 * @path /todoApp/systemAdmin/featureFlags
 * @accessor api.functional.todoApp.systemAdmin.featureFlags.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria, filters, sorting, and pagination controls for
     * feature flags
     */
    body: ITodoAppFeatureFlag.IRequest;
  };
  export type Body = ITodoAppFeatureFlag.IRequest;
  export type Response = IPageITodoAppFeatureFlag.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/featureFlags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/systemAdmin/featureFlags";
  export const random = (): IPageITodoAppFeatureFlag.ISummary =>
    typia.random<IPageITodoAppFeatureFlag.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single feature flag by ID from todo_app_feature_flags.
 *
 * This operation returns the complete details for one feature flag managed in
 * the Prisma model todo_app_feature_flags. As described in the schema, each
 * flag supports environment and namespace scoping, percentage rollouts, and
 * optional targeting metadata. Administrators can link a flag to a governing
 * policy (todo_app_service_policies), and the creator/owner relation to
 * todo_app_users captures administrative attribution. The model also defines
 * created_at, updated_at, and deleted_at timestamps, with search-friendly
 * indexes on name and description.
 *
 * Security: Feature flag definitions often reveal product roadmap and
 * operational strategy. Access should be limited to system administrators. When
 * a flag has been archived (deleted_at set), typical detail retrieval either
 * hides it or returns it with a clear archived indicator, depending on policy.
 *
 * Validation and behavior: The featureFlagId must be a valid UUID. If the
 * identifier does not correspond to an existing row or the flag has been
 * archived, the provider should return an appropriate error or a not-found
 * response consistent with administrative console expectations. This endpoint
 * is typically used after a search or from direct navigation in an admin UI.
 *
 * Related operations: Use PATCH /featureFlags for search and listing and POST
 * /featureFlags for creation. Update and archival endpoints would complete the
 * administrative lifecycle for flags.
 *
 * @param props.connection
 * @param props.featureFlagId Unique identifier of the feature flag
 * @path /todoApp/systemAdmin/featureFlags/:featureFlagId
 * @accessor api.functional.todoApp.systemAdmin.featureFlags.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the feature flag */
    featureFlagId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppFeatureFlag;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/featureFlags/:featureFlagId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/featureFlags/${encodeURIComponent(props.featureFlagId ?? "null")}`;
  export const random = (): ITodoAppFeatureFlag =>
    typia.random<ITodoAppFeatureFlag>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("featureFlagId")(() => typia.assert(props.featureFlagId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a feature flag (todo_app_feature_flags) by ID.
 *
 * Update an existing feature flag record in the administration configuration
 * domain. The underlying Prisma model todo_app_feature_flags includes fields
 * for namespace, environment, code, name, description, active,
 * rollout_percentage, target_audience, start_at, end_at, created_at,
 * updated_at, and deleted_at. It also carries optional foreign keys to
 * todo_app_service_policies (todo_app_service_policy_id) and todo_app_users
 * (todo_app_user_id) noting the administrative owner/creator. As documented in
 * the schema comments, this model supports environment and namespace scoping,
 * percentage rollouts, and optional targeting notes.
 *
 * Security considerations: Only users with the systemAdmin role should be
 * allowed to modify feature flag definitions. The operation must check that the
 * target flag is not logically removed (deleted_at is null) before applying
 * changes. The system should record administrative actions in audit facilities
 * like todo_app_admin_actions and todo_app_audit_logs for governance,
 * attributing the actor and reason when appropriate.
 *
 * This operation updates attributes of the identified flag while respecting
 * database constraints. The unique key across (namespace, code, environment)
 * must not be violated. The rollout_percentage must remain within the 0–100
 * integer range as indicated by the model. When linking to a policy via
 * todo_app_service_policy_id, the referenced todo_app_service_policies record
 * must exist and be appropriate for the intended governance. The updated_at
 * column should reflect the modification time; created_at is immutable by
 * clients.
 *
 * Related operations may include listing or retrieving feature flags for
 * administration, or deleting a flag to remove it from evaluation. On errors,
 * respond with appropriate messages for not found (unknown or logically removed
 * id), conflict on unique constraints, or validation failures for type/range
 * rules.
 *
 * @param props.connection
 * @param props.featureFlagId Feature flag's UUID to update
 * @param props.body Fields to update on the feature flag
 * @path /todoApp/systemAdmin/featureFlags/:featureFlagId
 * @accessor api.functional.todoApp.systemAdmin.featureFlags.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Feature flag's UUID to update */
    featureFlagId: string & tags.Format<"uuid">;

    /** Fields to update on the feature flag */
    body: ITodoAppFeatureFlag.IUpdate;
  };
  export type Body = ITodoAppFeatureFlag.IUpdate;
  export type Response = ITodoAppFeatureFlag;

  export const METADATA = {
    method: "PUT",
    path: "/todoApp/systemAdmin/featureFlags/:featureFlagId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/systemAdmin/featureFlags/${encodeURIComponent(props.featureFlagId ?? "null")}`;
  export const random = (): ITodoAppFeatureFlag =>
    typia.random<ITodoAppFeatureFlag>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("featureFlagId")(() => typia.assert(props.featureFlagId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a feature flag (todo_app_feature_flags) by ID.
 *
 * Delete a feature flag in the configuration domain. The Prisma model
 * todo_app_feature_flags includes a deleted_at column used to exclude records
 * from normal operations. When this endpoint is invoked by an authorized
 * systemAdmin, the implementation should transition the record to a deleted
 * state so that it is no longer returned by standard administrative listings or
 * used by runtime evaluators. The model also references optional relations to
 * todo_app_service_policies (policy) and todo_app_users (user); removing a flag
 * does not require modifying those parent entities.
 *
 * Security and governance: Only systemAdmin actors may remove feature flags.
 * Implementations should capture an administrative action in audit trails
 * (e.g., todo_app_admin_actions or todo_app_audit_logs) with the actor identity
 * and optional human-readable reason.
 *
 * Behavior and errors: If the id does not correspond to an existing,
 * non-deleted record, respond with a not-found outcome. If the flag is already
 * marked deleted, the operation may be treated as idempotent. No response body
 * is returned on success.
 *
 * @param props.connection
 * @param props.featureFlagId Feature flag's UUID to delete
 * @path /todoApp/systemAdmin/featureFlags/:featureFlagId
 * @accessor api.functional.todoApp.systemAdmin.featureFlags.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Feature flag's UUID to delete */
    featureFlagId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoApp/systemAdmin/featureFlags/:featureFlagId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/featureFlags/${encodeURIComponent(props.featureFlagId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("featureFlagId")(() => typia.assert(props.featureFlagId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
