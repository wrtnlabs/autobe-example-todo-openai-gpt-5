import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppAuditLog } from "../../../../structures/ITodoAppAuditLog";
import { IPageITodoAppAuditLog } from "../../../../structures/IPageITodoAppAuditLog";

/**
 * Search audit logs (todo_app_audit_logs) with filters, sorting, and
 * pagination.
 *
 * This operation queries audit entries recorded in the Prisma model
 * todo_app_audit_logs. The table captures security-relevant actions with fields
 * including actor_user_id (required), optional target_user_id, action (business
 * action key), resource_type, resource_id, success (boolean), client context
 * (ip, user_agent), and created_at/updated_at timestamps. The purpose is to
 * enable governance reviews without exposing private todo text values,
 * consistent with the schema’s design notes.
 *
 * Security and permissions: Audit data is highly sensitive and restricted to
 * systemAdmin users. Results may be further filtered or masked according to
 * policy when necessary (e.g., regional handling of IPs). The endpoint is
 * read-only.
 *
 * Entity relationships: actor_user_id and target_user_id reference
 * todo_app_users. These relations support filters like “all actions by an
 * administrator in a time window” or “all actions affecting a particular
 * account.” The audit log does not store private todo content; it only
 * references resource_type and resource_id for linkage in incident analysis.
 *
 * Validation and business logic: The request supports equality filtering on
 * identifiers (actor_user_id, target_user_id), exact or prefix matching on
 * action and resource_type as allowed by policy, boolean filtering on success,
 * and time-range filters over created_at. Sorting commonly uses created_at
 * descending for latest-first review. Pagination defaults should align with
 * administrative consoles (e.g., 20–100 per page).
 *
 * Related operations: Use GET /todoApp/systemAdmin/auditLogs/{auditLogId} for
 * fetching a specific audit record once identified. Combine with user
 * management views to correlate sequences of actions when investigating
 * events.
 *
 * Error handling: Invalid UUID formats or unsupported filter combinations
 * should be rejected with clear validation messages. Non-existent references
 * simply result in empty result sets.
 *
 * @param props.connection
 * @param props.body Filtering and pagination parameters for audit log search
 * @path /todoApp/systemAdmin/auditLogs
 * @accessor api.functional.todoApp.systemAdmin.auditLogs.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filtering and pagination parameters for audit log search */
    body: ITodoAppAuditLog.IRequest;
  };
  export type Body = ITodoAppAuditLog.IRequest;
  export type Response = IPageITodoAppAuditLog.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/auditLogs",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/systemAdmin/auditLogs";
  export const random = (): IPageITodoAppAuditLog.ISummary =>
    typia.random<IPageITodoAppAuditLog.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get one audit log entry (todo_app_audit_logs) by ID.
 *
 * This operation fetches an audit record from todo_app_audit_logs using its id
 * (UUID). Each audit row includes actor_user_id (required), optional
 * target_user_id, action, resource_type, resource_id, success flag, and
 * optional client context such as ip and user_agent, along with created_at and
 * updated_at timestamps. The audit log intentionally avoids storing private
 * todo content, focusing on security-relevant metadata as described in the
 * schema comments.
 *
 * Security: Access is limited to systemAdmin due to the sensitivity of audit
 * trails. The operation is read-only and intended for investigative and
 * compliance workflows.
 *
 * Relationships and interpretation: actor_user_id and target_user_id link to
 * todo_app_users. resource_type and resource_id allow correlating this entry
 * with domain entities. Implementations commonly provide navigation to related
 * user records where permitted by policy.
 *
 * Behavior and errors: If the auditLogId does not correspond to an existing
 * row, the service should return not found. No request body is required.
 *
 * @param props.connection
 * @param props.auditLogId Unique identifier (UUID) of the audit log entry to
 *   retrieve
 * @path /todoApp/systemAdmin/auditLogs/:auditLogId
 * @accessor api.functional.todoApp.systemAdmin.auditLogs.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier (UUID) of the audit log entry to retrieve */
    auditLogId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppAuditLog;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/auditLogs/:auditLogId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/auditLogs/${encodeURIComponent(props.auditLogId ?? "null")}`;
  export const random = (): ITodoAppAuditLog =>
    typia.random<ITodoAppAuditLog>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("auditLogId")(() => typia.assert(props.auditLogId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
