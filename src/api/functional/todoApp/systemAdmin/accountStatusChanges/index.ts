import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppAccountStatusChange } from "../../../../structures/ITodoAppAccountStatusChange";
import { IPageITodoAppAccountStatusChange } from "../../../../structures/IPageITodoAppAccountStatusChange";

/**
 * Search and retrieve paginated account status changes
 * (todo_app_account_status_changes) for governance.
 *
 * Retrieve a filtered and paginated collection of user account status
 * transitions from the todo_app_account_status_changes table. The Prisma schema
 * describes this model as “Point-in-time records of account lifecycle changes
 * for users (e.g., pending_verification → active, active → suspended, suspended
 * → active). Provides a complete historical trail for governance and incident
 * investigation. The admin attribution is optional for system-triggered
 * transitions. No private todo text is stored here.” Key fields include
 * target_user_id (the subject account), admin_user_id (optional administrator
 * actor), previous_status, new_status, business_reason, has_effect, and
 * timestamps (created_at, updated_at).
 *
 * Security and permissions: Access is restricted to users with the systemAdmin
 * role. Records may reveal sensitive governance events and must not be exposed
 * to non-admin users.
 *
 * Database relationships: Each row references the subject account
 * (target_user_id) and optionally the administrator responsible
 * (admin_user_id), both from todo_app_users. The operation must focus strictly
 * on lifecycle metadata and avoid exposure of unrelated user-private content.
 *
 * Validation and business logic: The request body supports filters such as
 * target_user_id, admin_user_id, previous_status, new_status, has_effect,
 * creation time window (created_at from/to), and free-text search over
 * business_reason consistent with the schema’s trigram index. Pagination
 * includes page and pageSize (1–100) and sorting by created_at or new_status.
 * Default ordering is created_at descending when unspecified.
 *
 * Related operations: Use this PATCH /accountStatusChanges endpoint to discover
 * events of interest; use GET /accountStatusChanges/{accountStatusChangeId} for
 * the specific record. Invalid filter values or page sizes should yield clear
 * validation errors without disclosing internal state.
 *
 * @param props.connection
 * @param props.body Filtering, sorting, and pagination parameters for account
 *   status change search.
 * @path /todoApp/systemAdmin/accountStatusChanges
 * @accessor api.functional.todoApp.systemAdmin.accountStatusChanges.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Filtering, sorting, and pagination parameters for account status
     * change search.
     */
    body: ITodoAppAccountStatusChange.IRequest;
  };
  export type Body = ITodoAppAccountStatusChange.IRequest;
  export type Response = IPageITodoAppAccountStatusChange.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/accountStatusChanges",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/systemAdmin/accountStatusChanges";
  export const random = (): IPageITodoAppAccountStatusChange.ISummary =>
    typia.random<IPageITodoAppAccountStatusChange.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of one account status change (todo_app_account_status_changes) by
 * ID.
 *
 * This operation fetches the account lifecycle change record identified by
 * accountStatusChangeId from the todo_app_account_status_changes table. The
 * Prisma schema explains that this model records status transitions such as
 * pending_verification → active, active → suspended, and suspended → active. It
 * captures the target user (target_user_id), optional admin actor
 * (admin_user_id), previous_status, new_status, business_reason (optional),
 * has_effect (indicating if the transition changed the stored status), and the
 * creation/update timestamps.
 *
 * Security and permissions: Only users with the systemAdmin role may access
 * this endpoint. Responses must avoid including any private Todo content and
 * remain limited to lifecycle metadata defined by the schema.
 *
 * Entity relationships: The record references two users via todo_app_users: the
 * subject account (target_user_id) and optionally the administrator who
 * effected the change (admin_user_id). Implementations may include authorized
 * display metadata for these users while respecting privacy and access rules.
 *
 * Validation and errors: The accountStatusChangeId must be a valid UUID. If the
 * record does not exist or access is unauthorized, return appropriate
 * not-found/forbidden errors without leaking sensitive details. This endpoint
 * is typically reached after narrowing results with PATCH
 * /accountStatusChanges.
 *
 * @param props.connection
 * @param props.accountStatusChangeId Unique identifier of the account status
 *   change to retrieve.
 * @path /todoApp/systemAdmin/accountStatusChanges/:accountStatusChangeId
 * @accessor api.functional.todoApp.systemAdmin.accountStatusChanges.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the account status change to retrieve. */
    accountStatusChangeId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppAccountStatusChange;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/accountStatusChanges/:accountStatusChangeId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/accountStatusChanges/${encodeURIComponent(props.accountStatusChangeId ?? "null")}`;
  export const random = (): ITodoAppAccountStatusChange =>
    typia.random<ITodoAppAccountStatusChange>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("accountStatusChangeId")(() =>
        typia.assert(props.accountStatusChangeId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
