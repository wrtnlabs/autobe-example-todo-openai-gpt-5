import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppDailyStat } from "../../../../structures/ITodoAppDailyStat";
import { IPageITodoAppDailyStat } from "../../../../structures/IPageITodoAppDailyStat";

/**
 * Search and paginate daily stats (mv_todo_app_daily_stats).
 *
 * This operation returns a paginated list of daily statistics from
 * mv_todo_app_daily_stats. Per the Prisma schema description, each row is a
 * read-optimized, denormalized snapshot for a calendar date (stats_date) that
 * includes todos_created, todos_completed, active_users, and a computed
 * completion_ratio, as well as refreshed_at timestamps indicating when the
 * materialized data was last refreshed. The rows also include created_at and
 * updated_at metadata used by the materialized cache layer and an optional
 * deleted_at that indicates an archived row in the cache.
 *
 * The endpoint is read-only and intended for administrative analytics and
 * dashboards. Because daily rollups can disclose service usage patterns, access
 * is restricted to the systemAdmin role. The request body
 * (ITodoAppDailyStat.IRequest) supports filtering by date ranges and sorting,
 * in addition to standard pagination controls. Implementations should exclude
 * rows where deleted_at is set from normal responses to maintain an accurate
 * active view.
 *
 * This endpoint is typically used with GET
 * /todoApp/systemAdmin/dailyStats/{dailyStatId} for detail retrieval of a
 * specific daily statistic row. Administrators first narrow down dates and
 * criteria via this search, and then use the detail endpoint to inspect a
 * single row’s metrics and refresh metadata.
 *
 * @param props.connection
 * @param props.body Search filters, date-range, sorting, and pagination for
 *   daily statistics.
 * @path /todoApp/systemAdmin/dailyStats
 * @accessor api.functional.todoApp.systemAdmin.dailyStats.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search filters, date-range, sorting, and pagination for daily
     * statistics.
     */
    body: ITodoAppDailyStat.IRequest;
  };
  export type Body = ITodoAppDailyStat.IRequest;
  export type Response = IPageITodoAppDailyStat.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/dailyStats",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/systemAdmin/dailyStats";
  export const random = (): IPageITodoAppDailyStat.ISummary =>
    typia.random<IPageITodoAppDailyStat.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a single daily stat (mv_todo_app_daily_stats) by ID.
 *
 * This operation fetches one row from mv_todo_app_daily_stats by its primary
 * key id (UUID). The view stores per-day rollups with fields such as
 * stats_date, todos_created, todos_completed, active_users, completion_ratio,
 * and refreshed_at, along with created_at and updated_at metadata. The model is
 * read-only and optimized for analytics; it does not expose any private todo
 * content.
 *
 * Access is limited to users with the systemAdmin role, as daily-level activity
 * and ratios can reveal operational usage. If the id does not match an existing
 * or active row (e.g., a row with deleted_at set is excluded), the
 * implementation should respond with not found behavior according to the
 * application’s conventions.
 *
 * Use in combination with PATCH /todoApp/systemAdmin/dailyStats to discover
 * candidate rows, then GET /todoApp/systemAdmin/dailyStats/{dailyStatId} to
 * inspect a particular day’s metrics and refresh information in detail.
 *
 * @param props.connection
 * @param props.dailyStatId Identifier of the daily statistics row (UUID).
 * @path /todoApp/systemAdmin/dailyStats/:dailyStatId
 * @accessor api.functional.todoApp.systemAdmin.dailyStats.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the daily statistics row (UUID). */
    dailyStatId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppDailyStat;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/dailyStats/:dailyStatId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/dailyStats/${encodeURIComponent(props.dailyStatId ?? "null")}`;
  export const random = (): ITodoAppDailyStat =>
    typia.random<ITodoAppDailyStat>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("dailyStatId")(() => typia.assert(props.dailyStatId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
