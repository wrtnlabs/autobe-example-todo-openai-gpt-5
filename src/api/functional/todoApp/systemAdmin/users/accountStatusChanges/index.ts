import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppAccountStatusChange } from "../../../../../structures/ITodoAppAccountStatusChange";
import { IPageITodoAppAccountStatusChange } from "../../../../../structures/IPageITodoAppAccountStatusChange";

/**
 * Search account status changes for a user (todo_app_account_status_changes).
 *
 * Retrieve account status change history for a given user to support governance
 * reviews, incident investigations, and audit reporting. According to the
 * Prisma schema comments for todo_app_account_status_changes, each row captures
 * a transition of a user account’s lifecycle status with fields including:
 * target_user_id (required), optional admin_user_id when manually changed,
 * previous_status, new_status, business_reason, has_effect (indicates if a
 * stored transition actually changed state), and timestamps
 * created_at/updated_at. This endpoint exposes a read/search surface for those
 * records while enforcing access control consistent with administrative
 * oversight.
 *
 * Security considerations: Only privileged operators should access another
 * user’s status history. The authorization model therefore limits this
 * operation to system administrators, aligning with the schema’s role
 * assignment model (todo_app_systemadmins) and business requirements that
 * administrators manage account governance. Client implementations should
 * ensure that request filters are validated and that records where deleted_at
 * is populated are excluded from normal responses unless the business logic
 * explicitly permits retention queries.
 *
 * Relationship to underlying entities: Each status change references a subject
 * account via target_user_id (FK to todo_app_users) and optionally an
 * admin_user_id (FK to todo_app_users) when an administrator performed the
 * change. No private todo content is exposed. Indexes on target_user_id and
 * created_at enable efficient retrieval by user and timeline. The response
 * returns records of the todo_app_account_status_changes entity. For
 * cross-referencing administrative actions, see also historical admin
 * operations in todo_app_admin_actions.
 *
 * Validation and business rules: Requests may include filters for time windows
 * based on created_at, enumerated or free-form values for
 * previous_status/new_status (as represented in the schema), boolean filtering
 * on has_effect, and optional filtering by the administrator responsible.
 * Sorting defaults to most recent first, and pagination follows standard
 * page/size conventions defined in the IRequest DTO. This is a read-only
 * operation; it does not create or modify status changes.
 *
 * Related operations: Administrators may also review user governance artifacts
 * through other audit endpoints (e.g., admin actions and audit logs) to build a
 * complete timeline. For account-level summaries, admins would typically first
 * locate the user (outside the scope of this operation) and then drill into
 * status transitions using this route.
 *
 * Expected behavior and errors: If the specified userId is not a valid UUID or
 * does not correspond to an existing user, the service should return a
 * validation or not-found error. Authorization failures should return an
 * appropriate access denial. When filters produce no matches, the response
 * returns an empty page with pagination metadata.
 *
 * @param props.connection
 * @param props.userId Target user’s ID whose account status changes are being
 *   queried
 * @param props.body Filter, sort, and pagination criteria for querying account
 *   status changes
 * @path /todoApp/systemAdmin/users/:userId/accountStatusChanges
 * @accessor api.functional.todoApp.systemAdmin.users.accountStatusChanges.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Target user’s ID whose account status changes are being queried */
    userId: string & tags.Format<"uuid">;

    /**
     * Filter, sort, and pagination criteria for querying account status
     * changes
     */
    body: ITodoAppAccountStatusChange.IRequest;
  };
  export type Body = ITodoAppAccountStatusChange.IRequest;
  export type Response = IPageITodoAppAccountStatusChange;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/users/:userId/accountStatusChanges",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/systemAdmin/users/${encodeURIComponent(props.userId ?? "null")}/accountStatusChanges`;
  export const random = (): IPageITodoAppAccountStatusChange =>
    typia.random<IPageITodoAppAccountStatusChange>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
