import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppSystemAdmin } from "../../../../../structures/ITodoAppSystemAdmin";
import { IPageITodoAppSystemAdmin } from "../../../../../structures/IPageITodoAppSystemAdmin";

/**
 * Search and paginate systemAdmin role assignment history for a user
 * (todo_app_systemadmins).
 *
 * Retrieve a filtered, paginated list of systemAdmin role assignment history
 * records for the specified user. The Prisma schema for todo_app_systemadmins
 * describes a history of grant/revoke events for governance audits, not
 * user-editable and managed by administrators. Fields include id (UUID),
 * todo_app_user_id (FK to todo_app_users.id), granted_at, optional revoked_at
 * for end of assignment, created_at, updated_at, and a logical deletion
 * timestamp in deleted_at used for retention workflows.
 *
 * Security and permissions: Access is restricted to administrative users. The
 * provider must verify that the caller has systemAdmin privileges and enforce
 * isolation by constraining results to todo_app_user_id = {userId}.
 * Non-administrative users must not be allowed to enumerate another user’s
 * administrative role history.
 *
 * Database behavior and filters: Queries commonly order by granted_at
 * descending. Filters may target current active assignments (revoked_at is
 * null), or limit by granted_at/revoked_at date ranges to support audit scope.
 * Implementations typically exclude logically removed rows where deleted_at is
 * set. The schema’s indexes on (todo_app_user_id, granted_at) and (granted_at,
 * created_at) facilitate these access patterns.
 *
 * Validation and business logic: The endpoint is read-only and must not mutate
 * role assignments. The request body supports pagination (page, pageSize),
 * sorting (e.g., by granted_at), and filters like active-only or bounded time
 * windows.
 *
 * Related operations: Use GET /users/{userId}/systemAdmins/{systemAdminId} to
 * retrieve a single assignment record. Providers may pre-validate the parent
 * user exists via a user retrieval endpoint. Handle authorization errors for
 * insufficient privileges and return empty results when no matching records
 * exist.
 *
 * @param props.connection
 * @param props.userId Owner user’s ID whose systemAdmin role history is being
 *   listed.
 * @param props.body Search, filter, and pagination parameters for listing
 *   systemAdmin role assignments.
 * @path /todoApp/systemAdmin/users/:userId/systemAdmins
 * @accessor api.functional.todoApp.systemAdmin.users.systemAdmins.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Owner user’s ID whose systemAdmin role history is being listed. */
    userId: string & tags.Format<"uuid">;

    /**
     * Search, filter, and pagination parameters for listing systemAdmin
     * role assignments.
     */
    body: ITodoAppSystemAdmin.IRequest;
  };
  export type Body = ITodoAppSystemAdmin.IRequest;
  export type Response = IPageITodoAppSystemAdmin.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/users/:userId/systemAdmins",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/systemAdmin/users/${encodeURIComponent(props.userId ?? "null")}/systemAdmins`;
  export const random = (): IPageITodoAppSystemAdmin.ISummary =>
    typia.random<IPageITodoAppSystemAdmin.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get one systemAdmin role assignment record for a user
 * (todo_app_systemadmins).
 *
 * Return a single historical systemAdmin role assignment entry from
 * todo_app_systemadmins for the specified user. Per the schema, this table
 * stores grant/revoke events over time for governance audits, is not
 * user-editable, and is managed by administrators. Fields include id (UUID),
 * todo_app_user_id (FK to todo_app_users.id), granted_at, optional revoked_at,
 * created_at, updated_at, and a logical deletion timestamp deleted_at managed
 * for retention.
 *
 * Security: Only administrative callers may access this detail view. The
 * provider must ensure the caller has systemAdmin privileges and that the
 * requested record’s todo_app_user_id equals {userId}. If the record does not
 * belong to the specified user or does not exist, respond with not-found
 * semantics without leaking cross-user details.
 *
 * Behavior and errors: This is a read-only operation. Implementations generally
 * exclude logically removed rows where deleted_at is set. Validate UUID formats
 * for both path parameters. For collection retrieval, use PATCH
 * /users/{userId}/systemAdmins.
 *
 * This endpoint is intended for administrative audits and governance workflows
 * that require precise visibility into when systemAdmin rights were granted or
 * revoked for a given account.
 *
 * @param props.connection
 * @param props.userId Owner user’s ID whose systemAdmin assignment record is
 *   queried.
 * @param props.systemAdminId Identifier of the systemAdmin role assignment
 *   record.
 * @path /todoApp/systemAdmin/users/:userId/systemAdmins/:systemAdminId
 * @accessor api.functional.todoApp.systemAdmin.users.systemAdmins.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Owner user’s ID whose systemAdmin assignment record is queried. */
    userId: string & tags.Format<"uuid">;

    /** Identifier of the systemAdmin role assignment record. */
    systemAdminId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppSystemAdmin;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/users/:userId/systemAdmins/:systemAdminId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/users/${encodeURIComponent(props.userId ?? "null")}/systemAdmins/${encodeURIComponent(props.systemAdminId ?? "null")}`;
  export const random = (): ITodoAppSystemAdmin =>
    typia.random<ITodoAppSystemAdmin>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("systemAdminId")(() => typia.assert(props.systemAdminId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
