import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppGuestVisitor } from "../../../../../structures/ITodoAppGuestVisitor";
import { IPageITodoAppGuestVisitor } from "../../../../../structures/IPageITodoAppGuestVisitor";

/**
 * Search and list guestVisitor assignments (todo_app_guestvisitors) for a user
 * with pagination and filters.
 *
 * Retrieve a filtered, paginated list of guestVisitor role assignments for the
 * specified userId from the todo_app_guestvisitors table. According to the
 * Prisma schema description, this model stores multiple historical records per
 * user with granted_at, optional revoked_at, and system-managed
 * created_at/updated_at/deleted_at. The user reference is via todo_app_user_id,
 * enabling queries ordered by granted_at and filtered for current membership
 * where revoked_at IS NULL.
 *
 * Security considerations: Role assignment history is governance data and not
 * user-editable. Access should be restricted to system administrators
 * responsible for audits and operations. Accordingly, the authorization role is
 * systemAdmin. The endpoint is strictly read-only and should implement
 * appropriate rate limits for list operations.
 *
 * Relationships and fields: Each record references todo_app_users through
 * todo_app_user_id. The key fields include granted_at (when the guestVisitor
 * role was granted) and revoked_at (null when still active). No write
 * operations are provided here, aligning with the business rule that role
 * assignments are managed by governance workflows.
 *
 * Query behavior and validation: The request body
 * (ITodoAppGuestVisitor.IRequest) may include pagination parameters (page,
 * pageSize within 1–100), optional filters (e.g., activeOnly—records where
 * revoked_at is null), time range filters on granted_at or revoked_at, and
 * sorting options (e.g., granted_at desc). The implementation should validate
 * page bounds and permitted sort fields, and default sorting by granted_at
 * descending if unspecified.
 *
 * Related operations: Use GET /users/{userId}/guestVisitors/{guestVisitorId} to
 * retrieve a single assignment record by its identifier. No creation, update,
 * or deletion operations are exposed in alignment with the schema’s
 * audit/history intent.
 *
 * Error handling: Return validation errors for unsupported sort fields or
 * out-of-range pagination. If the specified userId does not map to a known
 * user, handle the response generically to avoid disclosing details to
 * unauthorized parties, with explicit checks tied to the administrator role.
 *
 * @param props.connection
 * @param props.userId Target user’s ID whose guestVisitor assignments will be
 *   listed.
 * @param props.body Search, filter, sort, and pagination parameters for
 *   guestVisitor history.
 * @path /todoApp/systemAdmin/users/:userId/guestVisitors
 * @accessor api.functional.todoApp.systemAdmin.users.guestVisitors.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Target user’s ID whose guestVisitor assignments will be listed. */
    userId: string & tags.Format<"uuid">;

    /**
     * Search, filter, sort, and pagination parameters for guestVisitor
     * history.
     */
    body: ITodoAppGuestVisitor.IRequest;
  };
  export type Body = ITodoAppGuestVisitor.IRequest;
  export type Response = IPageITodoAppGuestVisitor.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/users/:userId/guestVisitors",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/systemAdmin/users/${encodeURIComponent(props.userId ?? "null")}/guestVisitors`;
  export const random = (): IPageITodoAppGuestVisitor.ISummary =>
    typia.random<IPageITodoAppGuestVisitor.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details of a guestVisitor assignment (todo_app_guestvisitors) for a
 * specific user.
 *
 * Return details of one guestVisitor role assignment from
 * todo_app_guestvisitors using the composite path (userId, guestVisitorId). The
 * Prisma model records role assignment events with fields such as granted_at
 * (grant time), optional revoked_at (revoke time), and system-managed
 * timestamps (created_at, updated_at, deleted_at). The record references the
 * owning user via todo_app_user_id. Although the path scopes by userId, the
 * implementation should still validate that the fetched record’s
 * todo_app_user_id matches the path userId to prevent cross-tenant leakage.
 *
 * Security and permissions: Access is restricted to administrators responsible
 * for governance reviews. Authorization is set to systemAdmin. No modifications
 * are permitted through this endpoint, and it should not reveal data for
 * records that do not belong to the specified user.
 *
 * Entity relationships and validation: Ensure the record’s todo_app_user_id
 * equals the path userId before returning it. The response includes all
 * relevant fields appropriate for administrative review, such as granted_at and
 * revoked_at, but excludes any secret or non-existent attributes as per schema.
 * The model supports historical queries where revoked_at may be null for
 * currently active assignments.
 *
 * Related operations: For broader history and filtering, use PATCH
 * /users/{userId}/guestVisitors. There are no write endpoints for this model
 * because role assignments are managed via governance processes.
 *
 * Error handling: Return not found if guestVisitorId does not exist or does not
 * belong to the specified userId. Handle authorization failures explicitly for
 * non-admin callers.
 *
 * @param props.connection
 * @param props.userId Owner user’s ID for scoping the role assignment.
 * @param props.guestVisitorId Identifier of the guestVisitor assignment record
 *   to retrieve.
 * @path /todoApp/systemAdmin/users/:userId/guestVisitors/:guestVisitorId
 * @accessor api.functional.todoApp.systemAdmin.users.guestVisitors.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Owner user’s ID for scoping the role assignment. */
    userId: string & tags.Format<"uuid">;

    /** Identifier of the guestVisitor assignment record to retrieve. */
    guestVisitorId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppGuestVisitor;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/users/:userId/guestVisitors/:guestVisitorId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/users/${encodeURIComponent(props.userId ?? "null")}/guestVisitors/${encodeURIComponent(props.guestVisitorId ?? "null")}`;
  export const random = (): ITodoAppGuestVisitor =>
    typia.random<ITodoAppGuestVisitor>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.param("guestVisitorId")(() => typia.assert(props.guestVisitorId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
