import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppUser } from "../../../../structures/ITodoAppUser";
import { IPageITodoAppUser } from "../../../../structures/IPageITodoAppUser";
export * as guestVisitors from "./guestVisitors/index";
export * as todoUsers from "./todoUsers/index";
export * as systemAdmins from "./systemAdmins/index";
export * as auditLogs from "./auditLogs/index";
export * as adminActions from "./adminActions/index";
export * as accountStatusChanges from "./accountStatusChanges/index";

/**
 * Search and paginate users (todo_app_users) for administration.
 *
 * Retrieve a filtered, paginated list of user accounts. The underlying Prisma
 * model todo_app_users stores core authentication/account fields: id (UUID),
 * email (unique), password_hash, status (e.g., pending_verification, active,
 * suspended, deactivated), email_verified, verified_at, last_login_at,
 * created_at, updated_at, and deleted_at. As described in the schema comments,
 * this table is central to access control and privacy boundaries and is the
 * parent for related profile and preference records.
 *
 * Security: Access to system-wide user listings must be restricted to the
 * systemAdmin role. This endpoint is for governance and operational views, not
 * for exposing private todo content. Summary response models MUST explicitly
 * exclude sensitive fields such as password_hash and any token-related values.
 * Business logic should ensure that logically removed accounts (deleted_at set)
 * are excluded unless explicitly requested by an administrative filter.
 *
 * Filtering and sorting: Implement flexible criteria aligned to the
 * schemaâ€”email substring search using trigram indexes, exact or set-based
 * status filtering, booleans like email_verified, and time-range filters for
 * created_at and last_login_at. The operation should support pagination (page,
 * pageSize) with defaults aligned to business policy (commonly 20) and sorting
 * by created_at (default desc) or other permissible columns. Validation should
 * enforce reasonable page size bounds and ignore unsupported fields.
 *
 * Related operations include retrieving a single user by ID for detailed
 * administrative review or updating account status via separate admin
 * workflows. On errors, return clear messages for invalid filters, out-of-range
 * pagination, or missing permissions.
 *
 * @param props.connection
 * @param props.body Search, filter, sort, and pagination parameters for users
 * @path /todoApp/systemAdmin/users
 * @accessor api.functional.todoApp.systemAdmin.users.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filter, sort, and pagination parameters for users */
    body: ITodoAppUser.IRequest;
  };
  export type Body = ITodoAppUser.IRequest;
  export type Response = IPageITodoAppUser.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/users",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/systemAdmin/users";
  export const random = (): IPageITodoAppUser.ISummary =>
    typia.random<IPageITodoAppUser.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a user (todo_app_users) by ID.
 *
 * Get detailed information about a user account identified by UUID. The Prisma
 * table todo_app_users contains authentication-centric fields: email,
 * password_hash (never exposed in responses), status, email_verified,
 * verified_at, last_login_at, created_at, updated_at, and deleted_at. This
 * endpoint should return a representation that excludes sensitive secrets while
 * capturing business-relevant fields like status and verification timestamps.
 *
 * Security: Only systemAdmin actors should be permitted to retrieve arbitrary
 * user records. Implementations must ensure that ownership checks are applied
 * for non-admin contexts (not applicable to this administrative endpoint). If
 * the target record has been logically removed (deleted_at set), return a
 * not-found outcome to avoid exposing retired identities.
 *
 * Relations and behavior: While the main entity is todo_app_users,
 * implementations may optionally enrich with adjacent information such as user
 * profile or preferences in read models; however, the canonical source remains
 * the users table. On errors, provide not-found for unknown ids, and avoid
 * disclosing whether a deleted account existed historically.
 *
 * @param props.connection
 * @param props.userId User's UUID to retrieve
 * @path /todoApp/systemAdmin/users/:userId
 * @accessor api.functional.todoApp.systemAdmin.users.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** User's UUID to retrieve */
    userId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppUser;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/users/:userId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/users/${encodeURIComponent(props.userId ?? "null")}`;
  export const random = (): ITodoAppUser => typia.random<ITodoAppUser>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
