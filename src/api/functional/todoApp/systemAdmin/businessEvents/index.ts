import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppBusinessEvent } from "../../../../structures/ITodoAppBusinessEvent";
import { IPageITodoAppBusinessEvent } from "../../../../structures/IPageITodoAppBusinessEvent";

/**
 * Search and paginate business events (todo_app_business_events) with filters
 * and sorting.
 *
 * Purpose and overview: The todo_app_business_events model is described as an
 * "Append-only business event log capturing user-facing domain events across
 * todoApp." Each record references a classification in todo_app_event_types and
 * can optionally reference an actor (todo_app_users), a target todo
 * (todo_app_todos), and a session (todo_app_sessions). This endpoint searches
 * that log with advanced filters to support governance, incident investigation,
 * and operational analytics.
 *
 * Security and permissions: Business event logs often contain sensitive
 * metadata (IP, user agent, and actor linkage). Restrict access to systemAdmin
 * role. End users should not be able to read these records.
 *
 * Relationship to underlying entities: Each event has foreign keys
 * todo_app_event_type_id, todo_app_user_id, todo_app_todo_id, and
 * todo_app_session_id. Queries commonly filter by these, by occurred_at ranges,
 * and by source system. The schema defines helpful indexes, including GIN
 * trigram indexes on message for efficient substring search and indexes on
 * occurred_at and various foreign keys for time-window analytics.
 *
 * Validation rules and business logic: The request body
 * (ITodoAppBusinessEvent.IRequest) should support pagination (page, pageSize),
 * sorting (e.g., by occurred_at desc), and filter criteria such as
 * eventTypeId(s), actor userId(s), target todoId(s), sessionId(s), source, ip,
 * and time windows (occurred_at from/to). Free-text search should apply
 * case-insensitive substring matching against message, consistent with schema’s
 * trigram index. Implement rate limiting per policy to protect the service.
 *
 * Related operations: Use GET /businessEvents/{businessEventId} to retrieve a
 * single event’s full details after discovering it in search results.
 * Administrators may also consult daily counters or KPI materialized views
 * through separate analytical endpoints (not defined here).
 *
 * Expected behavior and error handling: On success, return
 * IPageITodoAppBusinessEvent containing pagination metadata and an array of
 * ITodoAppBusinessEvent records. Return validation errors for malformed UUIDs,
 * out-of-range pagination values, or unsupported sort keys. Ensure consistent
 * timezone handling (occurred_at is timestamptz).
 *
 * @param props.connection
 * @param props.body Search criteria, pagination, and sorting for business
 *   events
 * @path /todoApp/systemAdmin/businessEvents
 * @accessor api.functional.todoApp.systemAdmin.businessEvents.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search criteria, pagination, and sorting for business events */
    body: ITodoAppBusinessEvent.IRequest;
  };
  export type Body = ITodoAppBusinessEvent.IRequest;
  export type Response = IPageITodoAppBusinessEvent;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/businessEvents",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/systemAdmin/businessEvents";
  export const random = (): IPageITodoAppBusinessEvent =>
    typia.random<IPageITodoAppBusinessEvent>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single business event (todo_app_business_events) by ID.
 *
 * Purpose and overview: This GET operation retrieves a single append-only
 * record from todo_app_business_events, the schema that captures domain events
 * with references to event types, users, todos, and sessions. It is used when
 * an administrator needs to inspect a specific occurrence identified via search
 * or from a related workflow.
 *
 * Security and permissions: Access should be limited to systemAdmin role due to
 * potentially sensitive content such as IP addresses and user agent strings and
 * the association to specific user identities.
 *
 * Relationship to underlying entities: The record may reference
 * todo_app_event_types (todo_app_event_type_id), todo_app_users
 * (todo_app_user_id), todo_app_todos (todo_app_todo_id), and todo_app_sessions
 * (todo_app_session_id). These relationships enable cross-navigation in
 * administrative consoles and support traceability.
 *
 * Validation rules and business logic: Validate businessEventId as a UUID and
 * ensure the target exists. As events are append-only, there is no mutation or
 * deletion through this endpoint. Ensure consistent timezone presentation for
 * occurred_at (timestamptz) in client applications.
 *
 * Related operations: Combine with the PATCH /businessEvents search endpoint
 * for discovery. Additional analytical endpoints such as daily counters and KPI
 * views are typically used for trend analysis (not part of this API set).
 *
 * Expected behavior and error handling: Return the ITodoAppBusinessEvent record
 * on success. Return not-found for unknown identifiers and authorization errors
 * for insufficient privileges. Avoid exposing unrelated personal data in error
 * details.
 *
 * @param props.connection
 * @param props.businessEventId Unique identifier of the business event to
 *   retrieve
 * @path /todoApp/systemAdmin/businessEvents/:businessEventId
 * @accessor api.functional.todoApp.systemAdmin.businessEvents.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the business event to retrieve */
    businessEventId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppBusinessEvent;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/businessEvents/:businessEventId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/businessEvents/${encodeURIComponent(props.businessEventId ?? "null")}`;
  export const random = (): ITodoAppBusinessEvent =>
    typia.random<ITodoAppBusinessEvent>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("businessEventId")(() =>
        typia.assert(props.businessEventId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
