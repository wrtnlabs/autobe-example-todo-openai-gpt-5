import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppEventType } from "../../../../structures/ITodoAppEventType";
import { IPageITodoAppEventType } from "../../../../structures/IPageITodoAppEventType";

/**
 * Create a new event type (todo_app_event_types).
 *
 * Insert a new taxonomy entry into todo_app_event_types to classify
 * business-domain events across the system. Fields include: code (unique,
 * stable identifier such as "todo.created"), name (human-readable), optional
 * description for administrative notes, active (boolean) to indicate whether
 * the type is currently in use, and timestamps created_at/updated_at managed by
 * the system.
 *
 * Only system administrators are authorized to create new event types to
 * maintain governance consistency. Providers should validate that the code is
 * globally unique (per the schema's @@unique([code]) constraint) and that
 * required fields (code, name, active) are present and well-formed. Optional
 * description may be included for context.
 *
 * On success, the operation returns the created event type record. Related
 * operations include PATCH /eventTypes for searching and listing, GET
 * /eventTypes/{eventTypeId} for detail retrieval, and a separate update
 * endpoint (not listed here) to modify an existing record's attributes or
 * toggle the active flag.
 *
 * @param props.connection
 * @param props.body Event type creation payload (code, name, optional
 *   description, active)
 * @path /todoApp/systemAdmin/eventTypes
 * @accessor api.functional.todoApp.systemAdmin.eventTypes.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Event type creation payload (code, name, optional description,
     * active)
     */
    body: ITodoAppEventType.ICreate;
  };
  export type Body = ITodoAppEventType.ICreate;
  export type Response = ITodoAppEventType;

  export const METADATA = {
    method: "POST",
    path: "/todoApp/systemAdmin/eventTypes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/systemAdmin/eventTypes";
  export const random = (): ITodoAppEventType =>
    typia.random<ITodoAppEventType>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and paginate event type taxonomy (todo_app_event_types).
 *
 * Retrieve a filtered, paginated collection of event type definitions from the
 * todo_app_event_types table. This table classifies business events with fields
 * including code (globally unique), name, optional description, and an active
 * flag indicating whether the type is currently in use. Timestamps created_at
 * and updated_at support audit and ordering use-cases.
 *
 * This operation targets administrative use. Security considerations require
 * system administrator privileges to view and manage the taxonomy
 * comprehensively. While the underlying data is not user-private, centralizing
 * access in admin tooling avoids accidental operational drift.
 *
 * The request body allows advanced filters: by active status, time ranges on
 * created_at, free-text search across code/name/description, and sort controls
 * (e.g., created_at desc by default, or code asc). Pagination parameters (page,
 * pageSize) must be supported, aligning with business expectations (typical
 * default 20; allowed 1–100). The response returns a page container with
 * summary projections optimized for list views.
 *
 * Error handling includes validation of pagination bounds, unsupported sort
 * keys, and malformed search inputs. Related operations include POST
 * /eventTypes to add a new type, GET /eventTypes/{eventTypeId} to view details,
 * and administrative toggling via update endpoints (not part of this list).
 *
 * @param props.connection
 * @param props.body Search, filter, sort, and pagination parameters for event
 *   types
 * @path /todoApp/systemAdmin/eventTypes
 * @accessor api.functional.todoApp.systemAdmin.eventTypes.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filter, sort, and pagination parameters for event types */
    body: ITodoAppEventType.IRequest;
  };
  export type Body = ITodoAppEventType.IRequest;
  export type Response = IPageITodoAppEventType.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/eventTypes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/systemAdmin/eventTypes";
  export const random = (): IPageITodoAppEventType.ISummary =>
    typia.random<IPageITodoAppEventType.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get event type details (todo_app_event_types) by ID.
 *
 * Retrieve a detailed event type definition from the todo_app_event_types model
 * using its primary key. The schema provides: id, code (unique and stable
 * machine-readable identifier), name (human-readable), optional description,
 * active flag indicating enablement, and timestamps created_at and updated_at.
 *
 * This operation is typically used by administrative consoles to inspect a
 * specific taxonomy entry selected from a list. Security policy limits access
 * to system administrators managing event classification.
 *
 * Validation rules include confirming the identifier corresponds to an existing
 * row. If the identifier is unknown, the provider should return a not-found
 * style outcome without exposing unrelated data. This operation complements the
 * list/search endpoint (PATCH /eventTypes) and the creation endpoint (POST
 * /eventTypes), and would typically be paired with an update operation to
 * change name, description, or active status when permitted by governance
 * policies.
 *
 * @param props.connection
 * @param props.eventTypeId Target event type identifier
 *   (todo_app_event_types.id)
 * @path /todoApp/systemAdmin/eventTypes/:eventTypeId
 * @accessor api.functional.todoApp.systemAdmin.eventTypes.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Target event type identifier (todo_app_event_types.id) */
    eventTypeId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppEventType;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/eventTypes/:eventTypeId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/eventTypes/${encodeURIComponent(props.eventTypeId ?? "null")}`;
  export const random = (): ITodoAppEventType =>
    typia.random<ITodoAppEventType>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("eventTypeId")(() => typia.assert(props.eventTypeId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a single event type (todo_app_event_types) by ID.
 *
 * Purpose and overview: This operation updates a single record in the
 * todo_app_event_types table, which the schema describes as the “Business event
 * taxonomy for todoApp. Each record defines a stable code and human-readable
 * name for a class of events (e.g., "todo.created", "todo.completed").”
 * Administrators use this endpoint to maintain display names, descriptions, and
 * enablement flags as the product evolves, without rewriting historical logs.
 *
 * Security and permissions: Only privileged users should mutate the event
 * taxonomy. Enforce authorization for systemAdmin role. Normal end users
 * (todoUser) and unauthenticated visitors (guestVisitor) are not permitted to
 * update event types.
 *
 * Relationship to underlying entities: The todo_app_business_events model
 * references todo_app_event_types through todo_app_event_type_id for
 * classification, and derived snapshots in todo_app_event_counters_daily and
 * todo_app_aggregated_metrics also depend on these definitions for grouping and
 * reporting. Updates to attributes like name, description, or active influence
 * how future events are emitted and presented, but should not change historical
 * rows already captured.
 *
 * Validation rules and business logic: The prisma model enforces a unique index
 * on code (@@unique([code])). If the update attempts to change code, it must
 * remain globally unique and stable; in many deployments, code changes may be
 * disallowed by policy to preserve stable identifiers. The active boolean
 * indicates whether the type is enabled for emission; toggling it to false
 * should prevent new events of that type from being produced by upstream
 * services while leaving existing data intact. Required fields include name and
 * code; optional fields include description. Ensure the eventTypeId is a
 * well-formed UUID and corresponds to an existing record (the model has no
 * deleted_at column).
 *
 * Related operations: Administrators may use GET retrieval or list/search
 * operations for event types (not defined here) to find the appropriate
 * identifier. For analytics and audit, related read-only endpoints on business
 * events and counters reflect the impact of changes to event types. This update
 * operation pairs with the erase endpoint on the same path when a type must be
 * removed.
 *
 * Expected behavior and error handling: The service returns the updated
 * ITodoAppEventType on success. Return validation errors for uniqueness
 * conflicts (code) or missing required fields. Return authorization errors for
 * insufficient privileges and not-found errors when eventTypeId does not exist.
 * Concurrency control should detect lost updates using updated_at semantics
 * implemented in service logic.
 *
 * @param props.connection
 * @param props.eventTypeId Unique identifier of the event type to update
 * @param props.body Fields to update for the event type
 * @path /todoApp/systemAdmin/eventTypes/:eventTypeId
 * @accessor api.functional.todoApp.systemAdmin.eventTypes.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the event type to update */
    eventTypeId: string & tags.Format<"uuid">;

    /** Fields to update for the event type */
    body: ITodoAppEventType.IUpdate;
  };
  export type Body = ITodoAppEventType.IUpdate;
  export type Response = ITodoAppEventType;

  export const METADATA = {
    method: "PUT",
    path: "/todoApp/systemAdmin/eventTypes/:eventTypeId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/systemAdmin/eventTypes/${encodeURIComponent(props.eventTypeId ?? "null")}`;
  export const random = (): ITodoAppEventType =>
    typia.random<ITodoAppEventType>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("eventTypeId")(() => typia.assert(props.eventTypeId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Erase an event type (todo_app_event_types) by ID; permanently removes the
 * record.
 *
 * Purpose and overview: This operation deletes a record from
 * todo_app_event_types, the model described as the "Business event taxonomy for
 * todoApp." Removing an event type should be rare and reserved for governance
 * scenarios (e.g., erroneous creation during testing or decommissioning a type
 * that must not exist).
 *
 * Security and permissions: Only system administrators are allowed to perform
 * deletion. This is a sensitive operation because the event taxonomy underpins
 * auditing and analytics classification.
 *
 * Relationship to underlying database entities: todo_app_business_events
 * references todo_app_event_types via todo_app_event_type_id. In the given
 * Prisma schema, the eventType relation uses onDelete: Cascade, which can
 * propagate deletion to dependent business event rows. To preserve
 * audit/analytics history, implement a service-layer guard to block deletion
 * when dependent events exist unless an explicit governed override is provided;
 * otherwise prefer deactivation (active=false) via the update endpoint.
 *
 * Validation rules and business logic: The path parameter eventTypeId must be a
 * UUID corresponding to an existing row. Since the model has no deleted_at
 * column, deletion removes the row completely. If business policy requires
 * retention of historical records, administrators should disable the type
 * instead of deleting it.
 *
 * Related operations: Prefer the update endpoint on the same path for
 * non-destructive changes such as toggling active or editing
 * names/descriptions. Use read-only business event endpoints to verify the
 * impact of changes to the taxonomy.
 *
 * Expected behavior and error handling: Return success with no response body
 * when deletion completes. Return not-found for unknown eventTypeId and
 * authorization errors for insufficient permissions. If application-level
 * safeguards prevent deletion due to existing dependencies, return a conflict
 * or policy-violation response with remediation guidance.
 *
 * @param props.connection
 * @param props.eventTypeId Unique identifier of the event type to remove
 * @path /todoApp/systemAdmin/eventTypes/:eventTypeId
 * @accessor api.functional.todoApp.systemAdmin.eventTypes.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the event type to remove */
    eventTypeId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoApp/systemAdmin/eventTypes/:eventTypeId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/eventTypes/${encodeURIComponent(props.eventTypeId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("eventTypeId")(() => typia.assert(props.eventTypeId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
