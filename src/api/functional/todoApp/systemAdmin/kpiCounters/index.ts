import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppKpiCounter } from "../../../../structures/ITodoAppKpiCounter";
import { IPageITodoAppKpiCounter } from "../../../../structures/IPageITodoAppKpiCounter";

/**
 * Search KPI window snapshots from Prisma table mv_todo_app_kpi_counters
 * (admin-only).
 *
 * Retrieve KPI counter windows for administrative insight from the Prisma table
 * mv_todo_app_kpi_counters. According to the schema comments, this materialized
 * view contains read-optimized, denormalized indicators over sliding or fixed
 * windows with fields including window_start, window_end, todos_created,
 * todos_completed, active_users, and optionally avg_time_to_complete_hours and
 * p95_completion_time_hours. These rows are refreshed from base sources like
 * todo_app_aggregated_metrics and are designed for monitoring dashboards rather
 * than transactional use.
 *
 * Security and authorization align with the business requirements stating that
 * aggregated service metrics are accessible to administrators, not routine end
 * users. Therefore, only systemAdmin should invoke this endpoint. The payload
 * must not expose private Todo text; only numeric counts and high-level
 * indicators are returned. Because the underlying table is read-only, no
 * creation, update, or deletion is allowed through this API.
 *
 * From a data relationship perspective, mv_todo_app_kpi_counters is derived
 * from non-PII sources such as aggregated metrics and event streams, preserving
 * historical KPI snapshots. Typical validation includes ensuring a valid
 * chronological range (window_start < window_end) when provided, and limiting
 * page size to administrator-configured bounds. Errors are returned for invalid
 * time ranges or unsupported sort keys. Related endpoints include the detail
 * retrieval GET /todoApp/systemAdmin/kpiCounters/{kpiCounterId} for fetching a
 * single snapshot row by its identifier.
 *
 * @param props.connection
 * @param props.body Search, filter, sort, and pagination parameters for KPI
 *   window snapshots (e.g., window range, sort, page).
 * @path /todoApp/systemAdmin/kpiCounters
 * @accessor api.functional.todoApp.systemAdmin.kpiCounters.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filter, sort, and pagination parameters for KPI window
     * snapshots (e.g., window range, sort, page).
     */
    body: ITodoAppKpiCounter.IRequest;
  };
  export type Body = ITodoAppKpiCounter.IRequest;
  export type Response = IPageITodoAppKpiCounter;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/kpiCounters",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoApp/systemAdmin/kpiCounters";
  export const random = (): IPageITodoAppKpiCounter =>
    typia.random<IPageITodoAppKpiCounter>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single KPI window snapshot from Prisma table mv_todo_app_kpi_counters
 * by ID (admin-only).
 *
 * Return a single KPI counter window row from mv_todo_app_kpi_counters by its
 * identifier. Per the Prisma schema, each row captures metrics for a defined
 * window with fields like window_start, window_end, todos_created,
 * todos_completed, active_users, and optional latency aggregates. This endpoint
 * is intended for administrative review where a specific KPI record needs
 * inspection.
 *
 * Access is restricted to systemAdmin per the business requirements for
 * aggregated service metrics visibility. The endpoint is purely read-only
 * against the materialized view and does not alter any underlying data.
 * Expected validation includes checking that the provided identifier is a valid
 * UUID and exists. If no row is found for the given id, the API should return a
 * not-found response without exposing internal implementation details.
 *
 * This detail retrieval complements the collection search at PATCH
 * /todoApp/systemAdmin/kpiCounters, allowing dashboards to drill into a single
 * KPI window when needed.
 *
 * @param props.connection
 * @param props.kpiCounterId Identifier of the KPI window snapshot row to
 *   retrieve.
 * @path /todoApp/systemAdmin/kpiCounters/:kpiCounterId
 * @accessor api.functional.todoApp.systemAdmin.kpiCounters.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the KPI window snapshot row to retrieve. */
    kpiCounterId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppKpiCounter;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/kpiCounters/:kpiCounterId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/kpiCounters/${encodeURIComponent(props.kpiCounterId ?? "null")}`;
  export const random = (): ITodoAppKpiCounter =>
    typia.random<ITodoAppKpiCounter>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("kpiCounterId")(() => typia.assert(props.kpiCounterId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
