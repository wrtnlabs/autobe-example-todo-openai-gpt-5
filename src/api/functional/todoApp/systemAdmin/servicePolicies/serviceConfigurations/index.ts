import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppServiceConfiguration } from "../../../../../structures/ITodoAppServiceConfiguration";
import { IPageITodoAppServiceConfiguration } from "../../../../../structures/IPageITodoAppServiceConfiguration";

/**
 * Create a configuration (todo_app_service_configurations) under a service
 * policy.
 *
 * Create a configuration entry under the identified service policy. The
 * underlying table todo_app_service_configurations stores administrative
 * settings with fields including namespace, environment (optional), key, value,
 * value_type, is_secret, description, active, effective_from, effective_to,
 * created_at, updated_at, and deleted_at. According to the schema comments,
 * values are raw strings interpreted by value_type (e.g., "string", "int",
 * "double", "boolean", "datetime", "uri"), and may be redacted when
 * is_secret=true. The configuration is optionally tied to a governing policy
 * via todo_app_service_policy_id, which in this endpoint is supplied by the
 * path parameter.
 *
 * Security and permissions: Only administrative actors are expected to create
 * configurations. Business logic should validate that the caller holds
 * sufficient privileges (systemAdmin) and apply redaction for secrets in logs
 * or responses when is_secret=true. The operation must also honor
 * effective_from/effective_to semantics and active flag handling described in
 * the model documentation.
 *
 * Database relationships and constraints: The new row references
 * todo_app_service_policies (foreign key todo_app_service_policy_id) and can
 * reference the actor user via todo_app_user_id depending on implementation. A
 * unique constraint on (namespace, key, environment) prevents duplicates; the
 * application should handle conflicts gracefully and surface clear guidance.
 * GIN trigram indexes on key/description and composite indexes on
 * active/namespace/environment support search and filtering in related read
 * endpoints.
 *
 * Validation and error handling: Ensure namespace and key are provided and
 * conform to business naming rules. Confirm value_type is a supported hint and
 * that value is compatible with it at validation time when applicable. On
 * uniqueness conflicts, return a descriptive message indicating the existing
 * combination of namespace/key/environment. Sensitive values should never be
 * echoed in logs when is_secret=true. Any date-times for
 * effective_from/effective_to must be valid RFC 3339 timestamps.
 *
 * @param props.connection
 * @param props.policyId Target policy ID to attach the configuration to
 * @param props.body Configuration creation payload scoped to the specified
 *   policy
 * @path /todoApp/systemAdmin/servicePolicies/:policyId/serviceConfigurations
 * @accessor api.functional.todoApp.systemAdmin.servicePolicies.serviceConfigurations.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Target policy ID to attach the configuration to */
    policyId: string & tags.Format<"uuid">;

    /** Configuration creation payload scoped to the specified policy */
    body: ITodoAppServiceConfiguration.ICreate;
  };
  export type Body = ITodoAppServiceConfiguration.ICreate;
  export type Response = ITodoAppServiceConfiguration;

  export const METADATA = {
    method: "POST",
    path: "/todoApp/systemAdmin/servicePolicies/:policyId/serviceConfigurations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/systemAdmin/servicePolicies/${encodeURIComponent(props.policyId ?? "null")}/serviceConfigurations`;
  export const random = (): ITodoAppServiceConfiguration =>
    typia.random<ITodoAppServiceConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("policyId")(() => typia.assert(props.policyId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/search service configurations (todo_app_service_configurations) for a
 * policy.
 *
 * This endpoint lists configurations in todo_app_service_configurations under a
 * given policy. The model stores namespace, optional environment, key (unique
 * within namespace/environment), value, value_type, is_secret, description,
 * active, effective_from, effective_to, and temporal fields including
 * created_at, updated_at, and deleted_at. The request targets only records
 * where todo_app_service_policy_id equals the provided policyId.
 *
 * Security and permissions: Because configurations may contain sensitive or
 * secret values (is_secret), access is restricted to systemAdmin. Providers
 * should redact values for entries where is_secret is true, depending on
 * business rules, in list views. The response structure can use a summary
 * representation to avoid exposing sensitive value content while still
 * providing key metadata needed for selection.
 *
 * Relationships and behavior: Each configuration may optionally reference a
 * policy and a creating/updating user. The search experience can leverage
 * defined indexes: trigram indexes on key and description support keyword
 * queries, and composite indexes support common filters (active, namespace,
 * environment). Ensure logical deletions (deleted_at) are respected so that
 * logically deleted records are not included by default.
 *
 * Validation and request parameters: The request body (IRequest) should support
 * filters like namespace, environment, active status, effective windows
 * intersection with now, and free-text query across key/description. Include
 * pagination (page, pageSize within allowed ranges such as 1–100) and sorting
 * (e.g., by created_at desc by default, or by key asc). Ensure policyId is
 * required and used to scope the query to this policy.
 *
 * Error handling: If the specified policyId does not exist or is not visible,
 * return not-found. If no configurations match, return an empty page. Avoid
 * returning secret values in summaries to reduce exposure risk.
 *
 * @param props.connection
 * @param props.policyId Parent policy UUID (todo_app_service_policies.id) to
 *   scope configurations
 * @param props.body Search filters, pagination, and sorting options for
 *   configurations under the policy
 * @path /todoApp/systemAdmin/servicePolicies/:policyId/serviceConfigurations
 * @accessor api.functional.todoApp.systemAdmin.servicePolicies.serviceConfigurations.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Parent policy UUID (todo_app_service_policies.id) to scope
     * configurations
     */
    policyId: string & tags.Format<"uuid">;

    /**
     * Search filters, pagination, and sorting options for configurations
     * under the policy
     */
    body: ITodoAppServiceConfiguration.IRequest;
  };
  export type Body = ITodoAppServiceConfiguration.IRequest;
  export type Response = IPageITodoAppServiceConfiguration.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/servicePolicies/:policyId/serviceConfigurations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/systemAdmin/servicePolicies/${encodeURIComponent(props.policyId ?? "null")}/serviceConfigurations`;
  export const random = (): IPageITodoAppServiceConfiguration.ISummary =>
    typia.random<IPageITodoAppServiceConfiguration.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("policyId")(() => typia.assert(props.policyId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a service configuration (todo_app_service_configurations) by id under a
 * policy.
 *
 * This endpoint returns one configuration from todo_app_service_configurations.
 * The model includes id, optional todo_app_user_id, optional
 * todo_app_service_policy_id, namespace, environment, key, value, value_type,
 * is_secret, description, active, effective_from, effective_to, created_at,
 * updated_at, and deleted_at. The request must ensure that the configuration’s
 * todo_app_service_policy_id equals the provided policyId to enforce correct
 * scoping.
 *
 * Security and permissions: Access is limited to systemAdmin due to potential
 * sensitivity (is_secret). Implementers may optionally redact value for secret
 * entries unless an explicit “reveal secret” workflow is authorized. All reads
 * should exclude logically deleted records (deleted_at not null) per business
 * policy.
 *
 * Relationships and constraints: The configuration references a policy and
 * optionally a creating/updating user. Uniqueness is enforced across
 * [namespace, key, environment]. The GET returns the complete object so that
 * administrators can verify exact values, types, and activation windows.
 *
 * Error handling: Return not-found if the configuration does not exist, is not
 * associated with the specified policy, or is marked deleted. Ensure correct
 * 404 behavior to avoid revealing records that are outside the given policy
 * scope.
 *
 * @param props.connection
 * @param props.policyId Parent policy UUID (todo_app_service_policies.id)
 * @param props.configurationId Target configuration UUID
 *   (todo_app_service_configurations.id)
 * @path /todoApp/systemAdmin/servicePolicies/:policyId/serviceConfigurations/:configurationId
 * @accessor api.functional.todoApp.systemAdmin.servicePolicies.serviceConfigurations.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Parent policy UUID (todo_app_service_policies.id) */
    policyId: string & tags.Format<"uuid">;

    /** Target configuration UUID (todo_app_service_configurations.id) */
    configurationId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppServiceConfiguration;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/servicePolicies/:policyId/serviceConfigurations/:configurationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/servicePolicies/${encodeURIComponent(props.policyId ?? "null")}/serviceConfigurations/${encodeURIComponent(props.configurationId ?? "null")}`;
  export const random = (): ITodoAppServiceConfiguration =>
    typia.random<ITodoAppServiceConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("policyId")(() => typia.assert(props.policyId));
      assert.param("configurationId")(() =>
        typia.assert(props.configurationId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a configuration in todo_app_service_configurations for a given policy.
 *
 * Modify the targeted configuration stored in todo_app_service_configurations.
 * This table holds administrative settings including namespace, optional
 * environment, key, value, value_type, is_secret, description, active,
 * effective_from, effective_to, timestamps, and a deleted_at marker. The
 * operation should enforce that the configuration belongs to the given
 * todo_app_service_policy_id (from policyId) before applying updates.
 *
 * Security considerations: Only authorized administrators should update
 * configurations. Avoid exposing secret values when is_secret=true; redact in
 * logs and, depending on policy, in responses. Maintain updated_at semantics
 * upon successful mutation. Inputs for time window fields
 * (effective_from/effective_to) must be valid RFC 3339 date-times.
 *
 * Relations and constraints: The configuration is linked to
 * todo_app_service_policies via todo_app_service_policy_id. Uniqueness on
 * (namespace, key, environment) must be respected; if an update changes any of
 * these, verify the combination remains unique. The table provides trigram
 * indexes for key/description and additional composite indexes to facilitate
 * downstream search.
 *
 * Error handling: Return clear messages for uniqueness conflicts or when
 * attempting to update a configuration not found under the specified policy. If
 * the record is marked deleted via deleted_at, treat it as not updatable per
 * governance policy.
 *
 * @param props.connection
 * @param props.policyId Policy ID that owns the configuration
 * @param props.configurationId Configuration ID to update
 * @param props.body Configuration update payload
 * @path /todoApp/systemAdmin/servicePolicies/:policyId/serviceConfigurations/:configurationId
 * @accessor api.functional.todoApp.systemAdmin.servicePolicies.serviceConfigurations.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Policy ID that owns the configuration */
    policyId: string & tags.Format<"uuid">;

    /** Configuration ID to update */
    configurationId: string & tags.Format<"uuid">;

    /** Configuration update payload */
    body: ITodoAppServiceConfiguration.IUpdate;
  };
  export type Body = ITodoAppServiceConfiguration.IUpdate;
  export type Response = ITodoAppServiceConfiguration;

  export const METADATA = {
    method: "PUT",
    path: "/todoApp/systemAdmin/servicePolicies/:policyId/serviceConfigurations/:configurationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/systemAdmin/servicePolicies/${encodeURIComponent(props.policyId ?? "null")}/serviceConfigurations/${encodeURIComponent(props.configurationId ?? "null")}`;
  export const random = (): ITodoAppServiceConfiguration =>
    typia.random<ITodoAppServiceConfiguration>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("policyId")(() => typia.assert(props.policyId));
      assert.param("configurationId")(() =>
        typia.assert(props.configurationId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a configuration (todo_app_service_configurations) from active use by
 * marking deleted_at.
 *
 * Remove the configuration from active use by marking it as deleted in
 * todo_app_service_configurations. The model includes a deleted_at timestamp to
 * exclude records from normal operations while retaining them for governance
 * and recovery workflows. This endpoint identifies the configuration by
 * configurationId within the policy scope policyId and, upon authorization,
 * updates the record to set deleted_at (and potentially active=false) according
 * to business rules.
 *
 * Security and permissions: Restricted to administrative actors. Ensure the
 * configuration belongs to the provided policyId and that the caller has
 * sufficient privileges. Avoid emitting sensitive value fields (when
 * is_secret=true) in audit logs or responses.
 *
 * Behavior and error handling: If the configuration is already marked deleted
 * (deleted_at not null), treat the operation as idempotent and return a
 * confirmation without further state change. If the record does not exist under
 * the specified policy, respond with a not-found outcome without leaking
 * cross-tenant details. This operation permanently removes the configuration
 * from active evaluations and standard listings by virtue of the deleted_at
 * marker.
 *
 * @param props.connection
 * @param props.policyId Policy ID that owns the configuration
 * @param props.configurationId Configuration ID to remove from active use
 * @path /todoApp/systemAdmin/servicePolicies/:policyId/serviceConfigurations/:configurationId
 * @accessor api.functional.todoApp.systemAdmin.servicePolicies.serviceConfigurations.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Policy ID that owns the configuration */
    policyId: string & tags.Format<"uuid">;

    /** Configuration ID to remove from active use */
    configurationId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoApp/systemAdmin/servicePolicies/:policyId/serviceConfigurations/:configurationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/servicePolicies/${encodeURIComponent(props.policyId ?? "null")}/serviceConfigurations/${encodeURIComponent(props.configurationId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("policyId")(() => typia.assert(props.policyId));
      assert.param("configurationId")(() =>
        typia.assert(props.configurationId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
