import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppFeatureFlag } from "../../../../../structures/ITodoAppFeatureFlag";
import { IPageITodoAppFeatureFlag } from "../../../../../structures/IPageITodoAppFeatureFlag";

/**
 * Create a feature flag in todo_app_feature_flags under a given
 * todo_app_service_policies record.
 *
 * This endpoint creates a feature flag record in todo_app_feature_flags,
 * associating it with the policy identified by policyId via the
 * todo_app_service_policy_id foreign key to todo_app_service_policies.id.
 * According to the Prisma schema comments, feature flags are designed for
 * conditional enablement and staged rollouts, support environment and namespace
 * scoping, percentage-based rollouts, and optional targeting notes.
 * Administrators manage these records; they may optionally be linked to a
 * governing policy and include timestamps (created_at, updated_at) and a
 * soft-deletion column (deleted_at).
 *
 * Security and permissions: Only administrative users (systemAdmin) may create
 * feature flags, as these directly impact runtime behavior. The server must
 * ignore or override any body-supplied governing policy field and instead bind
 * the new flag to the policyId from the path to avoid cross-policy mismatches.
 * Sensitive operational practices—like redacting internals in logs when
 * is_secret applies on other entities—should be considered, though flags
 * themselves do not include secret value types.
 *
 * Validation and business rules: Enforce uniqueness on [namespace, code,
 * environment] as defined by the Prisma schema (@@unique). Validate that
 * rollout_percentage is an integer suitable for 0–100 progressive rollout
 * semantics and that optional window fields (start_at, end_at) are coherent
 * (end_at after start_at when both present). Ensure the referenced policy
 * (todo_app_service_policies) exists and is not deleted (deleted_at is null).
 * The system sets created_at/updated_at automatically, and deleted_at remains
 * null on creation. On success, return the created ITodoAppFeatureFlag record.
 *
 * Related operations: Administrators typically retrieve the created flag using
 * GET /servicePolicies/{policyId}/featureFlags/{featureFlagId}, update it with
 * PUT, and remove it with DELETE when necessary. Conflicts due to uniqueness
 * violations or invalid policy references should be reported with clear
 * messages.
 *
 * @param props.connection
 * @param props.policyId Identifier of the parent service policy for association
 * @param props.body Feature flag creation payload. The server binds it to
 *   policyId.
 * @path /todoApp/systemAdmin/servicePolicies/:policyId/featureFlags
 * @accessor api.functional.todoApp.systemAdmin.servicePolicies.featureFlags.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Identifier of the parent service policy for association */
    policyId: string & tags.Format<"uuid">;

    /** Feature flag creation payload. The server binds it to policyId. */
    body: ITodoAppFeatureFlag.ICreate;
  };
  export type Body = ITodoAppFeatureFlag.ICreate;
  export type Response = ITodoAppFeatureFlag;

  export const METADATA = {
    method: "POST",
    path: "/todoApp/systemAdmin/servicePolicies/:policyId/featureFlags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/systemAdmin/servicePolicies/${encodeURIComponent(props.policyId ?? "null")}/featureFlags`;
  export const random = (): ITodoAppFeatureFlag =>
    typia.random<ITodoAppFeatureFlag>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("policyId")(() => typia.assert(props.policyId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and paginate feature flags (todo_app_feature_flags) under a policy.
 *
 * Search and list feature flags belonging to the specified policy
 * (todo_app_feature_flags with foreign key todo_app_service_policy_id). The
 * schema defines attributes including namespace, optional environment, code,
 * name, description, active, rollout_percentage, target_audience, start_at,
 * end_at, created_at, updated_at, and a deleted_at marker. Indexes on (active,
 * namespace, environment), (rollout_percentage, namespace), and trigram indexes
 * on name/description support efficient querying.
 *
 * Security: Access is restricted to administrative users responsible for flag
 * governance. Business logic must ensure the caller has system-level admin
 * permissions and apply policy scoping using policyId to avoid cross-policy
 * leakage.
 *
 * Query model and behavior: The request body may specify pagination, search
 * keywords (e.g., on code, name, description), filters (active state,
 * environment, namespace), rollout ranges, and time window constraints
 * (start_at/end_at). Sorting options can include created_at, updated_at, code,
 * name, rollout_percentage, or activity windows. Results should return a
 * summary shape optimized for listing, excluding unnecessary internal details,
 * and omit records with deleted_at set by default.
 *
 * Error handling: Validate that policyId maps to an existing
 * todo_app_service_policies row. For invalid filters or ranges, return
 * descriptive messages indicating the rule (e.g., invalid percentage range or
 * date-time format).
 *
 * @param props.connection
 * @param props.policyId Policy ID that scopes the feature flags
 * @param props.body Search, filter, sort, and pagination parameters for feature
 *   flags
 * @path /todoApp/systemAdmin/servicePolicies/:policyId/featureFlags
 * @accessor api.functional.todoApp.systemAdmin.servicePolicies.featureFlags.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Policy ID that scopes the feature flags */
    policyId: string & tags.Format<"uuid">;

    /** Search, filter, sort, and pagination parameters for feature flags */
    body: ITodoAppFeatureFlag.IRequest;
  };
  export type Body = ITodoAppFeatureFlag.IRequest;
  export type Response = IPageITodoAppFeatureFlag.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoApp/systemAdmin/servicePolicies/:policyId/featureFlags",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/systemAdmin/servicePolicies/${encodeURIComponent(props.policyId ?? "null")}/featureFlags`;
  export const random = (): IPageITodoAppFeatureFlag.ISummary =>
    typia.random<IPageITodoAppFeatureFlag.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("policyId")(() => typia.assert(props.policyId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a feature flag (todo_app_feature_flags) scoped to a service policy
 * (todo_app_service_policies).
 *
 * This endpoint fetches one feature flag from the todo_app_feature_flags table
 * using its primary key and ensures policy scoping by verifying that
 * todo_app_feature_flags.todo_app_service_policy_id matches the path policyId.
 * The underlying Prisma schema documents feature-flag concepts such as
 * namespace-scoped code uniqueness across (namespace, code, environment),
 * optional governing policy via todo_app_service_policy_id, and control fields
 * including active, rollout_percentage, and optional targeting window
 * (start_at, end_at). These schema descriptions clarify that flags are
 * administrator-managed and support staged rollouts and environment scoping.
 *
 * Security and permissions: Access is limited to administrative users
 * responsible for feature management. The requestor must hold system-level
 * privileges (systemAdmin role) because flags control runtime behavior.
 * Non-administrative roles must not read or infer internal rollout
 * configurations. Authorization should be performed prior to data access, and
 * response data must omit or mask any sensitive values if policy dictates.
 *
 * Database relationships: The feature flag references todo_app_service_policies
 * via todo_app_feature_flags.todo_app_service_policy_id (nullable in schema),
 * and administrators often manage flags in association with policies. This
 * operation uses the policyId path parameter to scope the retrieval. If the
 * feature flag does not belong to the given policy, the provider must respond
 * as not found. Read queries typically leverage indexes such as [active,
 * namespace, environment] and uniqueness on [namespace, code, environment].
 *
 * Validation and behavior: The provider verifies UUID formats for both policyId
 * and featureFlagId, checks that the referenced policy exists
 * (todo_app_service_policies.id), and then ensures the feature flag exists and
 * matches that policy. If the record has a non-null deleted_at, it is
 * considered deleted and should not be returned. The response returns all
 * relevant fields of ITodoAppFeatureFlag for administrative inspection.
 *
 * Related operations: Use POST /servicePolicies/{policyId}/featureFlags to
 * create a new flag under the policy, PUT to modify an existing flag, and
 * DELETE to remove (soft-delete) a flag. Typical admin workflows navigate
 * between these operations during flag lifecycle management. Error handling
 * should distinguish between format/validation errors, missing resources,
 * authorization failures, and conflict states.
 *
 * @param props.connection
 * @param props.policyId Identifier of the parent service policy
 * @param props.featureFlagId Identifier of the target feature flag
 * @path /todoApp/systemAdmin/servicePolicies/:policyId/featureFlags/:featureFlagId
 * @accessor api.functional.todoApp.systemAdmin.servicePolicies.featureFlags.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the parent service policy */
    policyId: string & tags.Format<"uuid">;

    /** Identifier of the target feature flag */
    featureFlagId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoAppFeatureFlag;

  export const METADATA = {
    method: "GET",
    path: "/todoApp/systemAdmin/servicePolicies/:policyId/featureFlags/:featureFlagId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/servicePolicies/${encodeURIComponent(props.policyId ?? "null")}/featureFlags/${encodeURIComponent(props.featureFlagId ?? "null")}`;
  export const random = (): ITodoAppFeatureFlag =>
    typia.random<ITodoAppFeatureFlag>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("policyId")(() => typia.assert(props.policyId));
      assert.param("featureFlagId")(() => typia.assert(props.featureFlagId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a feature flag (todo_app_feature_flags) scoped by a service policy
 * (todo_app_service_policies).
 *
 * This endpoint updates administrative fields of a feature flag stored in
 * todo_app_feature_flags. Per Prisma schema, feature flags include fields such
 * as namespace, code, environment, name, description, active,
 * rollout_percentage, target_audience, and optional start_at/end_at window
 * controls. The update must respect the uniqueness constraint on [namespace,
 * code, environment] and the policy association defined by
 * todo_app_service_policy_id.
 *
 * Security and permissions: Only administrative actors (systemAdmin) are
 * authorized to modify flags. The provider must verify that the targeted flag
 * belongs to the policy specified by policyId; otherwise, treat the request as
 * not found. Records with non-null deleted_at should not be updatable (consider
 * them removed from normal flows).
 *
 * Validation and behavior: Apply field validations coherent with business
 * semantics (e.g., rollout_percentage should remain within 0–100; start_at
 * precedes end_at if both set). The system should set updated_at to the current
 * time upon successful modification. Attempts to change the governing policy
 * association should be rejected; this endpoint maintains the link to policyId
 * from the path. On success, return the updated ITodoAppFeatureFlag entity for
 * confirmation.
 *
 * Related operations: Administrators can fetch the current state via GET,
 * create new flags with POST, and remove flags with DELETE. The implementation
 * should communicate conflicts clearly, especially uniqueness violations and
 * invalid state transitions.
 *
 * @param props.connection
 * @param props.policyId Identifier of the parent service policy
 * @param props.featureFlagId Identifier of the feature flag to update
 * @param props.body Fields to modify on the feature flag
 * @path /todoApp/systemAdmin/servicePolicies/:policyId/featureFlags/:featureFlagId
 * @accessor api.functional.todoApp.systemAdmin.servicePolicies.featureFlags.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Identifier of the parent service policy */
    policyId: string & tags.Format<"uuid">;

    /** Identifier of the feature flag to update */
    featureFlagId: string & tags.Format<"uuid">;

    /** Fields to modify on the feature flag */
    body: ITodoAppFeatureFlag.IUpdate;
  };
  export type Body = ITodoAppFeatureFlag.IUpdate;
  export type Response = ITodoAppFeatureFlag;

  export const METADATA = {
    method: "PUT",
    path: "/todoApp/systemAdmin/servicePolicies/:policyId/featureFlags/:featureFlagId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoApp/systemAdmin/servicePolicies/${encodeURIComponent(props.policyId ?? "null")}/featureFlags/${encodeURIComponent(props.featureFlagId ?? "null")}`;
  export const random = (): ITodoAppFeatureFlag =>
    typia.random<ITodoAppFeatureFlag>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("policyId")(() => typia.assert(props.policyId));
      assert.param("featureFlagId")(() => typia.assert(props.featureFlagId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-remove a feature flag in todo_app_feature_flags under a service policy
 * (todo_app_service_policies).
 *
 * This endpoint performs a non-destructive removal of a feature flag by setting
 * deleted_at in the todo_app_feature_flags table, as defined by the Prisma
 * schema. Records with deleted_at not null are excluded from normal flows; this
 * preserves administrative history and avoids accidental loss. The operation
 * must verify ownership under the policy scope using the
 * todo_app_service_policy_id foreign key to todo_app_service_policies.
 *
 * Security and permissions: Only administrative users (systemAdmin) may remove
 * feature flags. The provider should verify that the target feature flag
 * exists, is associated with the specified policyId, and is not already removed
 * (deleted_at is null). If the record is already removed, treat the operation
 * as idempotent and respond successfully without additional changes.
 *
 * Validation and behavior: Set deleted_at to the current time and update
 * updated_at. Do not physically delete the row to preserve auditability.
 * Subsequent reads through the GET operation should not return removed records.
 * If needed, additional administrative audit logging can be recorded in
 * separate audit tables (e.g., todo_app_admin_actions) per governance
 * policy—these are system-generated and not exposed via user-facing write
 * APIs.
 *
 * Related operations: Administrators may create new flags via POST after
 * removal, or update existing ones with PUT prior to removal. Retrieval via GET
 * will exclude removed records. Error handling should distinguish between
 * authorization, not-found (including cross-policy mismatch), and transient
 * conflicts.
 *
 * @param props.connection
 * @param props.policyId Identifier of the parent service policy
 * @param props.featureFlagId Identifier of the feature flag to remove
 * @path /todoApp/systemAdmin/servicePolicies/:policyId/featureFlags/:featureFlagId
 * @accessor api.functional.todoApp.systemAdmin.servicePolicies.featureFlags.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Identifier of the parent service policy */
    policyId: string & tags.Format<"uuid">;

    /** Identifier of the feature flag to remove */
    featureFlagId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoApp/systemAdmin/servicePolicies/:policyId/featureFlags/:featureFlagId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoApp/systemAdmin/servicePolicies/${encodeURIComponent(props.policyId ?? "null")}/featureFlags/${encodeURIComponent(props.featureFlagId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("policyId")(() => typia.assert(props.policyId));
      assert.param("featureFlagId")(() => typia.assert(props.featureFlagId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
