import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IPageITodoMvpTodo } from "../../../../structures/IPageITodoMvpTodo";
import { ITodoMvpTodo } from "../../../../structures/ITodoMvpTodo";

/**
 * List Todos owned by the authenticated user from Prisma table todo_mvp_todos.
 *
 * List the requesting user’s Todos from the todo_mvp_todos table. Each Todo
 * represents a single actionable item owned by one authenticated user as
 * described in the Prisma schema: a required title, optional notes, optional
 * day-level due_date interpreted in the user’s local time context, a simple
 * status ("open" or "completed"), and timestamps for created_at, updated_at,
 * and completed_at (only when completed).
 *
 * Security and permissions: access is restricted to authenticated users and
 * returns only records where todo_mvp_todos.todo_mvp_user_id matches the
 * requester’s identity. The response must not include any other user’s data.
 * Authentication and authorization are enforced by the controller/provider
 * according to session and ownership checks described in the business
 * requirements.
 *
 * Database relationship: todo_mvp_todos.owner relates to todo_mvp_users via
 * todo_mvp_user_id with onDelete: Cascade. No deletion-timestamp column exists
 * on this table; records are physically removed when deleted by design of the
 * MVP’s lifecycle policies. Indexes on (todo_mvp_user_id, status, created_at)
 * and related composites support default list ordering and basic filtering in
 * provider logic.
 *
 * Validation and business logic context: while this endpoint does not validate
 * create/update inputs, clients should expect fields to adhere to rules derived
 * from the schema comments (e.g., title is trimmed and typically 1–120 chars by
 * business rules; notes may be null; completed_at exists only when status is
 * "completed"). Due dates are optional and intended as day-level values.
 *
 * Related operations: creation and modification occur via separate endpoints
 * (e.g., POST/PUT/PUT-Toggle not shown here). This endpoint is designed to be
 * used in conjunction with those to reflect list updates immediately after
 * successful mutations. In case of authorization failure or ownership
 * violations, providers return appropriate errors in line with platform
 * conventions.
 *
 * @param props.connection
 * @path /todoMvp/user/todos
 * @accessor api.functional.todoMvp.user.todos.get
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function get(connection: IConnection): Promise<get.Response> {
  return true === connection.simulate
    ? get.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...get.METADATA,
          path: get.path(),
          status: null,
        },
      );
}
export namespace get {
  export type Response = IPageITodoMvpTodo;

  export const METADATA = {
    method: "GET",
    path: "/todoMvp/user/todos",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoMvp/user/todos";
  export const random = (): IPageITodoMvpTodo =>
    typia.random<IPageITodoMvpTodo>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Create a new Todo in table todo_mvp_todos owned by the authenticated user.
 *
 * Create a Todo record in todo_mvp_todos for the requesting user. The Prisma
 * schema’s description emphasizes a minimal task model: title (required),
 * optional notes and due_date, and a status constrained to "open" or
 * "completed" with a default of "open" on creation. Timestamps include
 * created_at and updated_at, while completed_at is set only when status becomes
 * "completed".
 *
 * Security and permissions: Only authenticated users may create Todos, and each
 * created row must be associated with the creator’s todo_mvp_users.id (stored
 * in todo_mvp_user_id). Other users’ ownership cannot be specified by clients.
 *
 * Validation and business rules: Title must be non-empty after trimming and
 * within the documented length expectations (typical 1–120 characters). Notes
 * are optional and typically limited to around 1,000 characters as per business
 * guidance. due_date is optional and interpreted at day-level in the user’s
 * local context (stored as timestamptz by schema); invalid dates must be
 * rejected. Status should default to "open"; clients generally should not set
 * completed_at at creation.
 *
 * Related operations: After creation, clients typically call PATCH /todos to
 * refresh the list or GET /todos/{todoId} to fetch full details. Auditing of
 * the creation event, if enabled, is handled internally by system services
 * referencing todo_mvp_audit_events.
 *
 * Error handling: Validation failures result in clear messages and no partial
 * writes. Ownership is enforced server-side, and authentication failures must
 * be denied without exposing other users’ data.
 *
 * @param props.connection
 * @param props.body Creation payload for a Todo (title required; optional notes
 *   and due_date; status defaults to "open").
 * @path /todoMvp/user/todos
 * @accessor api.functional.todoMvp.user.todos.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Creation payload for a Todo (title required; optional notes and
     * due_date; status defaults to "open").
     */
    body: ITodoMvpTodo.ICreate;
  };
  export type Body = ITodoMvpTodo.ICreate;
  export type Response = ITodoMvpTodo;

  export const METADATA = {
    method: "POST",
    path: "/todoMvp/user/todos",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoMvp/user/todos";
  export const random = (): ITodoMvpTodo => typia.random<ITodoMvpTodo>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List/search the authenticated user’s Todos from table todo_mvp_todos with
 * pagination and minimal filters.
 *
 * Retrieve a list of the caller’s own Todo items from todo_mvp_todos using
 * business-aligned filters and ordering. The underlying Prisma schema documents
 * a simple lifecycle with a required title, optional notes and due_date, a
 * status that is either "open" or "completed", and timestamps for created_at
 * and updated_at, plus completed_at only when status is "completed". This
 * endpoint focuses on list presentation and therefore returns summary
 * information optimized for rendering lists.
 *
 * Security and permissions: Access is restricted to authenticated users and
 * must return only rows where todo_mvp_todos.todo_mvp_user_id equals the
 * authenticated user’s id. No other user’s data can be included. Administrative
 * identities do not browse member content in MVP; enforcement is handled in
 * provider logic.
 *
 * Database relationship context: Each Todo belongs to exactly one user
 * (todo_mvp_users) via a required relation with onDelete: Cascade, ensuring
 * user removal removes their Todos. Audit/event tables (todo_mvp_audit_events)
 * record lifecycle actions but are system-managed artifacts and are not
 * manipulated by this endpoint.
 *
 * Validation and business logic: Filters are limited and predictable—status
 * filter supports "all", "open", and "completed"; default sorting is by
 * created_at descending (newest first). Pagination parameters are required to
 * ensure consistent performance targets. Inputs that specify an invalid status
 * or sort key should be rejected with a validation error.
 *
 * Related operations: Use POST /todos to create new items; GET /todos/{todoId}
 * to view a single item’s full details; PUT /todos/{todoId} to change fields
 * (title, notes, due_date, status). Typical UI will call this endpoint
 * frequently to refresh the visible list after any mutation.
 *
 * Error handling: Validation failures produce clear messages without leaking
 * other users’ information. If the authenticated context is missing, the
 * provider must deny access. Concurrency is not directly relevant for reads,
 * but the list should reflect confirmed writes promptly.
 *
 * @param props.connection
 * @param props.body Search, filter, sort, and pagination parameters for listing
 *   Todos.
 * @path /todoMvp/user/todos
 * @accessor api.functional.todoMvp.user.todos.patch
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patch(
  connection: IConnection,
  props: patch.Props,
): Promise<patch.Response> {
  return true === connection.simulate
    ? patch.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patch.METADATA,
          path: patch.path(),
          status: null,
        },
        props.body,
      );
}
export namespace patch {
  export type Props = {
    /** Search, filter, sort, and pagination parameters for listing Todos. */
    body: ITodoMvpTodo.IRequest;
  };
  export type Body = ITodoMvpTodo.IRequest;
  export type Response = IPageITodoMvpTodo.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoMvp/user/todos",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoMvp/user/todos";
  export const random = (): IPageITodoMvpTodo.ISummary =>
    typia.random<IPageITodoMvpTodo.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: patch.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patch.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single Todo from table todo_mvp_todos by id with full details.
 *
 * Fetch one Todo record from todo_mvp_todos using its id. The model’s columns
 * include title (required), notes (optional), status ("open" or "completed"),
 * due_date (optional, day-level semantics), completed_at when completed, and
 * created_at/updated_at timestamps. This operation provides the complete
 * representation suitable for detail views or edit forms.
 *
 * Security and permissions: The caller must be authenticated as a user and must
 * own the Todo (todo_mvp_user_id equals the caller’s id). If not owned or not
 * found, the service denies access or returns a not-found outcome without
 * revealing any protected content.
 *
 * Relationship context: The Todo has a required owner relation to
 * todo_mvp_users with onDelete: Cascade. Audit trails may reference this Todo
 * via todo_mvp_audit_events; those records are system-managed and not exposed
 * by this endpoint.
 *
 * Validation and behavior: The path parameter todoId is a UUID. No request body
 * is required. Typical usage follows list or creation operations to view
 * details before updates.
 *
 * Error handling: If the id is invalid format, treat as validation failure. If
 * the Todo does not exist or is not owned, respond as not-found without
 * disclosing ownership details.
 *
 * @param props.connection
 * @param props.todoId Identifier of the target Todo (UUID).
 * @path /todoMvp/user/todos/:todoId
 * @accessor api.functional.todoMvp.user.todos.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the target Todo (UUID). */
    todoId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoMvpTodo;

  export const METADATA = {
    method: "GET",
    path: "/todoMvp/user/todos/:todoId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoMvp/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): ITodoMvpTodo => typia.random<ITodoMvpTodo>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a Todo in table todo_mvp_todos by id (title, notes, due_date, status).
 *
 * Modify fields of a Todo in todo_mvp_todos. The schema defines a minimal task
 * with title (required), optional notes and due_date, and a status limited to
 * "open" or "completed". On successful changes, updated_at is refreshed; if
 * status becomes "completed", completed_at is set; when reverting to "open",
 * completed_at is cleared. Other timestamps (created_at) are immutable.
 *
 * Security and permissions: Only the owning authenticated user may update their
 * Todo (todo_mvp_user_id equals the caller). The operation must not allow
 * clients to change ownership. Administrative accounts do not edit member
 * content in MVP.
 *
 * Validation rules: Title must remain valid after trimming (typical 1–120
 * characters). Notes length should remain within the ~1,000 character guidance.
 * due_date, when provided, must be a valid calendar date. Status must be either
 * "open" or "completed". All-or-nothing validation applies; partial updates are
 * not persisted on validation failure.
 *
 * Related operations: Clients often call GET /todos/{todoId} before updating
 * and PATCH /todos afterward to refresh the list. Creation is via POST /todos.
 * System audit of update events, if configured, is internal to services
 * referencing todo_mvp_audit_events.
 *
 * Error handling: Invalid UUID in the path yields a validation error.
 * Nonexistent or non-owned targets must be handled as not-found without
 * disclosing protected details. Concurrency conflicts should be detected and
 * surfaced with clear retry guidance.
 *
 * @param props.connection
 * @param props.todoId Identifier of the Todo to update (UUID).
 * @param props.body Update payload for a Todo (title, notes, due_date, status).
 * @path /todoMvp/user/todos/:todoId
 * @accessor api.functional.todoMvp.user.todos.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Identifier of the Todo to update (UUID). */
    todoId: string & tags.Format<"uuid">;

    /** Update payload for a Todo (title, notes, due_date, status). */
    body: ITodoMvpTodo.IUpdate;
  };
  export type Body = ITodoMvpTodo.IUpdate;
  export type Response = ITodoMvpTodo;

  export const METADATA = {
    method: "PUT",
    path: "/todoMvp/user/todos/:todoId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoMvp/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): ITodoMvpTodo => typia.random<ITodoMvpTodo>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Hard delete a Todo from todo_mvp_todos by ID.
 *
 * Delete a single Todo owned by the requesting user. The underlying Prisma
 * model todo_mvp_todos includes fields id (UUID primary key), todo_mvp_user_id
 * (owner reference), title, notes, status ("open" or "completed" by business
 * rules), optional due_date, optional completed_at, and timestamps created_at
 * and updated_at. Because this model intentionally excludes a deletion marker
 * column, the system permanently removes the row when this operation succeeds.
 *
 * Security and permissions: Only authenticated users may invoke this endpoint,
 * and the target Todo must be owned by the caller (matched via
 * todo_mvp_todos.todo_mvp_user_id). Implementations should deny access to
 * non-owners without disclosing whether the record exists. Administrative
 * identities are not intended to manage member content in this MVP.
 *
 * Behavior and validation: The provider must verify path parameter format
 * (UUID) and enforce ownership checks before deletion. On success, the record
 * is removed from todo_mvp_todos. Any dependent rows in related tables will
 * follow the configured Prisma relation behavior for referential integrity. If
 * the record does not exist or is not accessible to the caller, the provider
 * should respond accordingly without revealing private details.
 *
 * Related operations: Creation and updates occur through other CRUD endpoints
 * on the same todo_mvp_todos table. Listing and detail retrieval endpoints
 * should no longer return the deleted resource after this operation. Error
 * handling should clearly indicate validation failures (e.g., malformed UUID)
 * and access violations.
 *
 * @param props.connection
 * @param props.todoId UUID of the Todo to delete
 * @path /todoMvp/user/todos/:todoId
 * @accessor api.functional.todoMvp.user.todos.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the Todo to delete */
    todoId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoMvp/user/todos/:todoId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoMvp/user/todos/${encodeURIComponent(props.todoId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("todoId")(() => typia.assert(props.todoId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
