import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoMvpAuditEvent } from "../../../../structures/ITodoMvpAuditEvent";
import { IPageITodoMvpAuditEvent } from "../../../../structures/IPageITodoMvpAuditEvent";

/**
 * List/search audit events from todo_mvp_audit_events (admin read-only).
 *
 * Return audit trail entries recorded in the todo_mvp_audit_events table. The
 * schema defines id (UUID primary key), optional foreign keys todo_mvp_user_id
 * and todo_mvp_admin_id (actors), optional todo_mvp_todo_id (target Todo),
 * event_type (e.g., "todo_created", "todo_updated", "todo_completed",
 * "todo_uncompleted", "todo_deleted"), optional event_description, and
 * timestamps created_at, updated_at, and optional deleted_at.
 *
 * Security and permissions: This endpoint is limited to administrators,
 * consistent with the requirement that admins have oversight capabilities
 * without accessing member Todo content directly. The response contains
 * operational metadata only; implementations must avoid including Todo content
 * fields, as the audit table intentionally stores no title or notes content.
 *
 * Query behavior and validation: The request body (ITodoMvpAuditEvent.IRequest)
 * should support pagination inputs, optional filters such as actor IDs, target
 * Todo ID, event_type set, and created_at ranges, and sorting controls (e.g.,
 * by created_at). The response returns a paginated container
 * (IPageITodoMvpAuditEvent) with pagination metadata and an array of audit
 * entries. Input should be validated to ensure UUID formats where applicable
 * and to constrain sort fields to supported columns.
 *
 * Related operations: Use GET /auditEvents/{auditEventId} to retrieve a
 * specific audit entry. No write endpoints exist for audit events as they are
 * created automatically by application logic during user/admin actions.
 *
 * @param props.connection
 * @param props.body Search, filter, and pagination parameters for audit event
 *   retrieval
 * @path /todoMvp/admin/auditEvents
 * @accessor api.functional.todoMvp.admin.auditEvents.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Search, filter, and pagination parameters for audit event retrieval */
    body: ITodoMvpAuditEvent.IRequest;
  };
  export type Body = ITodoMvpAuditEvent.IRequest;
  export type Response = IPageITodoMvpAuditEvent;

  export const METADATA = {
    method: "PATCH",
    path: "/todoMvp/admin/auditEvents",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoMvp/admin/auditEvents";
  export const random = (): IPageITodoMvpAuditEvent =>
    typia.random<IPageITodoMvpAuditEvent>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a single audit event from todo_mvp_audit_events by ID (admin).
 *
 * Fetch a single audit entry from todo_mvp_audit_events by its id. The table
 * includes id (UUID primary key), optional actor references todo_mvp_user_id
 * and todo_mvp_admin_id, an optional target todo_mvp_todo_id, event_type,
 * optional event_description, created_at, updated_at, and optional deleted_at.
 * The model deliberately avoids storing Todo content (title/notes) to preserve
 * privacy.
 *
 * Security and permissions: Access is restricted to administrators in alignment
 * with MVP oversight requirements. Non-admins must not access audit trail
 * contents. The provider must ensure the caller is authorized and should avoid
 * leaking information beyond what the audit schema contains.
 *
 * Behavior and error handling: On success, return the matched audit event. If
 * the id is malformed, return a validation error. If the record is not found or
 * has been removed by lifecycle processes, return a not-found outcome. This
 * operation complements PATCH /auditEvents for list retrieval.
 *
 * This endpoint is read-only; creation and modification of audit events are
 * system-controlled side effects of other business operations.
 *
 * @param props.connection
 * @param props.auditEventId UUID of the audit event to retrieve
 * @path /todoMvp/admin/auditEvents/:auditEventId
 * @accessor api.functional.todoMvp.admin.auditEvents.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the audit event to retrieve */
    auditEventId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoMvpAuditEvent;

  export const METADATA = {
    method: "GET",
    path: "/todoMvp/admin/auditEvents/:auditEventId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoMvp/admin/auditEvents/${encodeURIComponent(props.auditEventId ?? "null")}`;
  export const random = (): ITodoMvpAuditEvent =>
    typia.random<ITodoMvpAuditEvent>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("auditEventId")(() => typia.assert(props.auditEventId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
