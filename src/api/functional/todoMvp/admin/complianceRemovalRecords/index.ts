import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoMvpComplianceRemovalRecord } from "../../../../structures/ITodoMvpComplianceRemovalRecord";
import { IPageITodoMvpComplianceRemovalRecord } from "../../../../structures/IPageITodoMvpComplianceRemovalRecord";

/**
 * List/search compliance removal records from
 * todo_mvp_compliance_removal_records (admin).
 *
 * Return compliance removal records kept in
 * todo_mvp_compliance_removal_records. The schema defines id (UUID primary
 * key), optional todo_mvp_admin_id (acting admin), optional todo_mvp_todo_id
 * (removed Todo reference), reason_code (e.g., "policy_violation",
 * "legal_request", "user_request_via_admin"), optional notes (must not contain
 * Todo content), action_effective_at, created_at, updated_at, and optional
 * deleted_at for lifecycle/retention control.
 *
 * Security and permissions: Only administrators may access this endpoint. The
 * dataset supports oversight and compliance workflows and must not reveal user
 * Todo content, which is not present in the model by design.
 *
 * Query behavior and validation: The request body
 * (ITodoMvpComplianceRemovalRecord.IRequest) should allow pagination, filtering
 * by acting admin, by removed Todo reference, by reason_code, and by
 * action_effective_at ranges, as well as sorting (e.g., created_at or
 * action_effective_at). The response returns a paginated list container
 * (IPageITodoMvpComplianceRemovalRecord). Validate UUID formats and constrain
 * sort fields to supported columns.
 *
 * Related operations: No write APIs are exposed for these records in accordance
 * with system-generated data principles. Records are created by administrative
 * workflows within provider logic.
 *
 * @param props.connection
 * @param props.body Search, filter, and pagination parameters for compliance
 *   removal records
 * @path /todoMvp/admin/complianceRemovalRecords
 * @accessor api.functional.todoMvp.admin.complianceRemovalRecords.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filter, and pagination parameters for compliance removal
     * records
     */
    body: ITodoMvpComplianceRemovalRecord.IRequest;
  };
  export type Body = ITodoMvpComplianceRemovalRecord.IRequest;
  export type Response = IPageITodoMvpComplianceRemovalRecord;

  export const METADATA = {
    method: "PATCH",
    path: "/todoMvp/admin/complianceRemovalRecords",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoMvp/admin/complianceRemovalRecords";
  export const random = (): IPageITodoMvpComplianceRemovalRecord =>
    typia.random<IPageITodoMvpComplianceRemovalRecord>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a compliance removal record (todo_mvp_compliance_removal_records) by ID.
 *
 * This endpoint returns a single administrative compliance removal record
 * identified by its ID. The underlying Prisma model
 * todo_mvp_compliance_removal_records is documented as a “Minimal,
 * privacy-preserving record” that captures when an administrator removes a Todo
 * for policy or legal reasons. Fields include reason_code for a high-level
 * cause, optional notes that must not contain user Todo content, and
 * action_effective_at to indicate when the removal took effect for the user.
 * References to the acting administrator (todo_mvp_admin_id) and the removed
 * Todo (todo_mvp_todo_id) are nullable to preserve the record’s integrity even
 * after entity deletion. The model also records created_at and updated_at
 * timestamps, with deleted_at used for retention and lifecycle control.
 *
 * Security and permissions: Access is restricted to administrative actors. The
 * record is intended for oversight and compliance verification; it must not
 * reveal Todo content. Implementations should verify that the caller has
 * administrative privileges and, where applicable, limit visibility to the
 * minimum required set of fields for operational needs.
 *
 * Entity relationships: The record may relate to todo_mvp_admins (actorAdmin)
 * and todo_mvp_todos (removedTodo) via nullable foreign keys. Because these
 * references may be null (for example, after the Todo is removed), clients must
 * not assume presence of related entity details and should rely on the record’s
 * own fields for compliance proofs.
 *
 * Validation and behavior: The path parameter complianceRemovalRecordId must be
 * a valid UUID. If the record does not exist or is not accessible under current
 * policy, the server should respond with an appropriate not found outcome.
 * Since this is a read-only operation, no request body is required. This
 * operation may be used alongside audit event retrieval to corroborate broader
 * timelines (e.g., todo_mvp_audit_events with event_type such as
 * "todo_deleted").
 *
 * @param props.connection
 * @param props.complianceRemovalRecordId Identifier of the compliance removal
 *   record to retrieve
 * @path /todoMvp/admin/complianceRemovalRecords/:complianceRemovalRecordId
 * @accessor api.functional.todoMvp.admin.complianceRemovalRecords.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Identifier of the compliance removal record to retrieve */
    complianceRemovalRecordId: string & tags.Format<"uuid">;
  };
  export type Response = ITodoMvpComplianceRemovalRecord;

  export const METADATA = {
    method: "GET",
    path: "/todoMvp/admin/complianceRemovalRecords/:complianceRemovalRecordId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoMvp/admin/complianceRemovalRecords/${encodeURIComponent(props.complianceRemovalRecordId ?? "null")}`;
  export const random = (): ITodoMvpComplianceRemovalRecord =>
    typia.random<ITodoMvpComplianceRemovalRecord>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("complianceRemovalRecordId")(() =>
        typia.assert(props.complianceRemovalRecordId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
