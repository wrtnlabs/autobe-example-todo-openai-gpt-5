import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppGuestVisitor } from "../../../structures/ITodoAppGuestVisitor";
import { ITodoAppSessionRevocation } from "../../../structures/ITodoAppSessionRevocation";
export * as password from "./password/index";
export * as email from "./email/index";

/**
 * Register a guestVisitor in todo_app_users and issue session and refresh
 * tokens via todo_app_sessions and todo_app_refresh_tokens.
 *
 * This operation registers a temporary "guestVisitor" account and immediately
 * issues authentication credentials based on the schema under Actors and Auth.
 * The core identity is persisted in todo_app_users using fields such as email
 * (optional in this flow), password_hash (server-generated, never plaintext),
 * status (e.g., an application-defined state string), email_verified (false
 * when verification is outstanding), verified_at (null until verified),
 * last_login_at (set upon first successful authentication), and system
 * timestamps created_at and updated_at.
 *
 * Once the user is created, a new access session is inserted into
 * todo_app_sessions, capturing session_token (opaque, unique), issued_at,
 * expires_at, and available client context such as ip and user_agent. The
 * session forms the anchor for refresh rotation and subsequent audit logging.
 * The system then inserts the initial refresh token into
 * todo_app_refresh_tokens with token_hash (one‑way hash of the raw token),
 * issued_at, expires_at, parent_id set to null for the first issuance, and
 * optional rotation/revocation fields remaining null at creation.
 *
 * For services requiring email verification, a record can be prepared in
 * todo_app_email_verifications with token_hash, target_email, sent_at,
 * expires_at, and future consumption fields (consumed_at, failure_count). Until
 * verification succeeds, the todo_app_users.email_verified remains false and
 * verified_at remains null, consistent with the schema.
 *
 * Security considerations include never storing raw credentials (only
 * password_hash on todo_app_users) and generating non‑guessable session_token
 * and refresh token values. Client metadata such as ip and user_agent should be
 * captured in todo_app_sessions for security analytics and downstream business
 * events, aligning with fields present in the Auth schema.
 *
 * Related operations in this authentication workflow are the refresh endpoint
 * for token renewal, the email verification confirmation endpoint for verifying
 * target_email, and the logout endpoint that records revocation via
 * todo_app_session_revocations and sets revoked_at on todo_app_sessions. Error
 * handling should report validation failures (e.g., invalid email format)
 * without exposing sensitive internals or raw token values.
 *
 * @param props.connection
 * @param props.body Guest join payload (optional email and client context).
 * @setHeader token.access Authorization
 *
 * @path /auth/guestVisitor/join
 * @accessor api.functional.auth.guestVisitor.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Guest join payload (optional email and client context). */
    body: ITodoAppGuestVisitor.IJoin;
  };
  export type Body = ITodoAppGuestVisitor.IJoin;
  export type Response = ITodoAppGuestVisitor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guestVisitor/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guestVisitor/join";
  export const random = (): ITodoAppGuestVisitor.IAuthorized =>
    typia.random<ITodoAppGuestVisitor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Rotate todo_app_refresh_tokens and return new credentials for guestVisitor;
 * extend or reissue todo_app_sessions as needed.
 *
 * This operation accepts a refresh token and returns fresh authentication
 * credentials for the current guestVisitor subject. According to the Auth
 * schema, the refresh token information is stored in todo_app_refresh_tokens,
 * which includes token_hash for lookup, parent_id for rotation chaining,
 * issued_at and expires_at for validity, and rotated_at or revoked_at for
 * lifecycle control. On valid use, the system creates a new child record
 * (rotation) and marks the prior token's rotated_at while preserving revocation
 * fields when applicable.
 *
 * The access session context is represented by todo_app_sessions with issued_at
 * and expires_at used to determine session validity windows. Depending on
 * policy, the same session may be extended or a new session may be created,
 * using the fields ip and user_agent as available context. Any revocation
 * action is recorded via revoked_at and revoked_reason on the session and may
 * also be captured in todo_app_session_revocations for explicit provenance.
 *
 * The subject account is stored in todo_app_users, where fields like status,
 * email_verified, and verified_at can be consulted to ensure the account is
 * eligible for continued authentication. If business policies deny refresh for
 * certain status values, the endpoint must respond accordingly while avoiding
 * disclosure of sensitive internals.
 *
 * Security considerations include strict validation of token_hash
 * correspondence, rotation semantics that render the prior token unusable after
 * successful refresh, and consistent handling of expiry based on expires_at
 * values in both todo_app_refresh_tokens and todo_app_sessions. Client context
 * (ip, user_agent) may be used for anomaly detection consistent with the
 * schema.
 *
 * This endpoint is used together with the guest join operation and complements
 * verification and logout flows. Errors differentiate between invalid/expired
 * tokens and policy gating while maintaining consistent, privacy‑preserving
 * messages.
 *
 * @param props.connection
 * @param props.body Refresh token request payload (token and client context).
 * @setHeader token.access Authorization
 *
 * @path /auth/guestVisitor/refresh
 * @accessor api.functional.auth.guestVisitor.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token request payload (token and client context). */
    body: ITodoAppGuestVisitor.IRefreshRequest;
  };
  export type Body = ITodoAppGuestVisitor.IRefreshRequest;
  export type Response = ITodoAppGuestVisitor.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guestVisitor/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guestVisitor/refresh";
  export const random = (): ITodoAppGuestVisitor.IAuthorized =>
    typia.random<ITodoAppGuestVisitor.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Revoke current session in todo_app_sessions and create
 * todo_app_session_revocations for guestVisitor logout.
 *
 * This operation terminates the caller’s active session by updating the
 * corresponding todo_app_sessions record with revoked_at and an optional
 * revoked_reason. To ensure auditability, a single record is inserted into
 * todo_app_session_revocations for that session, covering the fields
 * revoked_at, revoked_by (e.g., "user"), and a free‑form reason consistent with
 * the schema.
 *
 * The endpoint requires the caller to be authenticated as a guestVisitor. It
 * does not alter the underlying todo_app_users identity record; it only affects
 * session validity and related refresh tokens per policy. The implementation
 * should also consider invalidating outstanding refresh tokens associated with
 * the session via todo_app_refresh_tokens by setting revoked_at and
 * revoked_reason when applicable.
 *
 * Security considerations include idempotent handling (revoking an already
 * revoked session returns success without additional state changes) and
 * avoiding disclosure of token internals. Client context (ip, user_agent)
 * captured in todo_app_sessions remains available for subsequent audits.
 *
 * This operation is typically used after join or refresh and complements the
 * refresh flow and email verification steps. Errors include missing
 * authentication and policy-based denials.
 *
 * On success, the response returns a concise summary derived from
 * todo_app_session_revocations for traceability.
 *
 * @param props.connection
 * @param props.body Logout request payload (optional reason or scope).
 * @path /auth/guestVisitor/logout
 * @accessor api.functional.auth.guestVisitor.logout
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function logout(
  connection: IConnection,
  props: logout.Props,
): Promise<logout.Response> {
  return true === connection.simulate
    ? logout.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...logout.METADATA,
          path: logout.path(),
          status: null,
        },
        props.body,
      );
}
export namespace logout {
  export type Props = {
    /** Logout request payload (optional reason or scope). */
    body: ITodoAppSessionRevocation.ICreate;
  };
  export type Body = ITodoAppSessionRevocation.ICreate;
  export type Response = ITodoAppSessionRevocation.ISummary;

  export const METADATA = {
    method: "POST",
    path: "/auth/guestVisitor/logout",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guestVisitor/logout";
  export const random = (): ITodoAppSessionRevocation.ISummary =>
    typia.random<ITodoAppSessionRevocation.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: logout.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: logout.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
