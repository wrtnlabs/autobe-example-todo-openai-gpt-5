import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppEmailVerification } from "../../../../../../structures/ITodoAppEmailVerification";

/**
 * Insert new todo_app_email_verifications row and trigger delivery for
 * verification.
 *
 * This operation generates a new verification entry in
 * todo_app_email_verifications for the provided email address or user context.
 * The record sets target_email, token_hash (derived from an opaque token),
 * sent_at, and expires_at based on policy. For repeated failures, failure_count
 * can support rate-limiting and diagnostics as indicated by the schema fields.
 *
 * No session is required to use this endpoint, and responses remain generic so
 * as not to reveal whether a matching account exists. The underlying
 * todo_app_users record will be updated later by the verification confirmation
 * endpoint to set email_verified and verified_at.
 *
 * Security considerations include applying rate limits and ensuring that token
 * values are generated with sufficient entropy and persisted only as
 * token_hash. The endpoint does not modify todo_app_users directly and avoids
 * exposing sensitive internal details.
 *
 * This operation is typically used after the guest join flow when a
 * verification email failed to arrive or expired, and it pairs with the
 * verification confirmation endpoint. It is independent of session state.
 *
 * Errors include invalid input and policy-based throttling for excessive
 * requests.
 *
 * @param props.connection
 * @param props.body Resend verification request payload (email or user hint per
 *   policy).
 * @path /auth/guestVisitor/email/verify/resend
 * @accessor api.functional.auth.guestVisitor.email.verify.resend.resendVerification
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function resendVerification(
  connection: IConnection,
  props: resendVerification.Props,
): Promise<resendVerification.Response> {
  return true === connection.simulate
    ? resendVerification.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...resendVerification.METADATA,
          path: resendVerification.path(),
          status: null,
        },
        props.body,
      );
}
export namespace resendVerification {
  export type Props = {
    /** Resend verification request payload (email or user hint per policy). */
    body: ITodoAppEmailVerification.IResendRequest;
  };
  export type Body = ITodoAppEmailVerification.IResendRequest;
  export type Response = ITodoAppEmailVerification.ISummary;

  export const METADATA = {
    method: "POST",
    path: "/auth/guestVisitor/email/verify/resend",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guestVisitor/email/verify/resend";
  export const random = (): ITodoAppEmailVerification.ISummary =>
    typia.random<ITodoAppEmailVerification.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: resendVerification.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: resendVerification.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
