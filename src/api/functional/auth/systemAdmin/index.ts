import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppSystemAdminJoin } from "../../../structures/ITodoAppSystemAdminJoin";
import { ITodoAppSystemAdmin } from "../../../structures/ITodoAppSystemAdmin";
import { ITodoAppSystemAdminLogin } from "../../../structures/ITodoAppSystemAdminLogin";
import { ITodoAppSystemAdminRefresh } from "../../../structures/ITodoAppSystemAdminRefresh";
export * as email from "./email/index";
export * as password from "./password/index";

/**
 * Register a systemAdmin using todo_app_users and grant role in
 * todo_app_systemadmins.
 *
 * This endpoint registers a new system administrator by inserting a user row
 * into todo_app_users and establishing an initial role grant in
 * todo_app_systemadmins. The todo_app_users table stores email for login,
 * password_hash for credential verification, status to control lifecycle (e.g.,
 * active or pending_verification), and email_verified/verified_at for
 * verification policy. The admin role history is captured in
 * todo_app_systemadmins with granted_at and optional revoked_at to preserve
 * governance history.
 *
 * On successful registration, the service can initialize authentication
 * artifacts: a session in todo_app_sessions with issued_at, expires_at,
 * optionally ip and user_agent, and a refresh token in todo_app_refresh_tokens
 * with issued_at/expires_at and token_hash for secure lookup. These artifacts
 * are returned through the authorized response contract.
 *
 * The operation integrates with policy and configuration surfaces via read-only
 * logic as needed, but the primary persistence is restricted to todo_app_users
 * and todo_app_systemadmins. It does not touch private todo content tables,
 * preserving separation of concerns.
 *
 * Security considerations match the schema: no plaintext password storage
 * (password_hash only), and the email field must be unique. Account status in
 * todo_app_users determines whether the new admin can immediately log in;
 * email_verified and verified_at reflect verification requirements.
 *
 * Related operations include login for existing admins, refresh to renew tokens
 * based on todo_app_refresh_tokens, and email verification flows backed by
 * todo_app_email_verifications. Error handling should reflect uniqueness on
 * email and policy validation for password strength.
 *
 * @param props.connection
 * @param props.body Registration payload for creating a systemAdmin account.
 * @setHeader token.access Authorization
 *
 * @path /auth/systemAdmin/join
 * @accessor api.functional.auth.systemAdmin.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Registration payload for creating a systemAdmin account. */
    body: ITodoAppSystemAdminJoin.ICreate;
  };
  export type Body = ITodoAppSystemAdminJoin.ICreate;
  export type Response = ITodoAppSystemAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/systemAdmin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/systemAdmin/join";
  export const random = (): ITodoAppSystemAdmin.IAuthorized =>
    typia.random<ITodoAppSystemAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Login a systemAdmin via todo_app_users and issue session/refresh artifacts.
 *
 * This endpoint validates the admin’s email and password against
 * todo_app_users, using the stored password_hash. The account’s status and
 * email_verified flags determine eligibility to authenticate. On success, it
 * records a new session in todo_app_sessions with issued_at/expires_at and
 * optional ip/user_agent, and creates a refresh token in
 * todo_app_refresh_tokens with issued_at/expires_at and token_hash.
 *
 * The todo_app_login_attempts table may be recorded separately by the
 * application for success/failure analytics (success, failure_reason,
 * occurred_at, ip, user_agent), but this endpoint focuses on establishing
 * authenticated state.
 *
 * Returned data follows the authorized contract, carrying access and refresh
 * tokens derived from todo_app_sessions and todo_app_refresh_tokens. The user’s
 * last_login_at in todo_app_users can be updated to reflect the successful
 * login event.
 *
 * This operation should not touch private todo data and is restricted to
 * authentication surfaces. It interoperates with email verification flows
 * tracked by todo_app_email_verifications, where email_verified and verified_at
 * govern access.
 *
 * Related endpoints are refresh for token renewal and logout or revoke sessions
 * backed by todo_app_session_revocations. Errors include invalid credentials,
 * suspended status in status, or unverified email as applicable to business
 * policy.
 *
 * @param props.connection
 * @param props.body Login credentials for systemAdmin authentication.
 * @setHeader token.access Authorization
 *
 * @path /auth/systemAdmin/login
 * @accessor api.functional.auth.systemAdmin.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Login credentials for systemAdmin authentication. */
    body: ITodoAppSystemAdminLogin.ICreate;
  };
  export type Body = ITodoAppSystemAdminLogin.ICreate;
  export type Response = ITodoAppSystemAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/systemAdmin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/systemAdmin/login";
  export const random = (): ITodoAppSystemAdmin.IAuthorized =>
    typia.random<ITodoAppSystemAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh tokens for systemAdmin using todo_app_refresh_tokens and
 * todo_app_sessions.
 *
 * This endpoint processes a refresh token associated with a session in
 * todo_app_sessions. The request includes a refresh token whose token_hash maps
 * to a row in todo_app_refresh_tokens that is not expired and not
 * revoked/rotated. On valid input, the service rotates the token (sets
 * rotated_at on the current record, creates a new child token referencing
 * parent_id) and can update todo_app_sessions metadata such as updated_at.
 *
 * The response returns new access credentials following the authorized
 * contract. Rotation and revocation states are enforced strictly using fields
 * like expires_at, rotated_at, revoked_at, and revoked_reason in
 * todo_app_refresh_tokens and revoked_at/revoked_reason in todo_app_sessions if
 * applicable.
 *
 * Security posture follows the schema’s recommendation to avoid plaintext
 * storage of tokens, using token_hash for durable lookups. No private todo
 * content is accessed through this flow, and the user’s core account data
 * remains in todo_app_users.
 *
 * This operation is complementary to login for first-time access and to
 * logout/session revocation that may set entries in
 * todo_app_session_revocations. Errors include expired or revoked tokens, or
 * mismatched session associations.
 *
 * Policy may cap session lifetimes by comparing issued_at/expires_at across
 * both the session and refresh chain to enforce maximum durations.
 *
 * @param props.connection
 * @param props.body Refresh request containing the refresh token.
 * @setHeader token.access Authorization
 *
 * @path /auth/systemAdmin/refresh
 * @accessor api.functional.auth.systemAdmin.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh request containing the refresh token. */
    body: ITodoAppSystemAdminRefresh.ICreate;
  };
  export type Body = ITodoAppSystemAdminRefresh.ICreate;
  export type Response = ITodoAppSystemAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/systemAdmin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/systemAdmin/refresh";
  export const random = (): ITodoAppSystemAdmin.IAuthorized =>
    typia.random<ITodoAppSystemAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
