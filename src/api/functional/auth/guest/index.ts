import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoMvpGuest } from "../../../structures/ITodoMvpGuest";
import { ITodoMvpGuestRefresh } from "../../../structures/ITodoMvpGuestRefresh";

/**
 * Register a guest identity in todo_mvp_guests and create a session in
 * todo_mvp_sessions, issuing initial JWTs.
 *
 * This endpoint registers an anonymous guest identity and issues initial JWT
 * credentials suitable for temporary, unauthenticated usage scenarios. It
 * persists a minimal identity row in the Actors.todo_mvp_guests table,
 * leveraging its id (UUID primary key), created_at, and updated_at columns to
 * provide durable but privacy-respecting identification for session management.
 * The design intentionally stores no credential fields for guests, aligning
 * with the table’s minimal footprint described in the Prisma schema comments.
 *
 * Upon creation of the guest identity, the service also creates a session
 * record in Auth.todo_mvp_sessions. That session row uses session_token_hash to
 * store a hashed representation of the issued token, and maintains lifecycle
 * fields created_at, updated_at, last_accessed_at, and expires_at. For guest
 * sessions, both todo_mvp_user_id and todo_mvp_admin_id remain null by design,
 * as guests are not authenticated users or admins. The expires_at field governs
 * absolute token lifetime, while last_accessed_at supports inactivity policies
 * as described in the schema commentary.
 *
 * From a role perspective, guests have no credentials and do not perform
 * password-based login. Therefore, this join operation is the only way to
 * establish a guest session. The returned ITodoMvpGuest.IAuthorized payload
 * encapsulates the tokens and identifies the session created in
 * todo_mvp_sessions so that subsequent requests can be validated without
 * exposing any personal data.
 *
 * Security considerations include hashing any bearer token into
 * todo_mvp_sessions.session_token_hash, avoiding storage of plaintext tokens.
 * The implementation must honor expires_at and update last_accessed_at on use.
 * Because guests are intentionally minimal, the join flow avoids collecting
 * unnecessary attributes, honoring privacy requirements emphasized in the
 * todo_mvp_guests schema documentation.
 *
 * Related operations: use POST /auth/guest/refresh to renew credentials before
 * expires_at. There is no password-based login for guests by design, and guests
 * cannot access protected Todo data per business rules; they may only operate
 * within public or guest-scoped capabilities until they become authenticated
 * users via a separate user registration flow outside the guest scope.
 *
 * @param props.connection
 * @param props.body Optional client hints for creating a guest identity;
 *   typically empty for MVP.
 * @setHeader token.access Authorization
 *
 * @path /auth/guest/join
 * @accessor api.functional.auth.guest.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Optional client hints for creating a guest identity; typically empty
     * for MVP.
     */
    body: ITodoMvpGuest.ICreate;
  };
  export type Body = ITodoMvpGuest.ICreate;
  export type Response = ITodoMvpGuest.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guest/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guest/join";
  export const random = (): ITodoMvpGuest.IAuthorized =>
    typia.random<ITodoMvpGuest.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh guest JWTs by rotating the session in todo_mvp_sessions using
 * session_token_hash and lifecycle fields.
 *
 * This endpoint renews guest credentials by validating and rotating the
 * corresponding session stored in Auth.todo_mvp_sessions. The Prisma schema
 * describes session_token_hash as a hashed representation uniquely identifying
 * a session; the service hashes the provided refresh token and matches it
 * against this column. The session’s lifecycle fields—created_at, updated_at,
 * last_accessed_at, and expires_at—are used to enforce absolute TTL and idle
 * activity policies during refresh.
 *
 * When the refresh succeeds, the service updates updated_at and
 * last_accessed_at, rotates the underlying token by updating
 * session_token_hash, and extends expires_at to a new absolute expiration. The
 * revoked_at field, when null, indicates the session has not been explicitly
 * invalidated; if set, refresh must be denied. For guest sessions,
 * todo_mvp_user_id and todo_mvp_admin_id remain null by design, reflecting that
 * the actor is an anonymous guest rather than an authenticated user or admin.
 *
 * This operation is specific to the guest role and complements the guest join
 * flow. Guests do not perform password-based login and therefore rely on join
 * followed by periodic refresh. The response type ITodoMvpGuest.IAuthorized
 * packages the newly issued credentials so clients can continue interacting
 * under the same guest identity established earlier.
 *
 * Security considerations: tokens are never stored in plaintext; only their
 * hashes are persisted in session_token_hash. The implementation must verify
 * expires_at and any business-specific idle constraints based on
 * last_accessed_at. On successful refresh, the previous token becomes invalid,
 * preventing token replay.
 *
 * Related operations: prior to using this endpoint, a client must have executed
 * POST /auth/guest/join to obtain an initial session. Refresh can be repeated
 * until session constraints in todo_mvp_sessions prevent further renewal (e.g.,
 * hard expiration via expires_at or explicit invalidation via revoked_at).
 *
 * @param props.connection
 * @param props.body Refresh token payload required to locate and rotate the
 *   guest session.
 * @setHeader token.access Authorization
 *
 * @path /auth/guest/refresh
 * @accessor api.functional.auth.guest.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh token payload required to locate and rotate the guest
     * session.
     */
    body: ITodoMvpGuestRefresh.IRequest;
  };
  export type Body = ITodoMvpGuestRefresh.IRequest;
  export type Response = ITodoMvpGuest.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guest/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guest/refresh";
  export const random = (): ITodoMvpGuest.IAuthorized =>
    typia.random<ITodoMvpGuest.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
