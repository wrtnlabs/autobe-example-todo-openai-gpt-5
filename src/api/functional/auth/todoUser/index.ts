import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoAppTodoUser } from "../../../structures/ITodoAppTodoUser";
import { ITodoAppTodoUserLogin } from "../../../structures/ITodoAppTodoUserLogin";
import { ITodoAppTodoUserRefresh } from "../../../structures/ITodoAppTodoUserRefresh";
export * as email from "./email/index";
export * as password from "./password/index";
export * as sessions from "./sessions/index";

/**
 * Register a new member in todo_app_users and assign todo_app_todousers; create
 * session/refresh in Auth tables.
 *
 * Purpose and functionality: Registers a new member user and issues
 * authentication tokens based on the Actors and Auth schema. Uses
 * todo_app_users.email as the unique login identifier, stores credentials in
 * todo_app_users.password_hash, initializes account lifecycle via
 * todo_app_users.status and todo_app_users.email_verified, and stamps
 * timestamps like todo_app_users.created_at and updated_at according to policy.
 * A role assignment entry is inserted into todo_app_todousers with granted_at
 * set and revoked_at null, marking the account as a current todoUser.
 *
 * Implementation details: After persisting the user (todo_app_users), this
 * operation creates a session in todo_app_sessions with session_token,
 * issued_at, expires_at, ip, and user_agent as available, and then inserts a
 * first refresh token in todo_app_refresh_tokens with token_hash, issued_at,
 * expires_at, and parent_id null. A success record in todo_app_login_attempts
 * is appended with success=true and failure_reason null. The response
 * encapsulates the authorized context (access/refresh semantics derived from
 * session/refresh records) in an application DTO; no plaintext secrets are
 * persisted beyond token/refresh hashes as per schema comments.
 *
 * Role-specific integration: This is for the "todoUser" role and therefore
 * populates todo_app_todousers for the created user. It does not create
 * admin/system role records (todo_app_systemadmins) and does not assign guest
 * history (todo_app_guestvisitors) unless governance workflows do so
 * separately.
 *
 * Security considerations: Passwords are never stored in plaintext; only
 * todo_app_users.password_hash is persisted. Session validity and rotation
 * lifetimes are controlled by todo_app_sessions.expires_at and
 * todo_app_refresh_tokens.expires_at. Account admission can honor policies via
 * todo_app_users.status (e.g., "pending_verification" vs. "active") and email
 * verification state via todo_app_users.email_verified and verified_at. All
 * tokens should be conveyed to the client via the response object and audited
 * via todo_app_audit_logs if required by policy.
 *
 * Related operations: Clients typically proceed to protected APIs using the
 * returned credentials. For email verification, see the email verification
 * consumption endpoint that manipulates todo_app_email_verifications. For token
 * renewal, use the refresh endpoint that appends a new child in
 * todo_app_refresh_tokens and updates rotation fields. Errors include duplicate
 * email (todo_app_users.email uniqueness), invalid password policy, or policy
 * blocks implied by todo_app_users.status values.
 *
 * @param props.connection
 * @param props.body Registration payload for creating a todoUser account and
 *   initial session.
 * @setHeader token.access Authorization
 *
 * @path /auth/todoUser/join
 * @accessor api.functional.auth.todoUser.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Registration payload for creating a todoUser account and initial
     * session.
     */
    body: ITodoAppTodoUser.ICreate;
  };
  export type Body = ITodoAppTodoUser.ICreate;
  export type Response = ITodoAppTodoUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/todoUser/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/todoUser/join";
  export const random = (): ITodoAppTodoUser.IAuthorized =>
    typia.random<ITodoAppTodoUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Login for todoUser using todo_app_users; creates todo_app_sessions and
 * todo_app_refresh_tokens and logs attempts.
 *
 * Purpose and functionality: Authenticates a user identified by
 * todo_app_users.email using a submitted credential compared against
 * todo_app_users.password_hash. On success, sets todo_app_users.last_login_at
 * and returns an authorized DTO while preserving role membership via
 * todo_app_todousers (granted_at not revoked_at).
 *
 * Implementation details: Creates a todo_app_sessions row with session_token,
 * issued_at, expires_at, and optional ip/user_agent, then inserts a
 * todo_app_refresh_tokens row with token_hash, issued_at, and expires_at.
 * Appends a todo_app_login_attempts record with success=true on successful
 * login or success=false with failure_reason (e.g., "invalid_credentials" or
 * account state) for failures. Enforces lifecycle gates using
 * todo_app_users.status (e.g., block when "suspended") and email gating using
 * todo_app_users.email_verified and verified_at according to policy.
 *
 * Role-specific integration: Confirms that the authenticating account currently
 * holds the member role by checking an active row in todo_app_todousers
 * (revoked_at IS NULL). This endpoint is specific to todoUser and does not
 * authenticate systemAdmin.
 *
 * Security considerations: Never expose whether the email exists; failures
 * should be logged in todo_app_login_attempts with generic failure_reason.
 * Sessions must honor todo_app_sessions.expires_at and revocation flows using
 * revoked_at and optional todo_app_session_revocations. Refresh tokens must be
 * stored as token_hash within todo_app_refresh_tokens and rotated on subsequent
 * refresh.
 *
 * Related operations: Use the refresh endpoint for renewing tokens bound to an
 * existing session (todo_app_sessions and todo_app_refresh_tokens). For
 * password resets, see password reset request and confirmation endpoints using
 * todo_app_password_resets.
 *
 * @param props.connection
 * @param props.body Login payload with email and password for todoUser
 *   authentication.
 * @setHeader token.access Authorization
 *
 * @path /auth/todoUser/login
 * @accessor api.functional.auth.todoUser.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Login payload with email and password for todoUser authentication. */
    body: ITodoAppTodoUserLogin.IRequest;
  };
  export type Body = ITodoAppTodoUserLogin.IRequest;
  export type Response = ITodoAppTodoUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/todoUser/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/todoUser/login";
  export const random = (): ITodoAppTodoUser.IAuthorized =>
    typia.random<ITodoAppTodoUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh tokens for todoUser using todo_app_refresh_tokens rotation and
 * todo_app_sessions validity.
 *
 * Purpose and functionality: Accepts a refresh token and renews access
 * credentials for a member account. Validates the token via
 * todo_app_refresh_tokens.token_hash, respects expires_at, and checks
 * rotated_at/revoked_at to enforce single-use rotation. Ensures the parent
 * session in todo_app_sessions is valid (not expired per expires_at and not
 * revoked via revoked_at).
 *
 * Implementation details: Creates a new child row in todo_app_refresh_tokens
 * with parent_id referencing the previous token, sets issued_at/expires_at, and
 * marks the previous token’s rotated_at. Session metadata (e.g., updated_at or
 * ip/user_agent) may be updated according to policy. The response carries
 * renewed authorization context in the standardized DTO.
 *
 * Role-specific integration: Confirms that the owning user still has an active
 * todoUser role via an unrevoked row in todo_app_todousers and that the user’s
 * account lifecycle in todo_app_users.status allows continued authentication.
 *
 * Security considerations: Tokens are stored as token_hash only; plaintext
 * values are never persisted. Rotation is strict: an already-rotated token
 * (rotated_at not null) is rejected. Revocation actions are respected using
 * todo_app_refresh_tokens.revoked_at/revoked_reason and
 * todo_app_sessions.revoked_at/revoked_reason.
 *
 * Related operations: If the user needs to end the session, use the logout
 * endpoint that records a revocation via todo_app_session_revocations. For
 * credential changes, see change password, which should revoke others' sessions
 * per policy.
 *
 * @param props.connection
 * @param props.body Refresh payload carrying the refresh token to rotate and
 *   renew access.
 * @setHeader token.access Authorization
 *
 * @path /auth/todoUser/refresh
 * @accessor api.functional.auth.todoUser.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh payload carrying the refresh token to rotate and renew
     * access.
     */
    body: ITodoAppTodoUserRefresh.IRequest;
  };
  export type Body = ITodoAppTodoUserRefresh.IRequest;
  export type Response = ITodoAppTodoUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/todoUser/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/todoUser/refresh";
  export const random = (): ITodoAppTodoUser.IAuthorized =>
    typia.random<ITodoAppTodoUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logout current session by updating todo_app_sessions and inserting into
 * todo_app_session_revocations; optionally revoke current refresh token.
 *
 * Purpose and functionality: Ends the authenticated session for a todoUser by
 * marking the session as revoked in todo_app_sessions and recording a
 * revocation entry in todo_app_session_revocations. May also mark the currently
 * held refresh token as revoked in todo_app_refresh_tokens.
 *
 * Implementation details: Identifies the current session via the authenticated
 * context, sets revoked_at and revoked_reason, and creates the associated
 * todo_app_session_revocations row with revoked_by (e.g., "user") and optional
 * reason. No user record changes are required.
 *
 * Role-specific integration: Requires an authenticated todoUser. The operation
 * affects only the caller’s current session.
 *
 * Security considerations: Ensure idempotency—repeated calls should succeed
 * without error if the session is already revoked. Avoid exposing other session
 * details. Consider appending an audit log entry in todo_app_audit_logs with
 * action="logout".
 *
 * Related operations: To revoke all other devices, use the revokeOthers
 * endpoint. To renew access later, use login or refresh.
 *
 * @param props.connection
 * @path /auth/todoUser/logout
 * @accessor api.functional.auth.todoUser.logout
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function logout(connection: IConnection): Promise<void> {
  return true === connection.simulate
    ? logout.simulate(connection)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...logout.METADATA,
          path: logout.path(),
          status: null,
        },
      );
}
export namespace logout {
  export const METADATA = {
    method: "POST",
    path: "/auth/todoUser/logout",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/todoUser/logout";
  export const random = (): void => typia.random<void>();
  export const simulate = (_connection: IConnection): void => {
    return random();
  };
}
